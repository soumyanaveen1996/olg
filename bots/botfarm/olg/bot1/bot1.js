(function(){
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	var __webpack_modules__ = ({

/***/ "../../Bitbucket/frontmjs/core/ALLConstants.js":
/*!*****************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/ALLConstants.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALL_CONSTANTS: function() { return /* binding */ ALL_CONSTANTS; },\n/* harmony export */   DEVICE_ORIENTATION: function() { return /* binding */ DEVICE_ORIENTATION; },\n/* harmony export */   LLM_SERVICE: function() { return /* binding */ LLM_SERVICE; },\n/* harmony export */   OPEN_AI_ROLES: function() { return /* binding */ OPEN_AI_ROLES; },\n/* harmony export */   PREFIXES: function() { return /* binding */ PREFIXES; },\n/* harmony export */   SYSTEM_INTENTS: function() { return /* binding */ SYSTEM_INTENTS; }\n/* harmony export */ });\nlet ALL_CONSTANTS = {\n  PERSISTED_FIELD_PREFIX: 'PERSISTED_FIELD_',\n  AUTO_SAVE_BUFFER_FIELD: 'AUTO_SAVE_BUFFER_',\n  PERSISTED_STORAGE: 'PERSISTENT_STORAGE_',\n  TO_SYNC_WITH_BACKEND: 'toSyncWithBackend',\n  AUTO_SAVE_INTENT_EDGE: 'autoSaveIntentEdge',\n  AUTO_SAVE_INTENT_CLOUD: 'autoSaveIntentCloud',\n  ACTIVITY_COLLECTION: '_activity',\n  TABLES: {\n    CHANGE_ACTION: 'change',\n    APPEND_ACTION: 'append',\n    CHANGE_FILTER_ACTION: 'changeFilter', //This is to respond to an edit filter request\n    RESULTS_FILTER_ACTION: 'resultsFilter',\n    VALIDATION_FILTER_ACTION: 'validationFilter',\n    CHANGE_FILTER_FORM_ACTION: 'changeFilterForm', //This is to automatically change fields within the filter form\n    RENAME_FILTER_ACTION: 'renameFilter',\n    MULTIPLE_SELECTION_ACTION: 'multipleSelection',\n    CLEAR_FILTER_ACTION: 'clearFilter',\n    CLEAR_SEARCH_ACTION: 'clearSearch',\n  },\n  CALENDAR: {\n    MONTHLY_VIEW: 0,\n    WEEKLY_VIEW: 1,\n    DAILY_VIEW: 2\n  },\n  /**\n   * @deprecated since beta 2. Import PREFIXES directly\n   */\n  PREFIXES: {\n    AUDIT: 'audit',\n    INDEX: 'index',\n    FIELD_BUFFER_PREFIX: 'AUTOSAVED_FIELD_',\n    FIELD_LOOKUP_PREFIX: 'LOOKUP_FIELD_',\n    FILTER_PREFIX: 'filter_prefix_',\n    ALL_FILTERS: 'filter_prefix_all_filters'\n  },\n  DB_OPERATIONS: {\n    INSERT: 'insert',\n    UPDATE: 'update',\n    UPSERT: 'upsert',\n    DELETE: 'delete',\n    QUERY: 'query'\n  },\n  RESPONSES: {\n    FORM_RESPONSE: 'form_response',\n    TABLE_RESPONSE: 'table_response',\n    CONTAINER_RESPONSE: 'container_response',\n    VIDEO_CALL: 'videoCall',\n    TIMELINE_RESPONSE: \"timelineResponse\",\n    SURVEY_RESPONSE: 'surveyResponse'\n  },\n  ACTIONS: {\n    ACTION: 'action',\n    SEARCH: 'search',\n    ON_ACTION: 'onAction',\n    ON_SEARCH: 'onSearch',\n    ON_REFRESH: 'onRefresh',\n    ON_ERROR: 'onError',\n    ERROR: 'error',\n    DISCARD: 'onDiscard',\n    MOVE: 'move',\n    CLICK: 'click',\n    COMPLETION: 'completion',\n    CONFIRM: 'confirm',\n    ON_CONFIRM: 'onConfirm',\n    CANCEL: 'cancel',\n    CLOSE: 'close',\n    RESULTS: 'results',\n    MAP_RESULTS: 'map_results',\n    CHANGE: 'change',\n    DELETE_ROW: 'deleteRow',\n    ADD_ROW: 'append',\n    CHANGE_COLUMN_TEMPLATE: 'changeColumnTemplate',\n    VALIDATION: 'validation',\n    QUICK_ACTION: \"quickAction\",\n    ON_FIELD_ACTION: 'onFieldAction',\n    ON_SELECTION: 'onSelection',\n    ON_MENU_ACTION: 'onMenuAction',\n    ON_DOWNLOAD: 'onDownload',\n    ON_DELETE: 'onDelete',\n    ON_SAVE: 'onSave',\n    ON_PREVIOUS_PAGE: 'previousPage',\n    ON_NEXT_PAGE: 'nextPage',\n    ON_FILTER_ACTION: 'filter',\n    ON_EDIT_FILTER_ACTION: 'editFilter',\n    ON_FILTER_DELETE_ACTION: 'filterDelete',\n    ON_CREATE_OVERLAY: 'createOverlay',\n    ON_EDIT_OVERLAY: 'editOverlay',\n    ON_DELETE_OVERLAY: 'deleteOverlay',\n    ON_TOP_MENU_ACTION: 'topMenu',\n    ON_SHOW_AREAS: 'showAreas',\n    SURVEY_RUN: 'runSurvey',\n    SURVEY_START: 'start',\n    SURVEY_ADD_QUESTION: 'addQuestion',\n    SURVEY_NEXT_QUESTION: 'nextQuestion',\n    SURVEY_END: 'end',\n    SURVEY_SHOW_CLOSE_PAGE: 'showClosePage',\n    SURVEY_PREVIOUS_QUESTION: 'previousQuestion'\n  },\n  CALL_ACTIONS: {\n    CALL: 'call',\n    HAND_UP: 'hangUp',\n    RING_START: 'ringStart',\n    CALL_START: 'callEnd',\n    CALL_END: 'callEnd'\n  },\n  MESSAGE_TYPES: {\n    VOICE_CALL_RESPONSE: 'voice_call_response',\n    HTML_RESPONSE: 'html_response'\n  },\n  COLLECTION_TYPES: {\n    CALENDAR: 'calendar',\n    TABLE: 'table',\n    MAP: 'map'\n  },\n  POINT_TYPE: {\n    MARKER: 'marker',\n    ROUTE: 'route',\n    PLANE_ROUTE: 'planeRoute'\n  },\n  MARKER_ICON_TYPE: {\n    VESSEL: 'arrow',\n    AIRCRAFT: 'aircraft',\n    CIRCLE: 'circle',\n    POI: 'poi'\n  },\n  FILE_SCOPE: {\n    CONVERSATION: 'conversation',\n    BOT: 'bot',\n    DOMAIN: 'domain'\n  },\n  SYSTEM_DB: 'frontmai',\n  COMMON_FIELDS: {\n    LAST_MAIN_TIMESTAMP: 'lastMainTimeStamp'\n  },\n  SYSTEM_TABLES: {\n    COUNTRIES: '_countries'\n  },\n  SYSTEM_FIELDS: {\n    COUNTRIES: '_countries',\n    COUNTRY_NAMES: '_countriesNames'\n  },\n  CLIENTS: {\n    MOBILECLIENT: 'mobile',\n    WEBCLIENT: 'web',\n    EDGE_WEBCLIENT: 'web2'\n  },\n  LOCATIONS: {\n    EDGE: 'Edge',\n    CLOUD: 'Cloud'\n  },\n  INTENTS: {\n    NO_INTENT: 'input.unknown'\n  },\n  TYPES: {\n    COLLECTION: \"collection\",\n    DOC: \"doc\",\n    FIELD: \"field\",\n    CONTAINER: \"container\"\n  },\n  NLP: {\n    ENGINES: {\n      OPEN_AI: \"openAI\",\n      LEX: \"lex\",\n      DIALOGFLOW: \"dialogflow\"\n    },\n    FIELDS: {\n      EMMA_PROMPT_KEY: \"emmaPrompt\",\n      DEFAULT_PROMPT_KEY: \"defaultPrompt\",\n      DEFAULT_CHAT_PROMPT_KEY: \"defaultChatPrompt\",\n      EMMA_NLP_KEY: \"emmaNLP\",\n      DEFAULT_NLP_KEY: \"defaultNLP\",\n      DEFAULT_CHAT_NLP_KEY: \"defaultChatNLP\",\n      WEB_BROWSER_COMMON_PROMPT: \"webBrowserCommonPrompt\",\n    }\n  },\n  VIDEO_CALL_ACTIONS: {\n    CREATE_MEETING: \"createMeeting\",\n    JOIN_MEETING: \"joinMeeting\"\n  },\n  TIMELINES: {\n    BOOKMARK: \"bookmark\",\n    VIEW: \"view\",\n    LOAD_MORE: \"loadMore\",\n    REFRESH: \"refresh\",\n    CLOSE: \"close\",\n    SURVEY: \"survey\",\n    ACTIONS: {\n        PUBLISH: 'publish',\n        DELETE: 'delete',\n        SEND_PUSH_NOTIFICATION: 'sendPushNotification'\n    }\n  },\n  SURVEY_STATUS: {\n    PENDING: 'pending',\n    IN_PROGRESS: 'inProgress',\n    DONE: 'done'\n  }\n}\n\nconst PREFIXES = {\n  AUDIT: 'audit',\n  INDEX: 'index',\n  FIELD_BUFFER_PREFIX: 'AUTOSAVED_FIELD_',\n  FIELD_LOOKUP_PREFIX: 'LOOKUP_FIELD_',\n  FILTER_PREFIX: 'filter_prefix_',\n  ALL_FILTERS: 'filter_prefix_all_filters',\n  LLM_CONTEXT: \"LLM_CONTEXT_\"\n}\nconst DEVICE_ORIENTATION = {\n  AUTO_ROTATE: 'auto-rotate',\n  FORCE_PORTRAIT: 'force-portrait',\n  FORCE_LANDSCAPE: 'force-landscape',\n}\n\nconst LLM_SERVICE = {\n  COMPLETION: \"COMPLETION\",\n  CHAT: \"CHAT\",\n  RELEVANT_QUESTIONS: \"RELEVANT_QUESTIONS\"\n}\n\nconst SYSTEM_INTENTS = {\n  GET_RELEVANT_QUESTIONS: \"_getRelevantQuestions\"\n}\n\nconst OPEN_AI_ROLES = {\n  SYSTEM: \"system\",\n  USER: \"user\",\n  ASSISTANT: \"assistant\"\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/ALLConstants.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/API.js":
/*!********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/API.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API: function() { return /* binding */ API; }\n/* harmony export */ });\nclass API {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n  }\n\n  loadServicesForMyDomains() {\n    let tableName = 'APIParameters';\n    let query = [\n      {\n        operand: 'userDomain',\n        value: this._state.currentUserDomain,\n        operator: 'eq',\n      }\n    ];\n    return this._state.db.getData(tableName, query);\n  }\n\n  async createNewService(service) {\n    let tableName = 'APIParameters';\n    let response = await this._state.db.writeData(tableName, service);\n    if (this._.get(response, \"errorMessage\")) {\n      this._state.addSystemErrorToStack(36);\n    }\n  }\n\n  callService(service, options) {\n    let params = {\n      capability: 'GetDataFromAPI',\n      capabilityFileName: 'getDataFromApi',\n      userDomain: this._state.conversation.userDomain,\n      serviceName: service,\n      queryParams: this._.get(options, 'queryParams'),\n      pathParams: this._.get(options, 'pathParams'),\n      header: this._.get(options, 'header'),\n      body: this._.get(options, 'body'),\n      sync: true,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n    };\n    try {\n      return this._state.callCapability(params)\n        .then(response => {\n          this._state.developer.info({\n            message: 'Returned from service successfully',\n            data: this._state.R.toString(response)\n          });\n          if (this._.get(response, 'error')) {\n            this._state.addSystemErrorToStack(37, response.error, response);\n          }\n          return response;\n        })\n        .catch(error => {\n          this._state.addSystemErrorToStack(37, error.message, params);\n          return error;\n        });\n    } catch (err) {\n      this._state.addSystemErrorToStack(37, err.message, params);\n    }\n  }\n\n  createUser(userDetailsArray, emailTemplateName, delayRequired) {\n    let params = {\n      users: userDetailsArray,\n      domain: this._state.currentUserDomain,\n      delayRequired: typeof delayRequired === undefined ? true : delayRequired,\n      emailTemplateName\n    };\n    let invocationType = \"RequestResponse\";\n    if (this._state.messageTypeFromUser === \"payload\") {\n      invocationType = \"Event\"\n    }\n    return this._state.callLambda(\"CreateUserLambda\", params, invocationType).then(response => {\n      this._state.developer.info({\n        message: 'Returned from service create user',\n        data: response,\n      });\n      let payload = JSON.parse(this._state._.get(response, \"Payload\"));\n      if (this._.get(payload, 'error')) {\n        this._state.addSystemErrorToStack(7, payload.error);\n      }\n      return payload;\n    }).catch(error => {\n      this._state.addSystemErrorToStack(7, error.message);\n      this._state.developer.log({\n        message: 'Returned with error',\n        data: error,\n      });\n      return error;\n    });\n  }\n\n  async userExistenceCheck({\n    loginUserName,\n    emailAddress,\n    appType\n  }) {\n    try {\n      let params = {\n        capability: \"CheckUserExists\",\n        capabilityFileName: \"checkUserExists\",\n        appType,\n        loginUserName,\n        emailAddress\n      };\n      let response = await this._state.callCapability(params);\n      this._state.developer.info({\n        message: 'Returned from service create user',\n        data: response,\n      });\n      return response;\n    } catch (error) {\n      this._state.addSystemErrorToStack(7, error.message);\n      this._state.developer.log({\n        message: 'Returned with error',\n        data: error,\n      });\n      return error;\n    }\n  }\n\n  async deleteUser(userIds) {\n    let params = {\n      capability: \"DeleteUser\",\n      capabilityFileName: \"deleteUser\",\n      appType: this._state.currentUserDomain,\n    };\n\n    if (Array.isArray(userIds)) {\n      if (userIds.length === 1) {\n        params.action = \"deleteUser\";\n        params.userId = userIds[0];\n      } else {\n        params.action = \"deleteMultipleUsers\";\n        params.userIdsToDelete = userIds;\n      }\n      return this._state.callCapability(params).then(response => {\n        this._state.developer.info({\n          message: 'DeleteUser response',\n          data: response,\n        });\n        if (this._.get(response, 'error')) {\n          this._state.addSystemErrorToStack(7, response.error);\n        }\n        return response;\n      }).catch(error => {\n        this._state.addSystemErrorToStack(7, error.message);\n        this._state.developer.log({\n          message: 'DeleteUser Returned with error',\n          data: error,\n        });\n        return error;\n      });\n    }\n    return false;\n  }\n\n  async authenticateUser({\n    appType = 'frontmai',\n    userEmail,\n    password,\n    otpToken\n  }) {\n    let params = {\n      capability: \"AuthCapability\",\n      capabilityFileName: \"authCapability\",\n      appType,\n      userEmail,\n      password,\n      action: \"AuthenticateUser\",\n      otpToken // this is the only not mandatory field. However, if the user has setup 2fa, this is a required input\n    };\n    return this._state.callCapability(params).then(response => {\n      return this._.get(response, 'success');\n    }).catch(error => {\n      this._state.developer.log({\n        message: 'Authenticate user returned with error',\n        data: error,\n      });\n      return this._.get(error, 'success');\n    })\n  }\n\n  async encodeFile(fileName) {\n    let params = {\n      capability: 'ConversationFilesCapability',\n      capabilityFileName: 'conversationFilesCapability',\n      targetConversationId: this._state.conversationId,\n      targetFileName: fileName,\n      conversation: this._state.conversation,\n      sync: true,\n      email: this._state.user.userEmail,\n      userId: this._state.user.userId,\n    };\n    return await this._state.callCapability(params);\n  }\n\n  async sendResponse({\n    code = 200,\n    response = {}\n  }) {\n    let finalResponse = {\n      code,\n      ...response\n    }\n    this._state.apiResponse = true;\n    this._state.addResponse(\"payload_response\", finalResponse);\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/API.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Accounts.js":
/*!*************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Accounts.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Accounts: function() { return /* binding */ Accounts; }\n/* harmony export */ });\nclass Accounts {\n  constructor(state) {\n    this['_state'] = state;\n    this['context'] = state.context;\n    this['userId'] = state.user.userId;\n    this['conversation'] = state.conversation;\n    this['location'] = state.location;\n  }\n\n  getBalance(account) {\n    let conversation = this.conversation;\n    let userId = this.userId;\n    let params = {\n      capability: 'MessageQuotaCapability',\n      capabilityFileName: 'messageQuotaCapability',\n      action: 'getSpecificQuota',\n      sync: true,\n      userId: userId,\n      conversation: conversation,\n      botId: account,\n    };\n    return this._state.callCapability(params);\n  }\n\n  storeBalance(account, balance) {\n    let conversation = this.conversation;\n    let userId = this.userId;\n    let params = {\n      capability: 'MessageQuotaCapability',\n      capabilityFileName: 'messageQuotaCapability',\n      action: 'incrementUserAssignedQuota',\n      sync: true,\n      userId: userId,\n      conversation: conversation,\n      stats: {},\n    };\n    params.stats[account] = balance;\n    return this._state.callCapability(params);\n  }\n\n  updateBalance(account, balance) {\n    let conversation = this.conversation;\n    let userId = this.userId;\n    let params = {\n      capability: 'MessageQuotaCapability',\n      capabilityFileName: 'messageQuotaCapability',\n      action: 'updateUserUsedQuota',\n      sync: true,\n      userId: userId,\n      conversation: conversation,\n      stats: {},\n    };\n    params.stats[account] = balance;\n    return this._state.callCapability(params);\n  }\n\n  resetBalance(account, balance) {\n    let conversation = this.conversation;\n    let userId = this.userId;\n    let params = {\n      capability: 'MessageQuotaCapability',\n      capabilityFileName: 'messageQuotaCapability',\n      action: 'setUserAssignedClearUsedQuota',\n      sync: true,\n      userId: userId,\n      conversation: conversation,\n      stats: {},\n    };\n    params.stats[account] = balance;\n    return this._state.callCapability(params);\n  }\n\n  getCallRates(isoCountry) {\n    try {\n      let conversation = this.conversation;\n      let userId = this.userId;\n      let params = {\n        capability: 'VoipCapability',\n        capabilityFileName: 'voipCapability',\n        action: 'getCallTariffsForCountry',\n        isoCountry: isoCountry,\n        userDomains: this._state.userDomains,\n        sync: true,\n        userId: userId,\n        conversation: conversation,\n      };\n      return this._state.callCapability(params);\n    } catch (error) {\n      this._state.addSystemErrorToStack(8, null, error.message);\n    }\n  }\n\n  getCallHistory() {\n    try {\n      let params = {\n        action: 'getCallHistory',\n        capability: 'VoipCapability',\n        capabilityFileName: 'voipCapability',\n        userId: this.userId,\n        conversation: this.conversation,\n        sync: true,\n        email: this._state.user.userEmail,\n      };\n      return this._state.callCapability(params);\n    } catch (error) {\n      this._state.addSystemErrorToStack(8, null, error.message);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Accounts.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Collection.js":
/*!***************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Collection.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collection: function() { return /* binding */ Collection; }\n/* harmony export */ });\n/* harmony import */ var _Intent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _FormFieldTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FormFieldTypes */ \"../../Bitbucket/frontmjs/core/FormFieldTypes.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"../../Bitbucket/frontmjs/core/Utils.js\");\n/* harmony import */ var _Error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Error */ \"../../Bitbucket/frontmjs/core/Error.js\");\n\n\n\n\n\n\nclass Collection extends _Intent__WEBPACK_IMPORTED_MODULE_0__.Intent {\n\n  dataType = _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TYPES.COLLECTION;\n\n  constructor(intentId, {\n      tabId,\n      name,\n      shared = false,\n      title,\n      description,\n      emptyStateMessage,\n      columnNames = [],\n      //filter,\n      keys = [],\n      selectableRows = false,\n      actionableRows = false,\n      addNewRows = false,\n      addNewRowsLabel,\n      allowMinimize = true,\n      allowClose = true,\n      minimizeOnAction = false,\n      updateInBackground = false,\n      topTableMenu = false,\n      promptOnClose,\n      footer,\n      rowMenu,\n      pages,\n      zone,\n      allowEdit = false,\n      allowDelete = false,\n      allowDeleteWhileOffline = false,\n      allowRefresh = false,\n      allowDownload = false,\n      allowSearch = false,\n      allowQuickAction = true,\n      confirmAction,\n      selectionAction,\n      parentDoc,\n      temp = false,\n      document,\n      modal,\n      style,\n      calendarEntry,\n      activeFilterName,\n      availableFilters,\n      filterDoc,\n      state,\n      version = 4,\n      cache = true,\n      local = false,\n      timeScaleView,\n      startDate,\n      activeQueryString,\n      mapOptions,\n      acceptAttachments,\n      fileScope,\n      system = false,\n      searchPlaceholder,\n      onInit = async self => {}\n    }\n  ) {\n    if (!document) {\n      return null\n    }\n    super(intentId, state, tabId);\n    this.onAction = async () => {};\n    this.onQuickAction = async () => {};\n    this.onFieldAction = async () => {};\n    this.onSelection = async () => {};\n    this.onRefresh = async () => {};\n    this.onSearch = async () => {};\n    this.onDownload = async () => {};\n    this.onConfirm = async () => {};\n    this.onTopMenuAction = async () => {};\n    this.onDelete = async () => {};\n    this.onSave = async () => {};\n    this.onClose = async () => {};\n    this.onMenuAction = async () => {};\n    this.onPreviousPage = async () => {};\n    this.onNextPage = async () => {};\n    this.onFilter = async () => {};\n    this.onFilterDelete = async () => {};\n    this.onFilterEdit = async () => {};\n    this.onRenameFilter = async () => {};\n    this.onMultipleSelection = async () => {};\n    this.onDiscard = async () => {};\n    this.onClearFilter = async () => {};\n    this.onClearSearch = async () => {};\n    this.onCreateOverlay = async () => {};\n    this.onEditOverlay = async () => {};\n    this.onDeleteOverlay = async () => {};\n    this.onShowAreas = async () => {};\n    this.onInit = onInit;\n    this.title = title;\n    this.description = description;\n    this.columnNames = columnNames;\n    //this.filter = filter;\n    this.keys = keys;\n    this.selectableRows = selectableRows;\n    this.actionableRows = actionableRows;\n    this.addNewRows = addNewRows;\n    this.addNewRowsLabel = addNewRowsLabel;\n    this.allowMinimize = allowMinimize;\n    this.allowClose = allowClose;\n    this.allowSearch = allowSearch;\n    this.minimizeOnAction = minimizeOnAction;\n    this.updateInBackground = updateInBackground;\n    this.promptOnClose = promptOnClose;\n    this.style = style;\n    this.calendarEntry = calendarEntry;\n    this.footer = footer;\n    this.rowMenu = rowMenu;\n    this.pages = pages;\n    this.zone = zone;\n    this.modal = modal;\n    this.allowChange = allowEdit;\n    this.allowEdit = allowEdit;\n    this.allowDelete = allowDelete;\n    this.allowDeleteWhileOffline = allowDeleteWhileOffline;\n    this.allowRefresh = allowRefresh;\n    this.allowDownload = allowDownload;\n    this.confirmAction = confirmAction;\n    this.emptyStateMessage = emptyStateMessage;\n    this._activeFilterName = activeFilterName;\n    this._availableFilters = availableFilters;\n    this._filteredColumns = [];\n    this._version = version;\n    this._columns = [];\n    this._action = null;\n    this._activeQueryString = activeQueryString;\n    this._columnTemplate = [];\n    this._preserveFieldData = {};\n    this._mapOptions = mapOptions;\n    this.selectionAction = selectionAction;\n    this._keysForShortMessage = [];\n    this.allowQuickAction = allowQuickAction;\n    this.acceptAttachments = acceptAttachments;\n    this.fileScope = fileScope;\n    this.parentDocId = this.intentId;\n    this.topTableMenu = topTableMenu;\n    this.searchPlaceholder = searchPlaceholder;\n    if (style === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.COLLECTION_TYPES.CALENDAR) {\n      this._timeScaleView = timeScaleView;\n      this._startDate = startDate\n    }\n    this._shared = shared;\n    let collectionName = `${name || intentId}`;\n    this._collectionName = collectionName;\n    this._state = document._state;\n    this._ = document._state._;\n    this._rows = [];\n    this._document = document;\n    this.documentId = document.intentId;\n    this._cache = cache;\n    this._system = system;\n    this.temp = temp;\n    this._local = local;\n    if (this._document) {\n      this._state = this._document._state;\n    }\n    this._subCollection = false;\n    this.filterDoc = filterDoc;\n    this._sectionId = null; \n    if (parentDoc) {\n      this.setParentDoc(parentDoc);\n    }\n    let _ = document._state._;\n    if (this.addNewRows) {\n      // TODO: the _ is undefined in this context and causing errors.\n      this.newRowFieldsOptions = document.message(true).fields || []; //_.get(document.message(true), 'fields')\n    }\n    this._document.setCollection(this);\n  }\n\n  resetProperties() {\n    this._action = null;\n    this.activeQueryString = null;\n    this.activeFilterName = null;\n    // we need to set the name  and call setCollection inside here\n    // because in the constructor we don't have the state.systemId seeded\n    // good to have in the feature: a json file with the bot metadata that the state\n    // can import and seed in the state constructor (having that we can move this again to the constructor)\n    this._name = this._shared ? `${this._collectionName}_${this._state.systemId}` : `${this._collectionName}_${this._state.botId}`;\n    this._document.setCollection(this);\n  }\n\n  cloneCollection(collection, intentId) {\n    return new Collection(intentId || this.intentId, {\n      title: this.title,\n      description: this.description,\n      columnNames: this.columnNames,\n      keys: this.keys,\n      selectableRows: this.selectableRows,\n      actionableRows: this.actionableRows,\n      addNewRows: this.addNewRows,\n      addNewRowsLabel: this.addNewRowsLabel,\n      allowMinimize: this.allowMinimize,\n      allowClose: this.allowClose,\n      minimizeOnAction: this.minimizeOnAction,\n      updateInBackground: this.updateInBackground,\n      promptOnClose: this.promptOnClose,\n      footer: this.footer,\n      rowMenu: this.rowMenu,\n      pages: this.pages,\n      allowEdit: this.allowEdit || this.allowChange,\n      allowDelete: this.allowDelete,\n      allowDeleteWhileOffline: this.allowDeleteWhileOffline,\n      allowRefresh: this.allowRefresh,\n      allowDownload: this.allowDownload,\n      allowSearch: this.allowSearch,\n      confirmAction: this.confirmAction,\n      parentDoc: this.parentDoc,\n      document: this._document,\n      modal: this.modal,\n      style: this.style,\n      calendarEntry: this.calendarEntry,\n      activeFilterName: this._activeFilterName,\n      availableFilters: this._availableFilters,\n      filterDoc: this._filterDoc,\n      state: this.document._state,\n      version: this._version,\n      cache: this._cache,\n      timeScaleView: this._timeScaleView,\n      startDate: this._startDate,\n      activeQueryString: this._activeQueryString,\n      mapOptions: this._mapOptions,\n      selectionAction: this.selectionAction,\n      acceptAttachments: this.acceptAttachments,\n      fileScope: this.fileScope,\n      topTableMenu: this.topTableMenu,\n      searchPlaceholder: this.searchPlaceholder,\n      system: this._system,\n      emptyStateMessage: this.emptyStateMessage,\n      onInit: this.onInit\n    });\n  }\n\n  overrideOptions(newOptions) {\n    let _ = this._state._;\n    this.tabId = newOptions.tabId;\n    this.title = _.get(newOptions, 'title');\n    this.columnNames = _.get(newOptions, 'columnNames');\n    this._columns = _.get(newOptions, 'columns');\n    this._filteredColumns = newOptions.filteredColumns;\n    this.keys = newOptions.keys;\n    this.selectableRows = newOptions.selectableRows;\n    this.actionableRows = newOptions.actionableRows;\n    this.addNewRows = newOptions.addNewRows;\n    this.addNewRowsLabel = newOptions.addNewRowsLabel;\n    this.allowMinimize = newOptions.allowMinimize;\n    this.allowClose = newOptions.allowClose;\n    this.minimizeOnAction = newOptions.minimizeOnAction;\n    this.updateInBackground = newOptions.updateInBackground;\n    this.promptOnClose = newOptions.promptOnClose;\n    this.footer = newOptions.footer;\n    this.rowMenu = newOptions.rowMenu;\n    this.pages = newOptions.pages;\n    this.zone = newOptions.zone;\n    this.modal = newOptions.modal;\n    this.allowChange = newOptions.allowChange;\n    this.allowEdit = newOptions.allowEdit;\n    this.allowDelete = newOptions.allowDelete;\n    this.allowDeleteWhileOffline = newOptions.allowDeleteWhileOffline;\n    this.allowRefresh = newOptions.allowRefresh;\n    this.allowDownload = newOptions.allowDownload;\n    this.confirmAction = newOptions.confirmAction;\n    this.allowSearch = newOptions.allowSearch;\n    this.allowQuickAction = newOptions.allowQuickAction\n    this.style = newOptions.style;\n    this.calendarEntry = newOptions.calendarEntry;\n    this._activeFilterName = newOptions.activeFilterName;\n    this._availableFilters = newOptions.availableFilters;\n    this._filterActive = newOptions.filterActive;\n    this.newRowFieldsOptions = newOptions.newRowFieldsOptions;\n    this._timeScaleView = newOptions.timeScaleView;\n    this._startDate = newOptions.startDate;\n    this._activeQueryString = newOptions.activeQueryString;\n    this._columnTemplate = newOptions.columnTemplate;\n    this._preserveFieldData = newOptions.preserveFieldData;\n    this._mapOptions = newOptions.mapOptions\n    this._keysForShortMessage = newOptions.keysForShortMessage;\n    this.parentDocId = newOptions.parentDocId;\n    this.emptyStateMessage = newOptions.emptyStateMessage;\n    if (this._state) {\n      if (!newOptions.parent) {\n        delete this._parent;\n      } else {\n        this._parent = this._state.intents[newOptions.parent];\n      }\n    }\n    this.selectionAction = _.get(newOptions, 'selectionAction');\n    this.topTableMenu = _.get(newOptions, 'topTableMenu');\n  }\n\n  get options() {\n    let parent = null;\n    if (this._parent) {\n      parent = this._parent._intentId;\n    }\n    let parentDocId;\n    if (this._state) {\n      parentDocId = this._state._.get(this._state, 'messageFromUser.parentDocId') || this.parentDocId;\n    }\n    return {\n      parent,\n      tableId: this.intentId,\n      controlId: this.intentId,\n      documentId: this.documentId,\n      action: this._action,\n      tabId: this.tabId,\n      title: this.title,\n      description: this.description,\n      columnNames: this.columnNames,\n      columns: this._columns,\n      filteredColumns: this._filteredColumns,\n      //filter: this.filter,\n      keys: this.keys,\n      selectableRows: this.selectableRows,\n      actionableRows: this.actionableRows,\n      addNewRows: this.addNewRows,\n      addNewRowsLabel: this.addNewRowsLabel,\n      allowMinimize: this.allowMinimize,\n      allowClose: this.allowClose,\n      minimizeOnAction: this.minimizeOnAction,\n      updateInBackground: this.updateInBackground,\n      promptOnClose: this.promptOnClose,\n      footer: this.footer,\n      rowMenu: this.rowMenu,\n      pages: this.pages,\n      zone: this.zone,\n      modal: this.modal,\n      allowChange: this.allowChange,\n      allowEdit: this.allowEdit,\n      allowDelete: this.allowDelete,\n      allowDeleteWhileOffline: this.allowDeleteWhileOffline,\n      allowRefresh: this.allowRefresh,\n      allowDownload: this.allowDownload,\n      confirmAction: this.confirmAction,\n      allowSearch: this.allowSearch,\n      style: this.style,\n      calendarEntry: this.calendarEntry,\n      activeFilterName: this._activeFilterName,\n      availableFilters: this._availableFilters,\n      filterActive: this._filterActive,\n      newRowFieldsOptions: this.newRowFieldsOptions,\n      timeScaleView: this._timeScaleView,\n      startDate: this._startDate,\n      activeQueryString: this._activeQueryString,\n      columnTemplate: this._columnTemplate,\n      preserveFieldData: this._preserveFieldData,\n      mapOptions: this._mapOptions,\n      selectionAction: this.selectionAction,\n      keysForShortMessage: this._keysForShortMessage,\n      acceptAttachments: this.acceptAttachments,\n      fileScope: this.fileScope,\n      allowQuickAction: this.allowQuickAction,\n      topTableMenu: this.topTableMenu,\n      searchPlaceholder: this.searchPlaceholder,\n      emptyStateMessage: this.emptyStateMessage,\n      parentDocId,\n      sectionId: this.sectionId\n    }\n  }\n\n  set document(document) {\n    this._document = document;\n  }\n\n  get document() {\n    return this._document;\n  }\n\n  set parentDoc(parentDoc) {\n    this._parentDoc = parentDoc;\n  }\n\n  get parentDoc() {\n    return this._parentDoc;\n  }\n  get sectionId() {\n    return this._sectionId;\n  }\n  \n  set sectionId(sectionId) {\n    this._sectionId = sectionId; \n  }\n\n  get system() {\n    return this._system;\n  }\n\n  get name() {\n    return this._shared ? `${this._collectionName}_${this._state.systemId}` : `${this._collectionName}_${this._state.botId}`;\n  }\n\n  get filterDoc() {\n    return this._filterDoc;\n  }\n\n  set filterDoc(filterDoc) {\n    this._filterDoc = filterDoc;\n    if (this._filterDoc) {\n      this._filterActive = true;\n      this._filterDoc._filteredCollectionName = this.intentId;\n    } else {\n      this._filterActive = false;\n    }\n  }\n\n  get isSubCollection() {\n    return this._subCollection;\n  }\n\n  set isSubCollection(isSubCollection) {\n    this._subCollection = isSubCollection;\n  }\n\n  sendResponse(skipOnResponse) {\n    this._state.addTableResponse(this.message(false, skipOnResponse));\n  }\n\n  generateTableColumnLabels() {\n    let _ = this._state._;\n    let tableRowLabels = [];\n    let columnNamesObject = {};\n    _.forEach(this._document.fields, field => {\n      if (!field.hidden) {\n        if (field.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_2__.FormFieldTypes.FILE_FIELD) {\n          if (this._version === 1) {\n            tableRowLabels.push(`${field.title}_attachment`);\n          } else {\n            columnNamesObject[field.id] = field.title;\n          }\n        } else {\n          if (this._version === 1) {\n            tableRowLabels.push(field.title);\n          } else {\n            columnNamesObject[field.id] = field.title;\n          }\n        }\n      }\n    });\n    if (this._version === 1) {\n      return tableRowLabels;\n    } else {\n      return columnNamesObject;\n    }\n  }\n\n  generateTableColumnTemplate() {\n    let _ = this._state._;\n    let columnNamesObject = [];\n    _.forEach(this._document.fields, field => {\n      // Also considering the hidden fields as required to generate the fields back in expandShortTableResponse\n      // if (!field.hidden) {\n      //let fieldProperties = field.message(true);\n      // delete fieldProperties.value;\n      columnNamesObject.push(field.message(true, true));\n      // }\n    });\n    return columnNamesObject;\n  }\n\n  generateTableKeyLabels() {\n    let _ = this._state._;\n    let tableRowKeyLabels = [];\n    _.forEach(this._document.fields, field => {\n      if (field.primaryKey) {\n        tableRowKeyLabels.push(field.title);\n      }\n    });\n    return tableRowKeyLabels;\n  };\n\n  generateKeysForShortMessage() {\n    //TODO: Check if the kays make sense. Filter temps??\n    let _ = this._state._;\n    let tableRowKey = [];\n    _.forEach(this._document.fields, field => {\n      tableRowKey.push(field.id);\n    });\n    return tableRowKey;\n  };\n\n  generateTableRows(skipOnResponse) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let tableRows = [];\n    _.forEach(this._rows, row => {\n      let doc = row.document;\n      let tableRow = {};\n      if (this._version === 2) {\n        tableRow = _.get(row.message(null, null, null, null, skipOnResponse), 'fields');\n      } else if (this._version > 2) {\n        let rowMessage = row.message(null, null, null, null, skipOnResponse);\n        let rowOptions = {};\n        if (row.allowEdit === false) {\n          rowOptions.allowEdit = false;\n        }\n        if (row.allowDelete === false) {\n          rowOptions.allowDelete = false;\n        }\n        rowOptions.rowMenu = row.rowMenu;\n        tableRow[row.docId] = {\n          fields: _.get(rowMessage, 'fields'),\n          rowOptions\n        }\n      } else {\n        _.forEach(row.fields, field => {\n          if (field) field.onMessage(skipOnResponse);\n          if (field.primaryKey || !field.hidden) {\n            if (field.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_2__.FormFieldTypes.DATE || field.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_2__.FormFieldTypes.DATETIME) {\n              tableRow[field.title] = `#date(${field.value})`;\n            } else {\n              tableRow[field.title] = field.value;\n            }\n          }\n        });\n      }\n      tableRows.push(tableRow);\n    });\n    return tableRows;\n  };\n\n  setFilterColumns() {\n    let _ = this._state._\n    if (this._filterDoc && this._filteredColumns.length === 0) {\n      let columns = [];\n      _.forEach(this._filterDoc.fields, field => {\n        if (!field.hidden) {\n          let fieldDetails = field.message();\n          if (fieldDetails) columns.push(fieldDetails);\n        }\n      })\n      this._filteredColumns = columns;\n    }\n  }\n\n  prepareCollectionOptions(preserveFieldData = {}) {\n    let currentAutoSave = this._document._autoSave;\n    if ((!this.allowChange && !this.allowEdit) && !this.addNewRows && !this.allowDelete && !this._parentDoc) {\n      this._document._autoSave = false;\n    }\n    this.setFilterColumns();\n    this.columnNames = this.generateTableColumnLabels();\n    this._columnTemplate = this.generateTableColumnTemplate();\n    this._keysForShortMessage = this.generateKeysForShortMessage();\n    this._preserveFieldData = preserveFieldData;\n    if (this._version === 2) {\n      this.keys = [];\n    } else {\n      this.keys = this.generateTableKeyLabels();\n    }\n    this._document._autoSave = currentAutoSave;\n  }\n\n  getRowsForShortResponse(preserveFieldData = {}) {\n    let _ = this._state._;\n    // let rowsResponse = [];\n    this.message(undefined, undefined, preserveFieldData);\n    //TODO: build the short response as array of arrays. Careful with the docId, allowDelete and allowEdit\n    // _.forEach(this._rows, row => {\n    //     row.onResponse(row);\n    //     let shortDoc = row._documentForShortResponse;\n    //     shortDoc.docId = row.docId;\n    //     shortDoc.allowEdit = row.allowEdit;\n    //     shortDoc.allowDelete = row.allowDelete;\n    //     rowsResponse.push(shortDoc);\n    // })\n    let rowsResponseDelta = [];\n    _.forEach(this._rows, row => {\n      let shortArr = [];\n      _.forEach(this._keysForShortMessage, key => {\n        shortArr.push(row._documentForShortResponse[key]);\n      });\n      let preservedFields = [];\n      _.forEach(Object.keys(preserveFieldData), field => {\n        let preservedFieldsArr = []\n        _.forEach(preserveFieldData[field], fieldKey => {\n          preservedFieldsArr.push(row.f[field][fieldKey]);\n        })\n        preservedFields.push(preservedFieldsArr);\n      })\n      rowsResponseDelta.push([shortArr, [row.docId, row.allowEdit, row.allowDelete, row.rowMenu], preservedFields]);\n    })\n    return rowsResponseDelta;\n  }\n\n  sendShortResponse(asyncPages, totalExpectedRows, preserveFieldData = {}) {\n    let _ = this._state._;\n    this.prepareCollectionOptions(preserveFieldData);\n    this._state.addShortTableResponse({\n      options: this.options,\n      asyncPages,\n      totalExpectedRows,\n      rows: this.getRowsForShortResponse(preserveFieldData)\n    })\n  }\n\n  message(asyncPages, skipOnResponse, preserveFieldData = {}) {\n    let _ = this._state._;\n    this.prepareCollectionOptions(preserveFieldData);\n    // this.generateAutoSaveBufferFromCollection();\n    if (asyncPages) {\n      this._action = _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TABLES.CHANGE_ACTION;\n      return {\n        rows: {\n          append: this.generateTableRows(skipOnResponse)\n        },\n        options: this.options\n      };\n    } else {\n      this._action = null;\n      return {\n        rows: this.generateTableRows(skipOnResponse),\n        options: this.options\n      };\n    }\n  }\n\n  sendEditFilterResponse() {\n    let D = this._state.developer;\n    this._action = _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TABLES.CHANGE_FILTER_ACTION;\n    this.setFilterColumns();\n    //D.log({message: \"Options on editResponse\", data: this.options});\n    this._state.addTableResponse({\n      rows: [],\n      options: this.options\n    })\n  }\n\n  sendFilterChangeResponse(action, results) {\n    let D = this._state.developer;\n    this._action = action;\n    this._filteredColumns = results;\n    //D.log({message: \"Options on editResponse\", data: this.options});\n    this._state.addTableResponse({\n      rows: [],\n      options: this.options\n    })\n  }\n\n  getFilterCriteriaWithName(name) {\n    return this._state.getField(_ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.PREFIXES.FILTER_PREFIX + name)\n  }\n\n  addRow(row) {\n    row.index = this._rows.length;\n    this._rows.push(row);\n  }\n\n  clearRows() {\n    this._rows = [];\n  }\n\n  rowAsDocumentsArray() {\n    let _ = this._state._;\n    let resultsArray = [];\n    _.forEach(this.rows, row => {\n      resultsArray.push(row.document)\n    });\n    return resultsArray\n  }\n\n  buildRowsFromArray(rows) {\n    let _ = this._state._;\n    if (Array.isArray(rows)) {\n      this.clearRows();\n      let i = 0;\n      rows.forEach(row => {\n        let newDoc = this._document.cloneDoc()\n        this.addRow(newDoc);\n        if (newDoc.hasSubDocs) {\n          newDoc.buildDocumentFromContainer(row, true)\n        } else {\n          newDoc.buildDocument(row, true);\n        }\n        i++;\n      });\n      //console.log('Final i ' + i);\n    }\n  }\n\n  buildRowsFromUserMessage(tabId, messageFromUser, state) {\n    this._state.duringBuild = true; // -- setting the auto save changes trigger to ignoring changes\n\n    this._state._.unset(this._state.autoSaveBuffer, this.getAutoSavePath(tabId));\n\n    this.buildRowsFromArray(messageFromUser.rows);\n\n    this._state.duringBuild = false;\n  }\n\n  getAutoSavePath(tabId, parentDocId) {\n    let state = this._state;\n    try {\n      let _ = state._;\n      let D = state.developer;\n      let tabIdToLoad = tabId || state.currentTabId || this.document.tabId;\n      if (this._parentDoc) {\n        let docPath = this._parentDoc.getAutoSavePath(tabIdToLoad, parentDocId);\n        return `${docPath}.${this.intentId}`\n      } else {\n        return `${tabIdToLoad}.${this.intentId}`\n      }\n    } catch (error) {\n      state.addSystemErrorToStack(999, error.message, this.intentId)\n    }\n  }\n\n  loadRowsFromAutoSaveBuffer(tabId) {\n    let state = this.document._state;\n    let _ = state._;\n    let D = state.developer;\n    let path = this.getAutoSavePath(tabId);\n    let autoSavedRows = _.get(state.autoSaveBuffer, path);\n    _.forEach(autoSavedRows, (autoSavedRow, docId) => {\n      let newRow = this.document.cloneDoc();\n      newRow.docId = docId;\n      this.addRow(newRow);\n      if (this.document._subDocs) {\n        newRow.buildDocumentFromContainer(autoSavedRow)\n      } else {\n        newRow.buildDocument(autoSavedRow)\n      }\n    });\n  }\n\n  generateAutoSaveBufferFromCollection() {\n    this._rows.forEach(row => {\n      row.generateAutoSaveBufferFromDoc();\n    })\n  }\n\n  clearAutoSaveBuffer(tabId) {\n    let state = this.document._state;\n    let _ = state._;\n    let path = this.getAutoSavePath(tabId);\n    _.unset(state.autoSaveBuffer, path);\n  }\n\n  clearAutoSaveBufferChanges(tabId) {\n    let state = this.document._state;\n    let _ = state._;\n    let path = this.getAutoSavePath(tabId);\n    _.unset(state.autoSaveBufferChanges, path);\n  }\n\n  async buildTheDocsFromPayload(payload) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let online = await this._state.online();\n    let currentAutoSave = this._document._autoSave;\n    if (Array.isArray(payload) && payload.length > 0) {\n      let allDocs = [];\n      this._rows = [];\n      let allKeys = {};\n      if ((!this.allowChange && !this.allowEdit) && !this.addNewRows && !this.allowDelete) {\n        this._document._autoSave = false;\n      }\n      for (let i = 0; i < payload.length; i++) {\n        let document = payload[i];\n        //let docClone = _.cloneDeep(this._document);\n        let docClone = this._document.cloneDoc();\n        //D.log({message: 'After clone', data: _.size(docClone.f)});\n        allDocs.push(document);\n        //this.addRow(docClone);\n        if (this._document.hasSubDocs) {\n          docClone.buildDocumentFromContainer(document);\n        } else {\n          docClone.buildDocument(document);\n        }\n        await docClone.onPostLoad(docClone);\n        let addDocClone = primaryKey => {\n          if (!allKeys[primaryKey]) {\n            this.addRow(docClone);\n            allKeys[primaryKey] = true;\n          }\n        }\n        let primaryKey = this.document._state.sha1(JSON.stringify(docClone.getPrimaryKey()));\n        addDocClone(primaryKey);\n      }\n      this._document._autoSave = currentAutoSave;\n      return allDocs;\n    }\n  }\n\n  async loadCollectionWithQuery({\n    action = 'query',\n    query = {},\n    projection = {},\n    sort = {},\n    skip = 0,\n    limit = 20,\n    collation = {},\n  }) {\n    if (this._subCollection) {\n      this._state.addErrorToStack(7, 'We cannot retrieve data from subCollections');\n      return\n    }\n    let results;\n    if (this._local) {\n      results = await this._state.deviceStorage.queryCollection(this.name);\n    } else {\n      let _ = this._state._;\n      let D = this._state.developer;\n      //console.log(\"Query 1\")\n      results = await this._state.db.getDataFromCollection({\n        collection: this.name,\n        action,\n        query,\n        projection,\n        sort,\n        skip,\n        limit,\n        collation,\n        system: this._system,\n        cache: this._cache,\n        securedFields: this.document.getSecuredFieldsArray(),\n      });\n      //console.log(\"Query 2\")\n    }\n    if (results?.statusCode === 200) {\n      let payload = results.body;\n      //console.log(\"Query 3\")\n      return this.buildTheDocsFromPayload(payload);\n    }\n  }\n\n  async countCollectionWithQuery({\n    query = {},\n    projection = {},\n    collation = {}\n  }) {\n    let results = await this._state.db.countDataFromCollection({\n      collection: this.name,\n      query,\n      projection,\n      collation\n    });\n    if (results.statusCode === 200) {\n      return results.body;\n    }\n  }\n\n  async loadCollectionFromIndex(queryObject, index) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    if (!index) index = this.intentId;\n    let payload = await this._state.db.getDataFromIndexWithQueryObject(index, queryObject);\n    D.log({ message: 'Results from ES query', data: payload });\n    if (_.get(payload, \"errorMessage\") || _.get(payload, \"error\")) {\n      return\n    } else {\n      return this.buildTheDocsFromPayload(payload);\n    }\n  }\n\n  getQueryForSearch(queryString) {\n    let _ = this._state._;\n    let query = {};\n    const OR = '$or';\n    query[OR] = []\n    _.forEach(this._document.fields, field => {\n      if (field.searchKey || field.primaryKey) {\n        let fieldQuery = {};\n        if (field.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_2__.FormFieldTypes.NUMBER_FIELD) {\n          fieldQuery[field.dbName || field.id] = parseInt(queryString, 10);\n        } else {\n          let regexSearch = {};\n          regexSearch['$regex'] = `^(.*?)${queryString}`;\n          regexSearch['$options'] = `i`;\n          fieldQuery[field.dbName || field.id] = regexSearch;\n        }\n        if (_.size(fieldQuery) > 0) {\n          query[OR].push(fieldQuery);\n        }\n      }\n    });\n    return query\n  }\n\n  setParentDoc(parentDoc) {\n    if (parentDoc.dataType === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TYPES.DOC) {\n      this.isSubCollection = true;\n      this.parentDoc = parentDoc;\n      this._document.parentDocId = this._state.user.userId;\n      parentDoc.addChildDoc(this);\n    } else {\n      this._state.addSystemErrorToStack(7, `Sub documents cannot be saved ${this._intentId}`);\n    }\n  }\n\n  get mapOptions() {\n    return this._mapOptions;\n  }\n\n  set activeQueryString(activeQueryString) {\n    this._activeQueryString = activeQueryString\n  }\n\n  get activeQueryString() {\n    return this._activeQueryString\n  }\n\n  set startDate(startDate) {\n    this._startDate = startDate\n  }\n\n  get startDate() {\n    return this._startDate\n  }\n\n  set timeScaleView(timeScaleView) {\n    this._timeScaleView = timeScaleView\n  }\n\n  get timeScaleView() {\n    return this._timeScaleView\n  }\n\n  set availableFilters(availableFilters) {\n    this._availableFilters = availableFilters;\n  }\n\n  get availableFilters() {\n    return this._availableFilters;\n  }\n\n  set activeFilterName(activeFilterName) {\n    this._activeFilterName = activeFilterName;\n  }\n\n  get activeFilterName() {\n    return this._activeFilterName;\n  }\n\n  set parent(parent) {\n    this._parent = parent;\n  }\n\n  get tableId() {\n    return this.intentId;\n  }\n\n  get rows() {\n    return this._rows;\n  }\n\n  set rows(rows) {\n    this._rows = rows;\n  }\n\n  get shared() {\n    return this._rows;\n  }\n\n  set shared(shared) {\n    this._shared = shared;\n  }\n\n  get filteredColumns() {\n    return this._filteredColumns;\n  }\n\n  set filteredColumns(cols) {\n    this._filteredColumns = cols;\n  }\n\n  get local() {\n    return this._local;\n  }\n\n  set local(local) {\n    this._local = local;\n  }\n\n  insertRow(i, row) {\n    this._rows.splice(i, 0, row)\n  }\n\n  get onMatching() {\n    return state => {\n      let _ = state._;\n      let D = state.developer;\n      const NO_VALUE = 'no value';\n      let action = _.get(state.messageFromUser, 'action');\n      let field = _.get(state.messageFromUser, 'currentFieldValue', _.get(state.messageFromUser, 'content.currentFieldValue', NO_VALUE));\n      return state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.RESPONSES.TABLE_RESPONSE &&\n        (state.messageFromUser.controlId === this.intentId || state.messageFromUser.tableId === this.intentId)\n        && field === NO_VALUE && !(action && _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.IsFieldAction(action));\n    };\n  }\n\n  async _callEvents(state) {\n    if (this._parent && this._parent._intentId === state.currentControlId) {\n      state.currentControlId = this._parent._intentId;\n    } else {\n      state.currentControlId = this.intentId;\n    }\n    if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_ACTION) await this.onAction();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.QUICK_ACTION) await this.onQuickAction();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_SELECTION) await this.onSelection();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_SAVE) await this.onSave();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.DISCARD) {\n      //todo: Restore original value from the messageFromUser\n      await this.onDiscard();\n    } else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CLOSE) await this.onClose();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.SEARCH) await this.onSearch();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_MENU_ACTION) await this.onMenuAction();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_FIELD_ACTION) await this.onFieldAction();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_REFRESH) await this.onRefresh();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_DOWNLOAD) await this.onDownload();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_CONFIRM) await this.onConfirm();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_DELETE) await this.onDelete();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_PREVIOUS_PAGE) await this.onPreviousPage();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_NEXT_PAGE) await this.onNextPage();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_FILTER_ACTION) await this.onFilter();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_FILTER_DELETE_ACTION) await this.onFilterDelete();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_EDIT_FILTER_ACTION) await this.onFilterEdit();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TABLES.MULTIPLE_SELECTION_ACTION) await this.onMultipleSelection();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TABLES.RENAME_FILTER_ACTION) await this.onRenameFilter();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TABLES.CLEAR_FILTER_ACTION) await this.onClearFilter();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TABLES.CLEAR_SEARCH_ACTION) await this.onClearSearch();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_CREATE_OVERLAY) await this.onCreateOverlay();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_EDIT_OVERLAY) await this.onEditOverlay();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_DELETE_OVERLAY) await this.onDeleteOverlay();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_SHOW_AREAS) await this.onShowAreas();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_TOP_MENU_ACTION) await this.onTopMenuAction();\n    else state.addSystemErrorToStack(28, _Error__WEBPACK_IMPORTED_MODULE_4__.Error.getErrorMessageforCodeAndLang(28));\n    if (state.responsesArray.length === 0) {\n      state.addSilentResponse();\n    }\n  }\n\n  get onResolution() {\n    let _ = this.document._state._;\n    let D = this.document._state.developer;\n    return async state => {\n      let docId = _.get(state.messageFromUser, 'docId');\n      let parentDocId = _.get(state.messageFromUser, 'parentDocId');\n      if (!docId && parentDocId) {\n        docId = parentDocId;\n      }\n      if (docId) {\n        let tabId = _.get(state.messageFromUser, 'tabId');\n        this.document.loadDocFromAutoSaveBuffer(tabId, docId, parentDocId);\n        if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_DELETE || (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.DISCARD && state.messageFromUser.newRow)) {\n          let docToBuild = _.get(state.messageFromUser, `content.${docId}`);\n          let docToRestore = _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.formResponseAsObject(docToBuild);\n          this.document.docId = docId;\n          this.document.buildDocument(docToRestore, true);\n          this.document.clearAutoSaveBuffer(tabId, docId, parentDocId);\n        } else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.DISCARD && !state.messageFromUser.newRow) {\n          let rawDocToRestore = _.get(state.messageFromUser, `content.${docId}`);\n          let docToRestore = _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.formResponseAsObject(rawDocToRestore);\n          this.document.docId = docId;\n          this.document.buildDocument(docToRestore, true);\n        } else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_SAVE) {\n          let rawDocToRestore = _.get(state.messageFromUser, `content`);\n          D.log({ message: \"rawDocToRestore\", data: rawDocToRestore });\n          let docToRestore = _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.formResponseAsObject({\n            fields: rawDocToRestore\n          });\n          D.log({ message: \"docToRestore\", data: docToRestore });\n          this.document.docId = docId;\n          this.document.buildDocument(docToRestore, true, true);\n          D.log({ message: \"builtDocument\", data: this.document.document });\n        } else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ON_MENU_ACTION) {\n          let rawDocToRestore = _.get(state.messageFromUser, `content.row`);\n          this.document.docId = docId;\n          this.document.buildDocument(rawDocToRestore, true, true);\n        }\n\n        //console.log(\"Document \" + JSON.stringify(this.document.document));\n      }\n      await this._callEvents(state);\n    };\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Collection.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Companies.js":
/*!**************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Companies.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Companies: function() { return /* binding */ Companies; }\n/* harmony export */ });\nclass Companies {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n  }\n\n  callCreateCompanyCapability(params) {\n    let capabilities = this._state.context.capabilities.capabilities;\n    let capFileName = params.capabilityFileName;\n    let capabilityModule = capabilities[capFileName];\n    return capabilityModule.execute(params, this._state.context.capabilities);\n  }\n\n  createChildCompany({ companyAddress, companyName, phoneNumbers, contractDuration, account }) {\n    let companyId = this._state.getUniqueId()\n    let params = {\n      capability: 'CompanyCapability',\n      capabilityFileName: 'companyCapability',\n      sync: true,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n      action: 'createCompany',\n      company: {\n        companyAddress,\n        companyId,\n        companyName,\n        phoneNumbers,\n        contractDuration,\n        account\n      },\n      companyDomain: {\n        userDomain: this._state.currentUserDomain,\n      },\n    };\n    return this.callCreateCompanyCapability(params).then(response => {\n      this._state.developer.info({ message: 'After created company', data: response });\n      if (this._.get(response, 'status')) {\n        return {\n          status: true,\n          companyId\n        }\n      } else {\n        return {\n          status: false,\n          errorMessage: this._.get(this._state._.compact(response), 'errorMessage', 'There was a problem creating the company')\n        }\n      }\n    });\n  }\n\n  addOfferToCompany({\n    companyId,\n    verificationCode,\n    validFrom,\n    validTo,\n    maxUsersPerLicense,\n    offers,\n    offerType,\n    description,\n    role\n  }) {\n    let params = {\n      capability: 'CompanyCapability',\n      capabilityFileName: 'companyCapability',\n      sync: true,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n      action: 'createCompany',\n      company: {\n        companyId\n      },\n      companyDomain: {\n        userDomain: this._state.currentUserDomain,\n      },\n      userOffers: [\n        {\n          verificationCode,\n          offerType,\n          description,\n          role,\n          valid_from: validFrom,\n          valid_to: validTo,\n          codeUsage: {\n            maximum: maxUsersPerLicense\n          },\n          offers\n        }]\n    };\n    return this.callCreateCompanyCapability(params).then(response => {\n      this._state.developer.info({ message: 'After added offer to company', data: response });\n      if (this._.get(response, 'status')) {\n        return {\n          status: true,\n          companyId\n        }\n      } else {\n        return {\n          status: false,\n          errorMessage: this._.get(this._state._.compact(response), 'errorMessage', 'There was a problem creating the company')\n        }\n      }\n    });\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Companies.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/ContactCentre.js":
/*!******************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/ContactCentre.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContactCentre: function() { return /* binding */ ContactCentre; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n\n\nclass ContactCentre {\n  static WAITING_STATUS() {\n    return 'Waiting';\n  }\n\n  static WAITING_VESSEL_STATUS() {\n    return 'WaitingVessel';\n  }\n\n  static ACTIVE_STATUS() {\n    return 'Active';\n  }\n\n  static ENDED_STATUS() {\n    return 'Ended';\n  }\n\n  static MISSED_STATUS() {\n    return 'Missed';\n  }\n\n  static MISSED_CALL_TEXT() {\n    return 'Missed call';\n  }\n\n  static CONTACT_CENTRE_APP() {\n    return 'callCentreBot';\n  }\n\n  static CLIENT_APP() {\n    return 'clientBot';\n  }\n\n  static MANAGER_APP() {\n    return 'shiftManagerBot';\n  }\n\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n  }\n\n  async getBotIDs(key) {\n    let query = [\n      {\n        operand: 'dataKey',\n        value: key,\n        operator: 'eq',\n      },\n    ];\n    let response = await this._state.db.getStaticData(query);\n    let items = this._.get(response, 'items');\n    if (Array.isArray(items) && items.length > 0) {\n      let botIDs = items[0].value;\n      if (this._.size(botIDs) > 0) {\n        return botIDs;\n      }\n    }\n  }\n\n  async loadContactCentreTeam(contactCentreBotId) {\n    if (contactCentreBotId) {\n      try {\n        const SHIFT_MANAGER_KEY_PREFIX = 'CONTACT_CENTRE_SHIFT_';\n        let pattern = `${SHIFT_MANAGER_KEY_PREFIX}_${contactCentreBotId}*`;\n        //console.log(pattern);\n        let response = await this._state.db.getKeysOnPattern(pattern);\n        return response;\n      } catch (err) {\n        state.addSystemErrorToStack(100, `Error reading call centre staff ${this._state.R.toString(err)}`);\n      }\n    }\n  }\n\n  async getTranscriptionForCurrentConversation({ epochTime, bot, conversation }) {\n    let params = {\n      capability: 'ArchivedMessagesReader',\n      action: 'getPaginatedMessages',\n      // parameters: {\n      //   startTime: epochTime || 1,\n      // },\n      conversationId: this._state._.get(conversation, 'conversationId') || this._state.conversationId,\n      bot: bot || this._state.conversation.bot,\n      sync: true,\n      conversation: conversation || this._state.conversation,\n      capabilityDomain: this._state.currentUserDomain,\n      userEmail: this._state.user.userEmail,\n      userId: this._state.user.userId,\n      userDomain: this._state.userDomains,\n    };\n    return this._state.callLambda('ArchivedMessagesReader', params, 'RequestResponse').then(response => {\n      let payload = JSON.parse(response.Payload);\n      //console.log(this._state.R.toString(response));\n      return payload;\n    });\n  }\n\n  async addEntryToContactCentreQueue(entry, contactCentreBot, overrideBotId, customQueue) {\n    try {\n      let chatForm = this._state._.cloneDeep(entry);\n      chatForm.botDetails = this._state._.cloneDeep(contactCentreBot);\n      chatForm.userId = this._state.user.userId;\n      let conversationToQueue = {\n        ticket: Math.round(Math.random() * (99999999 - 1) + 1),\n        content: chatForm,\n        createdOn: Date.now(),\n        open: true,\n        status: ContactCentre.WAITING_STATUS(),\n        botId: overrideBotId || this._state.conversation.bot,\n        conversationId: this._state.conversationId,\n        userId: this._state.user.userId,\n      };\n      const CONTACT_CENTRE_CACHE = 'CONTACT_CENTRE_';\n      const OPEN_STATUS = 'open';\n      let key = `${CONTACT_CENTRE_CACHE}_${OPEN_STATUS}_${overrideBotId || this._state.conversation.bot}_${customQueue || \"\"}_${this._state.conversationId}`;\n      await this._state.db.setOneValueInCacheWithExpiry(key, conversationToQueue, 3600 * 24 * 7); //Expires in one week\n      return conversationToQueue;\n    } catch (err) {\n      this._state.addSystemErrorToStack(5, `Error adding entry to queue ${err}`);\n    }\n  }\n\n  async closeEntryInContactCentreQueue(entry, customQueue) {\n    entry.open = false;\n    entry.owner = this._state.user.userId;\n    const CONTACT_CENTRE_CACHE = 'CONTACT_CENTRE_';\n    const OPEN_STATUS = 'open';\n    let key = `${CONTACT_CENTRE_CACHE}_${OPEN_STATUS}_${entry.botId}_${customQueue || \"\"}_${entry.conversationId}`;\n    await this._state.db.setOneValueInCacheWithExpiry(key, entry, 3600 * 24 * 7); //Expires in one week\n    return entry;\n  }\n\n  async changeQueueEntryStatus(entry, status, customQueue) {\n    entry.status = status;\n    const CONTACT_CENTRE_CACHE = 'CONTACT_CENTRE_';\n    const OPEN_STATUS = 'open';\n    let key = `${CONTACT_CENTRE_CACHE}_${OPEN_STATUS}_${entry.botId}_${customQueue || \"\"}_${entry.conversationId}`;\n    await this._state.db.setOneValueInCacheWithExpiry(key, entry, 3600 * 24 * 7); //Expires in one week\n    return entry;\n  }\n\n  async changeQueueVideoSessionId(entry, videoSessionId, customQueue) {\n    entry.content.videoSessionId = videoSessionId;\n    const CONTACT_CENTRE_CACHE = 'CONTACT_CENTRE_';\n    const OPEN_STATUS = 'open';\n    let key = `${CONTACT_CENTRE_CACHE}_${OPEN_STATUS}_${entry.botId}_${customQueue || \"\"}_${entry.conversationId}`;\n    await this._state.db.setOneValueInCacheWithExpiry(key, entry, 3600 * 24 * 7); //Expires in one day\n    return entry;\n  }\n\n  async storeQueueEntry(entry, customQueue) {\n    const CONTACT_CENTRE_CACHE = 'CONTACT_CENTRE_';\n    const OPEN_STATUS = 'open';\n    let key = `${CONTACT_CENTRE_CACHE}_${OPEN_STATUS}_${entry.botId}_${customQueue || \"\"}_${entry.conversationId}`;\n    await this._state.db.setOneValueInCacheWithExpiry(key, entry, 3600 * 24 * 7); //Expires in one day\n    return entry;\n  }\n\n  async loadConversationsInQueue(botId) {\n    try {\n      let botToLoad = botId || this._state.conversation.bot;\n      const CONTACT_CENTRE_CACHE = 'CONTACT_CENTRE_';\n      const OPEN_STATUS = 'open';\n      let pattern = `${CONTACT_CENTRE_CACHE}_${OPEN_STATUS}_${botToLoad}*`;\n      let response = await this._state.db.getKeysOnPattern(pattern);\n      let parsedResponse = [];\n      let R = this._state.R;\n      this._state._.forEach(response, conversation => {\n        let parsedConversation = JSON.parse(conversation.content);\n        let i = 0;\n        while (i < parsedResponse.length && parsedConversation.createdOn > parsedResponse[i].createdOn) {\n          i++;\n        }\n        parsedResponse.splice(i, 0, parsedConversation);\n      });\n      return parsedResponse;\n    } catch (err) {\n      this._state.addSystemErrorToStack(100, `Error reading conversations ${this._state.R.toString(err)}`);\n    }\n  }\n\n  async getQueueEntry({ videoSessionId, botId, ticket }) {\n    let parsedQueue = await this.loadConversationsInQueue(botId);\n    //console.log('Queue to search for ' + this._state.R.toString(parsedQueue));\n    //console.log(videoSessionId);\n    let index = -1;\n    for (let i = 0; i < parsedQueue.length; i++) {\n      if (\n        (videoSessionId && parsedQueue[i].content.videoSessionId === videoSessionId) ||\n        (ticket && parsedQueue[i].ticket === ticket)\n      ) {\n        index = i;\n      }\n    }\n    //console.log(index);\n    return parsedQueue[index];\n  }\n\n  async loadConversationsForBot(botId, pagination, sort) {\n    try {\n      let size = this._state._.get(pagination, 'size') || 6;\n      let from = this._state._.get(pagination, 'from') || 0;\n      //let sqlQuery = {};\n      let docQuery = {\n        _source: ['conversationId', 'createdOn', 'modifiedOn', 'duration'],\n        query: {\n          bool: {\n            must: {\n              term: {\n                bot: botId,\n              },\n            },\n          },\n        },\n        sort: {\n          createdOn: {\n            order: 'desc',\n          },\n        },\n        size: size,\n      };\n      let rangeDuration = {\n        duration: {\n          gte: 10000,\n        },\n      };\n      if (from === 0) {\n        docQuery.query.bool.filter = {\n          range: rangeDuration,\n        };\n      } else {\n        docQuery.query.bool.filter = [\n          {\n            range: rangeDuration,\n          },\n          {\n            range: {\n              createdOn: {\n                lt: from,\n              },\n            },\n          },\n        ];\n      }\n      //let allConversations = await this._state.db.getDataFromIndexWithSQL(sqlQuery);\n      let allConversations = await this._state.db.getDataFromIndexWithQueryObject(\n        DB.CONVERSATIONS_INDEX(),\n        docQuery\n      );\n      let finalResponse = [];\n      this._state._.forEach(allConversations, conversation => {\n        // conversation.state = JSON.parse(conversation.state);\n        // conversation.lastMessage = JSON.parse(conversation.lastMessage);\n        finalResponse.push(conversation);\n      });\n      return finalResponse;\n    } catch (err) {\n      this._state.addSystemErrorToStack(100, `Error reading conversations ${this._state.R.toString(err)}`);\n    }\n  }\n\n  async loadConversationData(conversationId) {\n    try {\n      let tableName = 'Conversations';\n      //console.log(tableName);\n      let query = [\n        {\n          operand: 'conversationId',\n          value: conversationId,\n          operator: 'eq',\n        },\n      ];\n      return this._state.db.getData(tableName, query);\n    } catch (err) {\n      this._state.addSystemErrorToStack(100, `Error reading conversations ${this._state.R.toString(err)}`);\n    }\n  }\n\n  async getConfigurationForKey(key) {\n    let query = [\n      {\n        operand: 'dataKey',\n        value: key,\n        operator: 'eq',\n      },\n    ];\n    let returnResponse = response => {\n      let items = this._state._.get(response, 'items');\n      if (Array.isArray(items) && items.length > 0) {\n        let botIDs = items[0].value;\n        return botIDs;\n      }\n    }\n    //console.log('Checking static data');\n    const STATIC_DATA = 'staticData';\n    if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE && this._state.v1Compatibility)) {\n      // console.log('Reading from Dynamo');\n      // this._state.developer.log({message: 'Reading from Dynamo'});\n      let response = await this._state.db.getStaticData(query);\n      this._state.addObjectToSyncMessage(STATIC_DATA, key, response);\n      return returnResponse(response)\n    } else {\n      //console.log('Reading from local');\n      this._state.developer.log({ message: 'Reading from local' });\n      let response = await this._state.deviceStorage.loadDocument(STATIC_DATA, this._state.sha1(key));\n      return returnResponse(response)\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/ContactCentre.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Contacts.js":
/*!*************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Contacts.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Contacts: function() { return /* binding */ Contacts; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n\n\nclass Contacts {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      this['contactCapability'] = this._state.context.getCapability('Contact');\n    }\n  }\n\n  refreshContactsOnEdge() {\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      this.contactCapability.refreshContacts();\n    } else {\n      this._state.addSystemErrorToStack(18);\n    }\n  }\n\n  getAllContactsFromEdge() {\n    return this.contactCapability.getAddedContacts().then(contactIds => {\n      return contactIds;\n    });\n  }\n\n  getAllContactsFromBackend() {\n    let params = {\n      capability: 'GetContacts',\n      capabilityFileName: 'contactsListCapability',\n      userDomain: this._state.conversation.userDomain,\n      sync: true,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n    };\n    return this._state.callCapability(params);\n  }\n  async syncContacts(usersToSync, userId) {\n    let params = {\n      userId: userId || this._state.user.userId,\n      usersToSync\n    }\n    try {\n      let lambda = this._state.frontmlib;\n      let response = await lambda.invokeLambda(\"SyncContacts\", \"RequestResponse\", params);\n      return response;\n    } catch (e) {\n      this._state.addSystemErrorToStack(7, \"Error in sync contacts\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Contacts.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/DB.js":
/*!*******************************************!*\
  !*** ../../Bitbucket/frontmjs/core/DB.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DB: function() { return /* binding */ DB; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State */ \"../../Bitbucket/frontmjs/core/State.js\");\n\n\n\nclass DB {\n  static CONVERSATIONS_INDEX() {\n    return 'conversations*';\n  }\n\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n  }\n\n  async checkMongoResponse(response, params, cache, audit, expectOneResult, operation, sync) {\n    let D = this._state.developer;\n    let results = response.Payload;\n    //In case of async lambda calls, there is no Payload\n    let parsedResponse = results?JSON.parse(results):{statusCode:200};\n    if (parsedResponse.statusCode === 500) {\n      this._state.addSystemErrorToStack(7, \"Error in database with error \" + response.Payload);\n    } else {\n      let auditDoc = params.document;\n      if (params.query) {\n        let _ = this._state._;\n        auditDoc = _.merge(auditDoc, params.query);\n      }\n      await this.writeAuditIndex(params.collection, auditDoc, audit, operation, sync);\n      if (cache) {\n        let payload = parsedResponse.body;\n        if ((payload === 'success' && params.document) || Array.isArray(payload) && payload.length > 0 && expectOneResult) {\n          if (payload === 'success') {\n            parsedResponse.body = [params.document]\n          }\n        }\n        this._state.addObjectToSyncMessage(params.collection, JSON.stringify(params), parsedResponse);\n      }\n    }\n    return parsedResponse;\n  }\n\n  async countDataFromCollection({\n    collection,\n    query = {},\n    projection = {},\n    collation,\n    system = false\n  }) {\n    let params = {\n      action: 'count',\n      db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n      collection,\n      query,\n      projection,\n      collation,\n      userId: this._state.user.userId\n    };\n    if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || await this._state.online()) {\n      let lambda = this._state.frontmlib;\n      let response = await lambda.invokeLambda('MongoDBManager', 'RequestResponse', params);\n      let results = response.Payload;\n      let parsedResponse = JSON.parse(results);\n      if (parsedResponse.statusCode === 500) {\n        this._state.addSystemErrorToStack(7, \"Error in database with error \" + response.Payload);\n      } else {\n        return parsedResponse\n      }\n    }\n  }\n\n  async getDataFromCollection({\n    collection,\n    action = 'query',\n    query = {},\n    projection = {},\n    sort = {},\n    skip = 0,\n    limit = 20,\n    collation,\n    expectOneResult = false,\n    cache = true,\n    system = false,\n    local = false, \n    securedFields\n  }) {\n    try {\n      let params = {\n        action,\n        db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n        collection,\n        query,\n        projection,\n        sort,\n        skip,\n        limit,\n        collation,\n        userId: this._state.user.userId,\n        securedFields\n      };\n      if ((this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || await this._state.online()) && !local) {\n        let lambda = this._state.frontmlib;\n        let response = await lambda.invokeLambda('MongoDBManager', 'RequestResponse', params);\n        return this.checkMongoResponse(response, params, cache, false, expectOneResult, _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.DB_OPERATIONS.QUERY);\n      } else {\n        // let query = params.query;\n        // if(params?.action === \"query\" && params.hasOwnProperty('skip') && !expectOneResult) query = { ...params.query, skip: params.skip };\n        let hashedKey = this._state.sha1(JSON.stringify(params));\n        let fromStorage;\n          \n        if (expectOneResult) {\n          fromStorage = await this._state.deviceStorage.loadDocument(params.collection, hashedKey);\n        } else {\n          fromStorage = await this._state.deviceStorage.queryCollection(params.collection, hashedKey);\n        }\n        if (!fromStorage) {\n          //this._state.addSystemErrorToStack(40);\n          fromStorage = {\n            statusCode: 200,\n            body: []\n          }\n        }\n        return fromStorage\n      }\n    } catch (err) {\n      this._state.addSystemErrorToStack(26, '3 ' + err.name + ': ' + err.message);\n    }\n  }\n\n  async archiveMessages() {\n    let state = this._state;\n    let _ = state._;\n    let frontmlib = state.frontmlib;\n    const THIRTY_DAYS_IN_MILLISECONDS = 1000 * 60 * 60 * 24 * 30; //TODO: Need to adjust this logic to hipaa\n    let messageToArchive = {\n      conversationId: state.conversationId,\n      messageId: state.messageIdFromUser || state.getUniqueId(),\n      content: [state.messageFromUser],\n      contentType: \"10\",\n      createdOn: Date.now(),\n      ttl: Date.now() + THIRTY_DAYS_IN_MILLISECONDS,\n      deleted: [],\n      delivered: [],\n      opened: [],\n      userDomain: state.currentUserDomain,\n      createdBy: state.user.userId\n    }\n\n    let messages = [];\n\n    _State__WEBPACK_IMPORTED_MODULE_1__.D.debug({message: \"Responses array\", data: state.responsesArray});\n    if (_.isEmpty(state.responsesArray)) {\n      if (state.messageTypeFromUser === \"10\" || state.messageTypeFromUser === \"string\") {\n        messages.push(messageToArchive);\n      }\n    } else {\n      _State__WEBPACK_IMPORTED_MODULE_1__.D.debug({message: \"messageToArchive\", data: messageToArchive});\n      _State__WEBPACK_IMPORTED_MODULE_1__.D.debug({message: \"nlpResults\", data: state.nlpResults});\n      if (!_.isEmpty(state.nlpResults)) {\n        messages.push(messageToArchive);\n      }\n      _.forEach(state.responsesArray, response => {\n        if (response.type === \"string\") {\n          let newMessageToArchive = _.clone(messageToArchive);\n          delete newMessageToArchive.createdBy;\n          newMessageToArchive.messageId = response.messageId || state.getUniqueId();\n          newMessageToArchive.content = [response.message]\n          newMessageToArchive.createdOn = Date.now();\n          messages.push(newMessageToArchive);\n        }\n      })\n    }\n    _State__WEBPACK_IMPORTED_MODULE_1__.D.debug({message: \"Messages to archive\", data: messages});\n    if (messages.length > 0) {\n      await frontmlib.insertMessages(messages);\n    }\n  }\n\n  async writeAuditIndex(collection, document, audit, operation, sync) {\n    //console.log(\"audit?\");\n    if (audit) {\n      //console.log(\"Before audit\");\n      let auditDoc = {\n        operation,\n        location: sync ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE : _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD,\n        timestamp: Date.now(),\n        userId: this._state.user.userId,\n        userEmail: this._state.user.userEmail,\n        client: this._state.client,\n        appVersion: this._state.appVersion,\n        botId: this._state.botId,\n        userDomain: this._state.currentUserDomain\n      }\n      let doc = {};\n      console.log(\"Before merge\");\n      if (collection === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.ACTIVITY_COLLECTION) {\n        doc = this._state.R.merge(auditDoc, document);\n      } else {\n        doc = this._state.R.merge(auditDoc, { document })\n      }\n      console.log(\"After merge \" + JSON.stringify(doc));\n      let index = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.PREFIXES.AUDIT}_${this._state.currentUserDomain}_${collection}`;\n      await this._state.db.writeDataIntoIndex({ index, doc });\n      //console.log(\"Calling archive\");\n      await this.archiveMessages()\n    }\n  }\n\n  async insertDocumentInCollection({\n    collection,\n    document,\n    audit,\n    sync = false,\n    system = false,\n    securedFields,\n    cache = false,\n    asyncCall = false\n  }) {\n    let params = {\n      action: 'insertOne',\n      db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n      collection,\n      document,\n      userId: this._state.user.userId,\n      securedFields\n    };\n    return this._state.callLambda('MongoDBManager', params, this.getLambdaInvocationType(asyncCall))\n      .then(response => {\n        return this.checkMongoResponse(response, params, cache, audit, false, _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.DB_OPERATIONS.INSERT, sync);\n      })\n      .catch(error => {\n        console.log(\"6. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  async insertManyDocumentsInCollection({\n    collection,\n    documents,\n    audit,\n    sync = false,\n    system = false,\n    securedFields,\n    cache = false,\n    asyncCall = false\n  }) {\n    let params = {\n      action: 'insertArray',\n      db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n      collection,\n      documents,\n      userId: this._state.user.userId,\n      securedFields\n    };\n    return this._state.callLambda('MongoDBManager', params, this.getLambdaInvocationType(asyncCall))\n      .then(response => {\n        return this.checkMongoResponse(response, params, cache, audit, false, _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.DB_OPERATIONS.INSERT, sync);\n      })\n      .catch(error => {\n        console.log(\"6. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  getLambdaInvocationType(asyncCall) {\n    if (asyncCall) {\n      return  \"Event\"\n    }\n    return \"RequestResponse\"\n  }\n\n  async updateDataInCollection({\n    collection,\n    document,\n    query,\n    options,\n    audit,\n    sync = false,\n    system = false,\n    securedFields,\n    cache = false,\n    updateMany = true,\n    local = false,\n    updateOperator = '$set',\n    asyncCall = false\n  }) {\n    let _ = this._state._;\n    let params = {\n      action: updateMany ? 'updateMany' : 'update',\n      db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n      collection,\n      document,\n      query,\n      options,\n      userId: this._state.user.userId,\n      updateOperator,\n      securedFields\n    };\n    if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || (await this._state.online() && !(this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE))) {\n      return this._state.callLambda('MongoDBManager', params, this.getLambdaInvocationType(asyncCall))\n        .then(response => {\n          return this.checkMongoResponse(response, params, cache, audit, false, _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.DB_OPERATIONS.UPSERT, sync);\n        })\n        .catch(error => {\n          this._state.addSystemErrorToStack(7, error.message);\n        });\n    } else {\n      let hashedKey = this._state.sha1(JSON.stringify(params));\n      let fromStorage = await this._state.deviceStorage.loadDocument(collection, hashedKey) || {};\n      if (_.size(fromStorage) > 0) {\n        //Update the fields in the doc and save\n        let docArray = _.get(fromStorage, 'body');\n        if (Array.isArray(docArray)) {\n          let docInStorage = [];\n          for (let i = 0; i < docArray.length; i++) {\n            docInStorage.push(_.merge(docArray[i], document));\n          }\n          fromStorage.body = docInStorage;\n        } else {\n          this._state.addSystemErrorToStack(7, 'Error updating document in local storage');\n        }\n      } else {\n        fromStorage = {\n          statusCode: 200,\n          body: [document]\n        }\n      }\n      //console.log('This is the key in updateDataInCollection ' + JSON.stringify(params.query));\n      await this._state.deviceStorage.saveDocument(collection, hashedKey, fromStorage);\n      if (!local) {\n        this._state.addObjectToSyncMessage(collection, JSON.stringify(params), fromStorage);\n      }\n    }\n  }\n\n  async updateManyDataInCollection({\n    collection,\n    document,\n    query,\n    options,\n    audit,\n    sync = false,\n    system = false,\n    securedFields,\n    updateOperator = \"$set\",\n    cache = false,\n    asyncCall = false\n  }) {\n    let _ = this._state._;\n    let params = {\n      action: 'updateMany',\n      db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n      collection,\n      document,\n      query,\n      options,\n      userId: this._state.user.userId,\n      updateOperator,\n      securedFields\n    };\n    if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || (await this._state.online() && !(this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE))) {\n      return this._state.callLambda('MongoDBManager', params, this.getLambdaInvocationType(asyncCall))\n        .then(response => {\n          console.log(\"6.9 in then\");\n          return this.checkMongoResponse(response, params, cache, audit, false, _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.DB_OPERATIONS.UPSERT, sync);\n        })\n        .catch(error => {\n          console.log(\"7. adding system error \" + JSON.stringify(error));\n          this._state.addSystemErrorToStack(7, error.message);\n        });\n    } else {\n      let hashedKey = this._state.sha1(JSON.stringify(params));\n      let fromStorage = await this._state.deviceStorage.loadDocument(collection, hashedKey) || {};\n      if (_.size(fromStorage) > 0) {\n        //Update the fields in the doc and save\n        let docArray = _.get(fromStorage, 'body');\n        if (Array.isArray(docArray)) {\n          let docInStorage = [];\n          for (let i = 0; i < docArray.length; i++) {\n            docInStorage.push(_.merge(docArray[i], document));\n          }\n          fromStorage.body = docInStorage;\n        } else {\n          this._state.addSystemErrorToStack(7, 'Error updating document in local storage');\n        }\n      } else {\n        fromStorage = {\n          statusCode: 200,\n          body: [document]\n        }\n      }\n      //console.log('This is the key in updateDataInCollection ' + JSON.stringify(params.query));\n      await this._state.deviceStorage.saveDocument(collection, hashedKey, fromStorage);\n      this._state.addObjectToSyncMessage(collection, JSON.stringify(params), fromStorage);\n    }\n  }\n\n  async deleteDataFromCollection({ collection, query, sync, audit, system = false, deleteMany = false, local = false}) {\n    let params = {\n      action: deleteMany ? 'deleteMany' : 'delete',\n      db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n      collection,\n      query,\n      userId: this._state.user.userId,\n    };\n    if (local) {\n      let hashedKey = this._state.sha1(JSON.stringify(params));\n      return await this._state.deviceStorage.deleteDocument(collection, hashedKey);\n    }\n    return this._state.callLambda('MongoDBManager', params, 'RequestResponse')\n      .then(response => {\n        return this.checkMongoResponse(response, params, false, audit, false, _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.DB_OPERATIONS.DELETE, sync);\n      })\n      .catch(error => {\n        console.log(\"8. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  async deleteManyDataFromCollection({ collection, query, sync, audit, system = false }) {\n    let params = {\n      action: 'deleteMany',\n      db: system ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.SYSTEM_DB : this._state.currentUserDomain,\n      collection,\n      query,\n      userId: this._state.user.userId,\n    };\n    return this._state.callLambda('MongoDBManager', params, 'RequestResponse')\n      .then(response => {\n        return this.checkMongoResponse(response, params, false, audit, false, _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.DB_OPERATIONS.DELETE, sync);\n      })\n      .catch(error => {\n        console.log(\"8. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  async getCatalogue({ query, userDomain }) {\n    try {\n      let params = {\n        query: query,\n        isAllBotsRequest: true,\n        selectedDomain: userDomain,\n        email: this._state.user.userEmail,\n      };\n      let response = await this._state.callLambda('catalogueLambda', params, 'RequestResponse')\n      if (response) {\n        return JSON.parse(response.Payload);\n      }\n    } catch (error) {\n      console.log(\"9. adding system error\");\n      this._state.addSystemErrorToStack(7, null, error.message);\n    }\n  }\n\n  getStaticData(query, scan, pagination, sort) {\n    let tableName = 'KeyValues_' + this._state.currentUserDomain;\n    //console.log(tableName);\n    return this.getData(tableName, query, scan, pagination, sort);\n  }\n\n  getData(table, query, scan, pagination, sort) {\n    let params = {\n      collection: table,\n      query: query,\n      scan: scan,\n      capability: 'GetData',\n      pagination: pagination,\n      sort: sort,\n      sync: true,\n    };\n    return this._state.callLambda('SystemCapabilities', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"10. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  getDataFromIndex(index, queryString, pageSize, sort, exactMatch) {\n    let params = {\n      method: 'GET',\n      action: 'search',\n      index: this._state._.toLower(index),\n      q: queryString,\n      size: pageSize,\n      sort: sort,\n      exact: exactMatch,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"11. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  getDataFromIndexWithID(index, type, id) {\n    let params = {\n      method: 'GET_WITH_ID',\n      index: this._state._.toLower(index),\n      docType: type,\n      id: id,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"12. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  getDataFromIndexWithSQL(queryString) {\n    let params = {\n      method: 'SQL',\n      q: queryString,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"13. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  deleteDataFromIndex(index, type, objectId) {\n    let params = {\n      method: 'DELETE',\n      index: this._state._.toLower(index),\n      q: objectId,\n      docType: type,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"14. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  deleteDataFromIndexByID(index, type, objectId) {\n    let params = {\n      method: 'DELETE',\n      index: this._state._.toLower(index),\n      docType: type,\n      id: objectId,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"15. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  getDataFromIndexWithQueryObject(index, queryObject) {\n    let params = {\n      method: 'GET',\n      action: 'bodySearch',\n      index: this._state._.toLower(index),\n      q: queryObject,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        //console.log(JSON.stringify(response));\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"16. adding system error\");\n        //console.log(JSON.stringify(response));\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  countDataInIndex(index, queryString) {\n    let params = {\n      method: 'GET',\n      action: 'count',\n      index: this._state._.toLower(index),\n      q: queryString,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"17. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  writeDataIntoIndex({ index, docType = '_doc', doc }) {\n    let params = {\n      method: 'POST',\n      action: 'insert',\n      index: this._state._.toLower(index),\n      docType: docType,\n      doc: doc,\n    };\n    return this._state.callLambda(\"elastiSearch\", params, \"Event\")\n      .then(response => {\n        // return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"18. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  bulkWriteDataIntoIndex({ index, docType = '_doc', docs, docIdField }) {\n    let params = {\n      method: 'BULK_INSERT',\n      action: 'insert',\n      index: this._state._.toLower(index),\n      docType: docType,\n      docs,\n      docIdField,\n    };\n    return this._state.callLambda('elastiSearch', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"19. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  updateDataInIndex({ index, docType = '_doc', doc }) {\n    let params = {\n      method: 'PUT',\n      docType: docType,\n      index: this._state._.toLower(index),\n      doc: doc,\n      id: doc.id,\n    };\n    return this._state.callLambda(\"elastiSearch\", params, \"Event\")\n      .then(response => {\n        // return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"20. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  writeTransactionData(documents) {\n    let tableName = 'Transactions_' + this._state.currentUserDomain;\n    return this.writeData(tableName, documents);\n  }\n\n  writeStaticData(documents) {\n    let tableName = 'KeyValues_' + this._state.currentUserDomain;\n    return this.writeData(tableName, documents);\n  }\n\n  writeData(table, documents) {\n    let params = {\n      collection: table,\n      documents: documents,\n      capability: 'WriteData',\n    };\n    return this._state.callLambda('SystemCapabilities', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"21. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  async updateStaticData(filter, expression, expressionAttributeValues, expressionAttributeNames) {\n    let tableName = 'KeyValues_' + this._state.currentUserDomain;\n    let state = this._state;\n    let D = state.developer;\n    try {\n      if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE && this._state.v1Compatibility)) {\n        const frontmLib = this._state.frontmlib;\n        let updateQueryResponse = await frontmLib.dbUpdateItem(tableName, filter, expression, expressionAttributeValues, expressionAttributeNames);\n        return updateQueryResponse;\n      }\n    } catch (error) {\n      console.log(\"22. adding system error\");\n      D.log({ message: 'Error updateStaticData::: ', data: JSON.stringify(error) });\n      this._state.addSystemErrorToStack(7, null, error.message);\n    }\n  }\n\n  deleteTransactionData(query) {\n    let tableName = 'Transactions_' + this._state.currentUserDomain;\n    return this.deleteData(tableName, query);\n  }\n\n  deleteStaticData(query) {\n    let tableName = 'KeyValues_' + this._state.currentUserDomain;\n    return this.deleteData(tableName, query);\n  }\n\n  deleteData(table, query) {\n    let params = {\n      collection: table,\n      query: query,\n      capability: 'DeleteData',\n    };\n    return this._state.callLambda('SystemCapabilities', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"23. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  strigifyValue(value) {\n    if (this._.isString(value)) {\n      return value;\n    }\n    return this._.isObjectLike(value) ? JSON.stringify(value) : this._.toString(value);\n  }\n\n  createParamsForAdd(keyValuePairs) {\n    if (!Array.isArray(keyValuePairs)) {\n      keyValuePairs = [keyValuePairs];\n    }\n\n    return keyValuePairs.map(keyValue => {\n      let { key, value, expiry, isArrayElement, index } = keyValue;\n      value = this.strigifyValue(value);\n      return { key, value, expiry, isArrayElement, index };\n    });\n  }\n\n  callRedisWriteQueue(keyValuePairs) {\n    let lambdaParams = {\n      action: 'add',\n      data: keyValuePairs,\n    };\n    let size = this._state.sizeOfObject(JSON.stringify(lambdaParams, null, 0));\n    if (size >= 200000) {\n      //console.log(\"********** Danger danger danger!! Your PARAMS is too big!! ********** \" + size)\n    } else {\n      //console.log(\"********** Size is not important ********** \" + size)\n    }\n    return this._state.callLambda('RedisWriteQueue', lambdaParams, 'RequestResponse').then(response => {\n      return JSON.parse(response.Payload);\n    });\n  }\n\n  callRedisDeleteQueue(key) {\n    let lambdaParams = {\n      action: 'delete',\n      key,\n    };\n    return this._state.callLambda('RedisWriteQueue', lambdaParams, 'RequestResponse').then(response => {\n      return JSON.parse(response.Payload);\n    });\n  }\n\n  deleteOneKeyInCache(key) {\n    return this.callRedisDeleteQueue(key);\n  }\n\n  setOneValueInCache(key, value) {\n    return this.callRedisWriteQueue(this.createParamsForAdd({ key, value }));\n  }\n\n  setOneValueInCacheWithExpiry(key, value, expiry) {\n    let lambdaParams = this.createParamsForAdd({ key, value, expiry });\n    //console.log('Storing key ' + key);\n    return this.callRedisWriteQueue(lambdaParams);\n  }\n\n  setMultipleValuesInCache(keyValuePairs) {\n    return this.callRedisWriteQueue(this.createParamsForAdd(keyValuePairs));\n  }\n\n  addOneListElementInCache(key, value) {\n    return this.addMultipleListElementInCache({ key, value });\n  }\n\n  updateOneListElementInCache(key, value, index) {\n    return this.addMultipleListElementInCache({ key, value, index });\n  }\n\n  addMultipleListElementInCache(keyValuePairs) {\n    if (!Array.isArray(keyValuePairs)) {\n      keyValuePairs = [keyValuePairs];\n    }\n    keyValuePairs = keyValuePairs.map(keyValue => {\n      keyValue.isArrayElement = true;\n      return keyValue;\n    });\n    return this.callRedisWriteQueue(this.createParamsForAdd(keyValuePairs));\n  }\n\n  getValueFromCache(key) {\n    return this.getMultipleValuesFromCache(key).then(data => {\n      return data[key];\n    });\n  }\n\n  getObjectFromCache(key) {\n    return this.getMultipleValuesFromCache(key).then(data => {\n      let object = data[key]?.content;\n      if (object) {\n        try {\n          return JSON.parse(object);\n        } catch (err) {\n          return object\n        }\n      }\n    });\n  }\n\n  getMultipleValuesFromCache(keys) {\n    if (!Array.isArray(keys)) {\n      keys = [keys];\n    }\n    let lambdaParams = {\n      multiKeys: keys,\n    };\n    return this._state.callLambda('RedisReadQueue', lambdaParams, 'RequestResponse').then(response => {\n      return JSON.parse(response.Payload);\n    });\n  }\n\n  getKeysOnPattern(pattern) {\n    let lambdaParams = {\n      pattern,\n    };\n    return this._state.callLambda('RedisReadQueue', lambdaParams, 'RequestResponse').then(response => {\n      return JSON.parse(response.Payload);\n    });\n  }\n\n  async getUser(userId) {\n    try {\n      if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE && this._state.v1Compatibility)) {\n        let frontmLib = this._state.frontmlib;\n        return await frontmLib.getUser(userId);\n      }\n    } catch (error) {\n      console.log(\"24. adding system error\");\n      this._state.addSystemErrorToStack(7, null, error.message);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/DB.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Developer.js":
/*!**************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Developer.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Developer: function() { return /* binding */ Developer; }\n/* harmony export */ });\n/* harmony import */ var _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LogEntrytype */ \"../../Bitbucket/frontmjs/core/LogEntrytype.js\");\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _UnitTest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UnitTest */ \"../../Bitbucket/frontmjs/core/UnitTest.js\");\n/* harmony import */ var _Error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Error */ \"../../Bitbucket/frontmjs/core/Error.js\");\n\n\n\n\n\nclass Developer {\n  static DEBUG() {\n    return 'Debug';\n  }\n\n  static DEV() {\n    return 'Dev';\n  }\n\n  static PROD() {\n    return 'Prod';\n  }\n\n  static TEST() {\n    return 'Test';\n  }\n\n  static PERF() {\n    return 'Perf';\n  }\n\n  constructor(state) {\n    this['_state'] = state;\n    this['_debugMode'] = false;\n    this['_command'] = [];\n    this['_runProfile'] = Developer.PROD(); //Possible values also Prod and Test\n  }\n\n  init() {\n    this['_'] = this._state._;\n    this['R'] = this._state.R;\n  }\n\n  get runProfile() {\n    return this._runProfile;\n  }\n\n  set runProfile(runProfile) {\n    this._runProfile = runProfile;\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT && this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.LOCATIONS.EDGE && !this._state.v1Compatibility) {\n      this._state.context.devMode();\n    }\n  }\n\n  callBotPublisher(newBot, action) {\n    let params = {\n      action: action,\n      conversation: this._state.conversation,\n      botMetadata: newBot,\n      userId: this._state.user.userId,\n    };\n    return this._state.callLambda('BotPublisher', params, 'RequestResponse').then(response => {\n      let payload = JSON.parse(response.Payload);\n      if (payload.error !== 0) {\n        if (payload.error === 9) {\n          this._state.addSystemErrorToStack(9);\n        } else {\n          console.log(\"1. adding system error\");\n          this._state.addSystemErrorToStack(7, payload.error);\n        }\n      }\n      return payload.error;\n    });\n  }\n\n  publishBot(newBot) {\n    return this.callBotPublisher(newBot, 'publishNewBot');\n  }\n\n  updateBot(newBot) {\n    return this.callBotPublisher(newBot, 'updateBot');\n  }\n\n  deleteBotFromCatalogue(newBot) {\n    return this.callBotPublisher(newBot, 'deleteBot');\n  }\n\n  publishApp(newBot) {\n    return this.callBotPublisher(newBot, 'publishNewBotInNewFormat');\n  }\n\n  updateApp(newBot) {\n    return this.callBotPublisher(newBot, 'updateBotInNewFormat');\n  }\n\n  deleteAppFromCatalogue(newBot) {\n    return this.callBotPublisher(newBot, 'deleteBotInNewFormat');\n  }\n\n  setDebugActive() {\n    this.log({ message: 'Activating debug mode' });\n    this._debugMode = true;\n  }\n\n  validDeveloperDomains() {\n    let domains = [];\n    if (this._state.conversation.userDomain === 'frontmai') {\n      this._state._.each(this._state.userDomains, userDomain => {\n        let index = this._state._.findIndex(userDomain.roles, role => {\n          return (role = 'developer');\n        });\n        if (index > -1) {\n          domains.push(userDomain.domain);\n        }\n      });\n    } else {\n      domains.push(this._state.conversation.userDomain);\n    }\n    return domains;\n  }\n\n  isDeveloperIntent() {\n    return typeof this._state.messageFromUser === 'string' &&\n      this._state.messageFromUser.substring(0, 2) === '@@' &&\n      this._state.messageFromUser.substring(0, 5) !== '@@run';\n  }\n\n  identifyDeveloperIntent() {\n    if (typeof this._state.messageFromUser === 'string') {\n      let command = this._state.messageFromUser.toLowerCase();\n      switch (command) {\n        case '@@reset conversation':\n          return '_dev_reset_conversation';\n        case '@@debug on':\n          return '_dev_debug_switch_on';\n        case '@@debug off':\n          return '_dev_debug_switch_off';\n        case '@@inspect all':\n          return '_dev_inspect_all';\n        case '@@inspect nlp':\n          return '_dev_inspect_nlp';\n        case '@@inspect history':\n          return '_dev_inspect_history';\n        case '@@inspect messages':\n          return '_dev_inspect_messages';\n        case '@@inspect old fields':\n          return '_dev_inspect_old';\n        default:\n          if (this.R.includes('@@inspect state', command)) {\n            return '_dev_inspect_state';\n          } else if (this.R.includes('@@inspect', command)) {\n            return '_dev_inspect';\n          }\n      }\n    }\n    return null;\n  }\n\n  debug({ message, errorCode, data, more }) {\n    if (this.runProfile === Developer.DEBUG()) {\n      this.addEntryInES({ level: _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__.LogEntrytype.DEBUG(), message, errorCode, data, more });\n    }\n  }\n\n  log({ message, errorCode, data, more }) {\n    if (this.runProfile === Developer.DEV() || this.runProfile === Developer.DEBUG()) {\n      this.addEntryInES({ level: _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__.LogEntrytype.LOG(), message, errorCode, data, more });\n    }\n  }\n\n  info({ message, errorCode, data, more }) {\n    if (this.runProfile === Developer.DEBUG()) {\n      this.addEntryInES({ level: _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__.LogEntrytype.INFO(), message, errorCode, data, more });\n    }\n  }\n\n  warning({ message, errorCode, data, more }) {\n    this.addEntryInES({ level: _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__.LogEntrytype.WARNING(), message, errorCode, data, more });\n  }\n\n  perf({ message, errorCode, data, more }) {\n    if (this.runProfile === Developer.DEBUG() || this.runProfile === Developer.PERF()) {\n      this.addEntryInES({ level: _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__.LogEntrytype.PERF(), message, errorCode, data, more });\n    }\n  }\n\n  systemError({ message, errorCode, data, more }) {\n    this.addEntryInES({ level: _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__.LogEntrytype.SYSTEM_ERROR(), message, errorCode, data, more });\n  }\n\n  userError({ message, errorCode, data, more }) {\n    this.addEntryInES({ level: _LogEntrytype__WEBPACK_IMPORTED_MODULE_0__.LogEntrytype.USER_ERROR(), message, errorCode, data, more });\n  }\n\n  addEntryInES({ level, errorCode, message, data, more }) {\n    try {\n      //console.log('Message ' + this._state.R.toString(message));\n      let activeIntent;\n      if (this._state.activeIntent !== '') {\n        activeIntent = this._state.activeIntent;\n      }\n      let params = {\n        type: 'USER',\n        entry: {\n          userDomain: this._state.currentUserDomain,\n          userId: this._state.user.userId,\n          userEmail: this._state.user.userEmail,\n          botId: this._state.conversation.bot,\n          conversationId: this._state.conversationId,\n          entity: 'Micro-App',\n          intent: activeIntent,\n          client: this._state.client,\n          location: this._state.location,\n          timestamp: Date.now(),\n          level,\n          errorCode,\n          message,\n          data: !data || typeof data === 'string' ? data : JSON.stringify(data),\n        },\n      };\n      if (more) {\n        params.entry = { ...params.entry, ...more };\n      }\n      let size = this._state.sizeOfObject(JSON.stringify(params));\n      if (size > 200000) {\n        this.warning({ message: _Error__WEBPACK_IMPORTED_MODULE_3__.Error.getErrorMessageforCodeAndLang(50, 'en'), data: message })\n        return;\n      }\n      if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.LOCATIONS.CLOUD || (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.LOCATIONS.EDGE && this._state.v1Compatibility)) {\n        try {\n          let invocationType = \"Event\";\n          if (this.runProfile === Developer.DEBUG()) {\n            invocationType = \"RequestResponse\";\n          }\n          let lambda = this._state.frontmlib;\n          return lambda.invokeLambda('logger', invocationType, params);\n        } catch (err) {\n          this._state.context.log(params);\n        }\n      } else {\n        params.data = params.entry.data;\n        this._state.context.log(params);\n      }\n    } catch (err) {\n      // TODO: the function is causing maximum stack error. Has to replace.\n      // this._state.addSystemErrorToStack(26, '1 ' + err.name + ': ' + err.message);\n      console.log(err);\n    }\n  }\n\n  processCommand(command) {\n    switch (command) {\n      case '_dev_reset_conversation': {\n        this.resetConversation();\n        break;\n      }\n      case '_dev_debug_switch_on': {\n        this.debugSwitch(true);\n        break;\n      }\n      case '_dev_debug_switch_off': {\n        this.debugSwitch(false);\n        break;\n      }\n      case '_dev_inspect': {\n        this.inspectField();\n        break;\n      }\n      case '_dev_inspect_all': {\n        this.inspectAllFields();\n        break;\n      }\n      case '_dev_inspect_nlp': {\n        this.inspectNLPFields();\n        break;\n      }\n      case '_dev_inspect_state': {\n        this.inspectStateField();\n        break;\n      }\n      case '_dev_inspect_history': {\n        this.inspectHistory();\n        break;\n      }\n      case '_dev_inspect_messages': {\n        return this.inspectMessages();\n      }\n      case '_dev_inspect_old': {\n        return this.inspectOldFields();\n      }\n      default:\n        break;\n    }\n  }\n\n  //Commands\n\n  inspectField() {\n    let fieldName = this.R.head(this.R.drop(1, this.R.split(' ')(this._state.messageFromUser)));\n    if (fieldName) {\n      let fieldContent = this.R.toString(this._.get(this._state.fields, fieldName));\n      if (fieldContent) {\n        this._state.addStringResponse(fieldContent);\n        return;\n      }\n    }\n    this._state.addStringResponse('Could not find ' + fieldName);\n  }\n\n  inspectAllFields() {\n    let fieldContent = this.R.toString(this._state.fields);\n    this._state.addStringResponse(fieldContent);\n  }\n\n  inspectOldFields() {\n    let fieldContent = this.R.toString(this._state._oldFields);\n    this._state.addStringResponse(fieldContent);\n  }\n\n  inspectNLPFields() {\n    let fieldContent = this.R.toString(this._state._lastNLPResults);\n    this._state.addStringResponse(fieldContent);\n  }\n\n  inspectStateField() {\n    this._state.addStringResponse(this._state.R.toString(this._state.getAllProperties()));\n  }\n\n  inspectHistory() {\n    this._state.addStringResponse(this._state.R.toString(this._state._intentHistory));\n  }\n\n  inspectMessages() {\n    this._state.addStringResponse(this._state.R.toString(this._state._inputHistory));\n  }\n\n  debugSwitch(mode) {\n    if (this._debugMode && mode) {\n      this._state.addStringResponse('Debug mode is already active');\n    } else if (this._debugMode === mode) {\n      this._state.addStringResponse('Debug mode is already inactive');\n    } else {\n      this._debugMode = mode;\n      if (this._debugMode) {\n        this.log({ message: 'Debug mode set to active' });\n        this._state.addStringResponse('Debug mode activated');\n      } else {\n        this.log({ message: 'Debug mode set to inactive' });\n        this._state.addStringResponse('Debug mode deactivated');\n      }\n    }\n  }\n\n  resetConversation() {\n    console.log(\"Resetting conversation\");\n    this._state._activeIntent = '';\n    this._state.requestIdsArray = [];\n    this._state._intentHistory = [];\n    this._state._intentStats = {};\n    this._state.lastGreetingTime = 0;\n    this._state.errorStack = [];\n    this._state.fields = {};\n    this._state.sessionFields = {};\n    this._state.waitingCustomCap = 0;\n    this._state._currentSearchBox = '';\n    this._state._inSilence = false;\n    this._state._lastNLPResults = {};\n    this._state.clearSmartSuggestionsArray();\n    this._state.blockSuggestions = true;\n    this._state._silentIntent = false;\n    this._state.clearAutoSaveBuffer();\n    this._state.clearAutoSaveBufferChanges();\n    this._state.addStringResponse('The conversation has been reset');\n    this._state.sendMessage({ intentId: '@@reset' });\n  }\n\n  logCurrentEventDurationWithStartTime(event, startTime, endTime) {\n    try {\n      let newEventLog = {\n        event: event,\n        startTime: startTime,\n        duration: endTime - startTime,\n      };\n      this.perf({ more: newEventLog });\n    } catch (error) {\n\n    }\n  }\n\n  generateTestCaseStep({ message }) {\n    let params = {\n      state: this._state.getAllProperties(),\n      schedule: Date.now(),\n    };\n    params.state.messageTypeFromUser = message.type;\n    params.state.messageFromUser = message.content;\n    params.state.client = this._state.client;\n    params.state.userName = this._state.userName;\n    params.state.lang = 'en';\n    params.state.waitingCustomCap = 0;\n    params.state.messageFromUser.page = 0;\n    params.state.unitTestMode = true;\n    return params;\n  }\n\n  async submitTest({ testCases }) {\n    let currentTestCase = testCases[0];\n    this._state.setField(_UnitTest__WEBPACK_IMPORTED_MODULE_2__.UnitTest.TEST_CASES_FIELD(), testCases);\n    this._state.setField(_UnitTest__WEBPACK_IMPORTED_MODULE_2__.UnitTest.CURRENT_TEST_FIELD(), this._state.activeIntent);\n    let fullState = this.generateTestCaseStep({ message: currentTestCase });\n    let jobId = this._state.getUniqueId();\n    //console.log('Before submitting job');\n    let response = await this._state.jobScheduler.addNewJob(this._state.client, fullState, jobId, null);\n    //console.log('Job submitted');\n    if (response.jobId !== jobId) {\n      this._state.addErrorToStack(1000, `Problems submitting test case`);\n    } else {\n      return response.jobId;\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Developer.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/DeviceStorage.js":
/*!******************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/DeviceStorage.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeviceStorage: function() { return /* binding */ DeviceStorage; }\n/* harmony export */ });\nclass DeviceStorage {\n\n  constructor(state) {\n    this._state = state;\n    this.botContext = state.context;\n    let D = this._state.developer;\n    try {\n      this.deviceStorageCapability = this.botContext.getCapability('DeviceStorage');\n      this.sha1 = state.context.getCapability('sha1');\n    } catch (err) {\n      console.log('Problems creating device storage');\n    }\n  }\n\n  getKeyFromStorage(key) {\n    return this.deviceStorageCapability.get(key).then(result => {\n      return result\n    });\n  }\n\n  saveKeyInStorage(key, value) {\n    return this.deviceStorageCapability.save(key, value);\n  }\n\n  removeKeyFromStorage(key) {\n    return this.deviceStorageCapability.delete(key);\n  }\n\n  getStateForConversation(conversationId) {\n    if (!conversationId) {\n      return\n    }\n    return this.getKeyFromStorage.get(conversationId);\n  }\n\n  saveConversationState(state) {\n    if (!state) {\n      return\n    }\n    return this.saveKeyInStorage(state.conversationId, state);\n  }\n\n  async saveDocument(collection, primaryKey, document) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let key = `${collection}_${primaryKey}`;\n\n    let collectionKey = `Collection_${collection}`;\n    let allCollectionKeys = await this.getKeyFromStorage(collectionKey) || [];\n    let index = _.findIndex(allCollectionKeys, keyFromArray => {\n      return keyFromArray === key\n    });\n    if (index > -1) {\n      allCollectionKeys.splice(index, 1);\n    }\n    allCollectionKeys.push(key);\n    if (allCollectionKeys.length > 10) {\n      allCollectionKeys.splice(0, 1);\n      await this.removeKeyFromStorage(key);\n    }\n    await this.saveKeyInStorage(collectionKey, allCollectionKeys);\n\n    await this.saveKeyInStorage(key, document);\n  }\n\n  async deleteDocument(collection, primaryKey) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let key = `${collection}_${primaryKey}`;\n    let collectionKey = `Collection_${collection}`;\n    let allCollectionKeys = await this.getKeyFromStorage(collectionKey) || [];\n    let index = _.findIndex(allCollectionKeys, keyFromArray => {\n      return keyFromArray === key\n    });\n    if (index > -1) {\n      allCollectionKeys.splice(index, 1);\n    }\n    await this.saveKeyInStorage(collectionKey, allCollectionKeys);\n\n    await this.removeKeyFromStorage(key);\n  }\n\n  async loadDocument(collection, primaryKey) {\n    try {\n      let _ = this._state._;\n      let key = `${collection}_${primaryKey}`;\n      let document = await this.getKeyFromStorage(key);\n      return document;\n    } catch (err) {\n      console.log(\"DeviceStorage class error: Error stringifying primary key\");\n    }\n  }\n\n  async queryCollection(collection, query) {\n    try {\n      let _ = this._state._;\n      let D = this._state.developer;\n      // if we have a query we get only the data for that query\n      if (query) {\n        query = `${collection}_${query}`;\n        let doc = await this.getKeyFromStorage(query);\n        if (doc) {\n          return doc;\n        } else {\n          // this is added as if query is present and not in the storage it just goes down and returns all the data once again.\n          return {\n            statusCode: 200,\n            body: []\n          }\n        }\n      }\n\n      let collectionKey = `Collection_${collection}`;\n      let allCollectionKeys = await this.getKeyFromStorage(collectionKey) || [];\n      let allDocs = [];\n      for (let i = 0; i < allCollectionKeys.length; i++) {\n        let key = allCollectionKeys[i];\n        let doc = await this.getKeyFromStorage(key);\n        let body = _.get(doc, 'body');\n        if (body) {\n          allDocs = allDocs.concat(body)\n        }\n      }\n      return {\n        statusCode: 200,\n        body: allDocs\n      }\n    } catch (err) {\n      console.log(\"DeviceStorage class error: Error stringifying primary key\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/DeviceStorage.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Doc.js":
/*!********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Doc.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Doc: function() { return /* binding */ Doc; }\n/* harmony export */ });\n/* harmony import */ var _Intent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"../../Bitbucket/frontmjs/core/Utils.js\");\n/* harmony import */ var _Error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Error */ \"../../Bitbucket/frontmjs/core/Error.js\");\n\n\n\n\n\nclass Doc extends _Intent__WEBPACK_IMPORTED_MODULE_0__.Intent {\n\n  dataType = _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TYPES.DOC;\n\n  constructor(\n    intentId, state,\n    {\n      tabId,\n      title = 'Lookup',\n      description = 'lookup',\n      allowMinimize = true,\n      allowClose = true,\n      minimizeOnConfirm = true,\n      updateInBackground = false,\n      promptOnClose,\n      confirm,\n      cancel,\n      icon,\n      readOnly = false,\n      allowEdit = true,\n      zone,\n      parentDoc,\n      temp = false,\n      subDocs,\n      autoSave = false,\n      modal,\n      onResponse = () => {},\n      audit,\n      autoIndex = false,\n      docId = state.user.userId,\n      rowMenu,\n      allowDelete,\n      allowDeleteWhileOffline,\n      _id,\n      version,\n      onPostBuild = (self, doc) => {},\n      onPostBuildContainer = (self, container) => {},\n      onSave = async self => {},\n      onPostLoad = async self => {},\n      onSubmit = async () => {},\n      onCancel = async () => {},\n      onClose = async () => {},\n      onInit = async () => {},\n    }\n  ) {\n    super(intentId, state, tabId);\n    let D = this._state.developer;\n    this._state = state;\n    this._children = {};\n    this._document = {};\n    this._dbDocument = {};\n    this._documentForShortResponse = {};\n    this._subDoc = false;\n    this._subDocs = subDocs || [];\n    this._subCollections = [];\n    this._sectionCollections = {};\n    this._autoSave = autoSave;\n    this._audit = audit;\n    this.index = -1;\n    this._filteredCollectionName = \"\";\n    this._sections = {};\n    this._id = _id;\n    this.temp = temp;\n    this._autoIndex = autoIndex;\n    this.title = title;\n    this.description = description;\n    this.allowMinimize = allowMinimize;\n    this.allowClose = allowClose;\n    this.minimizeOnConfirm = minimizeOnConfirm;\n    this.updateInBackground = updateInBackground;\n    this.confirm = confirm;\n    this.cancel = cancel;\n    this.icon = icon;\n    this.modal = modal;\n    this.readOnly = readOnly;\n    this.allowEdit = allowEdit;\n    this.promptOnClose = promptOnClose;\n    this._rowMenu = rowMenu;\n    this._allowDelete = allowDelete;\n    this._allowDeleteWhileOffline = allowDeleteWhileOffline;\n    this._version = version;\n    this.zone = zone;\n    this._fields = [];\n    this._f = {};\n    this.docId = docId;\n    this.onPostBuild = onPostBuild;\n    this.onPostBuildContainer = onPostBuildContainer;\n    this.onSave = onSave;\n    this.onPostLoad = onPostLoad;\n    this.onSubmit = onSubmit;\n    this.onCancel = onCancel;\n    this.onClose = onClose;\n    this.onResponse = onResponse;\n    this.onInit = onInit;\n    if (parentDoc) {\n      if (parentDoc.dataType === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TYPES.DOC) {\n        this._subDoc = true;\n        this._parentDoc = parentDoc;\n        parentDoc.addChildDoc(this);\n      } else {\n        this._state.addSystemErrorToStack(7, `Sub documents cannot be saved ${this._intentId}`);\n      }\n    }\n  }\n  resetProperties() {\n    this.docId = this._state.user.userId;\n  }\n\n  cloneDoc(intentId, fieldsSuffix) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let newDoc = new Doc(intentId || this.intentId, this._state, {\n      title: this.title,\n      description: this.description,\n      allowMinimize: this.allowMinimize,\n      allowClose: this.allowClose,\n      minimizeOnConfirm: this.minimizeOnConfirm,\n      updateInBackground: this.updateInBackground,\n      promptOnClose: this.promptOnClose,\n      confirm: this.confirm,\n      cancel: this.cancel,\n      icon: this.icon,\n      readOnly: this.readOnly,\n      allowEdit: this.allowEdit,\n      zone: this.zone,\n      autoSave: this.autoSave,\n      modal: this.modal,\n      onResponse: this.onResponse,\n      onPostBuild: this.onPostBuild,\n      onPostBuildContainer: this.onPostBuildContainer,\n      audit: this._audit,\n      allowDelete: this.allowDelete,\n      allowDeleteWhileOffline: this.allowDeleteWhileOffline,\n      rowMenu: this.rowMenu,\n      onInit: this.onInit,\n      docId: this._state.getUniqueId()\n    });\n    newDoc._sections = this._sections;\n    newDoc.onPostBuild = this.onPostBuild;\n    newDoc.onSave = this.onSave;\n    newDoc.onPostBuildContainer = this.onPostBuildContainer;\n    newDoc.onPostLoad = this.onPostLoad;\n    if (this._collection) {\n      newDoc._collection = this._collection;\n      newDoc._collectionDBName = this._collectionDBName;\n      //newDoc.setCollection(doc._collection);\n    }\n    this._state.duringBuild = true;\n    _.forEach(this.fields, field => {\n      // field.duringBuild = true;\n      field.cloneField(newDoc, fieldsSuffix);\n    });\n    this._state.duringBuild = false;\n    _.forEach(this._subDocs, subDoc => {\n      // D.log({message: 'Adding subDoc', data: subDoc.intentId});\n      let newSubDoc = subDoc.cloneDoc();\n      newSubDoc._autoSave = newDoc._autoSave;\n      newSubDoc._parentDoc = newDoc;\n      newSubDoc._subDoc = true;\n      newDoc.addChildDoc(newSubDoc);\n    });\n    return newDoc\n  }\n\n  options(parent, quickForm) {\n    return {\n      parent,\n      formId: this.intentId,\n      controlId: this.intentId,\n      docId: this.docId,\n      tabId: this.tabId,\n      title: this.title,\n      description: this.description,\n      allowMinimize: this.allowMinimize,\n      allowClose: this.allowClose,\n      minimizeOnConfirm: this.minimizeOnConfirm,\n      updateInBackground: this.updateInBackground,\n      promptOnClose: this.promptOnClose,\n      confirm: this.confirm,\n      cancel: this.cancel,\n      icon: this.icon,\n      readOnly: this.readOnly,\n      allowEdit: this.allowEdit,\n      zone: this.zone,\n      allowDelete: this._allowDelete,\n      allowDeleteWhileOffline: this._allowDeleteWhileOffline,\n      rowMenu: this._rowMenu,\n      modal: !!quickForm,\n      sections: this._sections,\n      version: this.version\n    }\n  }\n\n  getCollectionData() {\n    const D = this._state.developer;\n    const _ = this._state._;\n    let collectionData = {};\n    _.map(this._sectionCollections, (collection, section) => {\n      collection.prepareCollectionOptions();\n      collectionData[section] = {\n        rows: collection.getRowsForShortResponse(),\n        options: collection.options\n      };\n    });\n    return collectionData;\n  }\n\n  formResponseWithAction(action, result, quickForm, forCollection, parent) {\n    let oldAllowDelete = this._allowDelete;\n    let oldAllowEdit = this.allowEdit;\n    let r = result;\n    let a = action;\n    let columnTemplate;\n    if (action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CHANGE && Array.isArray(r)) {\n      r = {\n        fields: result,\n      };\n    } else if (action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.DELETE_ROW) {\n      r = {\n        deleteRow: [this.docId]\n      }\n      a = _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CHANGE;\n    } else if (action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.ADD_ROW && Array.isArray(r)) {\n      r = {\n        append: result\n      }\n      a = _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CHANGE;\n    } else if (action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CHANGE_COLUMN_TEMPLATE) {\n      r = [];\n      let collection = this.collection;\n      if (collection) {\n        columnTemplate = collection.generateTableColumnTemplate();\n      }\n    }\n    let collection = this.collection;\n    let tableId;\n    let parentDocId;\n    let rowOptions;\n    if (forCollection && collection) {\n      tableId = collection.intentId;\n      if (this._state && this._state.messageFromUser) {\n        parentDocId = this._state.messageFromUser.parentDocId;\n      }\n      if (this._state && this._state.messageFromUser.action !== _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.MOVE && this._state.messageFromUser.action !== _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.SEARCH && (oldAllowDelete !== this._allowDelete || oldAllowEdit !== this.allowEdit)) {\n        rowOptions = {\n          allowDelete: this._allowDelete,\n          allowEdit: this.allowEdit,\n          rowMenu: this.rowMenu\n        }\n      }\n    }\n    let options = this.options(parent, quickForm)\n    options.tableId = tableId;\n    options.parentDocId = parentDocId;\n    options.action = a;\n    options.rowOptions = rowOptions;\n    options.columnTemplate = columnTemplate;\n    options.sectionId = collection?.sectionId;\n    return {\n      result: r,\n      options\n    };\n  }\n\n  getParentForMessage(skipOnResponse) {\n    if (!skipOnResponse) {\n      this.onResponse(this);\n    }\n    let parent = null;\n    if (this._parent) {\n      parent = this._parent._intentId;\n    }\n    return parent\n  }\n\n  message(action, result, quickForm, forCollection, skipOnResponse) {\n    let parent = this.getParentForMessage(skipOnResponse);\n    if (action) {\n      return this.formResponseWithAction(action, result, quickForm, forCollection, parent)\n    } else {\n      let fields = [];\n      this._fields.forEach(field => {\n        let fieldMessage = field.message(skipOnResponse);\n        if (fieldMessage && (!quickForm || (quickForm && field.includeInQuickEdit))) {\n          fields.push(fieldMessage)\n        }\n      });\n      return {\n        fields: fields,\n        options: this.options(parent, quickForm),\n      };\n    }\n  }\n\n  shortMessage(action, result, quickForm, forCollection, skipOnResponse) {\n    let parent = this.getParentForMessage(skipOnResponse);\n    if (action) {\n      return this.formResponseWithAction(action, result, quickForm, forCollection, parent);\n    } else {\n      let fieldKeys = _Utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getGenericKeys();\n      let fieldData = [];\n      this._fields.forEach(field => {\n        let fieldMessage = field.shortMessage(skipOnResponse);\n        if (fieldMessage && (!quickForm || (quickForm && field.includeInQuickEdit))) {\n          fieldData.push(fieldMessage)\n        }\n      });\n      return {\n        fields: {\n          fieldKeys,\n          fieldData\n        },\n        options: this.options(parent, quickForm),\n        collectionData: this.getCollectionData()\n      };\n    }\n  }\n\n  set parent(parent) {\n    this._parent = parent;\n  }\n\n  get formId() {\n    return this.intentId;\n  }\n\n  get fields() {\n    return this._fields;\n  }\n\n  get f() {\n    return this._f;\n  }\n\n  set fields(fields) {\n    this._fields = [];\n    this.addFields(fields);\n  }\n  \n  get version() {\n    return this._version;\n  }\n\n  set version(version) {\n    this._version = version;\n  }\n\n  addField(field) {\n    if (field.dataType === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TYPES.FIELD) {\n      this._fields.push(field);\n      this._f[field._intentId] = field;\n      return this._fields.length > 0 ? (this._fields.length - 1) : 0\n    } else {\n      state.addSystemErrorToStack(_Error__WEBPACK_IMPORTED_MODULE_3__.Error.getErrorMessageforCodeAndLang(28));\n    }\n  }\n\n  addFields(fields) {\n    if (Array.isArray(fields)) {\n      fields.forEach(field => {\n        this.addField(field);\n      });\n    }\n  }\n\n  removeFieldWithId(id) {\n    delete this._f[id];\n    let _ = this._state._;\n    let index = _.findIndex(this._fields, field => {\n      return field.id === id;\n    })\n    if (index > -1) {\n      this._fields.splice(index, 0, 1);\n    }\n  }\n\n  addSection(section) {\n    this._sections[section.sectionId] = section.message();\n  }\n\n  get allowDelete() {\n    return this._allowDelete;\n  }\n\n  set allowDelete(allowDelete) {\n    this._allowDelete = allowDelete;\n  }\n\n  get rowMenu() {\n    return this._rowMenu;\n  }\n\n  set rowMenu(rowMenu) {\n    this._rowMenu = rowMenu;\n  }\n\n  sendResponse() {\n    this._state.addFormResponse(this.message());\n  }\n\n  sendShortResponse() {\n    this._state.addShortFormResponse(this.shortMessage());\n  }\n\n  sendChangeResponse(changedFieldsArray) {\n    this._state.addFormChangeResponse(\n      this.message(_ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CHANGE, changedFieldsArray)\n    )\n  }\n\n  sendQuickDocResponse() {\n    this._state.addFormResponse(this.message(null, null, true));\n  }\n\n  setCollection(collection) {\n    this._collection = collection.intentId;\n    this._collectionDBName = collection.name;\n  }\n\n  get collection() {\n    return this._state.intents[this._collection];\n  }\n\n  getPrimaryKey() {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let primaryKey = {};\n    _.forEach(this._fields, field => {\n      if (field.primaryKey && field.value && !field.temp) {\n        primaryKey[field.dbName || field._intentId] = field.value;\n      }\n    });\n    return primaryKey;\n  }\n\n  getPrimaryKeyAsStringForSearch(object) {\n    let result = \"\";\n    this._state._.forEach(object, field => {\n      let f = field;\n      if (typeof field !== 'string') {\n        f = this._state.R.toString(field);\n      }\n      if (result === \"\") {\n        result = result + f;\n      } else {\n        result = result + \"-\" + f;\n      }\n    });\n    return result\n  }\n\n  getNonPrimaryKey() {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let primaryKey = {};\n    _.forEach(this._fields, field => {\n      if (!field.primaryKey && field.value) {\n        primaryKey[field._intentId] = field.value;\n      }\n    });\n    return primaryKey;\n  }\n\n  buildDocumentFromContainer(container, skipPostBuild) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let rootDoc = container[this.intentId];\n    let start = Date.now();\n    if (typeof rootDoc !== 'undefined') {\n      this.buildDocument(rootDoc, skipPostBuild);\n    } else {\n      this.buildDocument(container, skipPostBuild);\n    }\n    _.forEach(this._subDocs, subDoc => {\n      let doc = container[subDoc.intentId];\n      if (doc && !subDoc.temp) {\n        subDoc.buildDocument(doc, skipPostBuild)\n        this._document[subDoc.intentId] = subDoc.document;\n        this._dbDocument[subDoc.intentId] = subDoc.document;\n      }\n    });\n    _.forEach(this._subCollections, subCollection => {\n      let collection = container[subCollection.intentId];\n      if (collection && !subCollection.temp) {\n        let childArray = [];\n        subCollection.clearRows();\n        _.forEach(collection, entry => {\n          let newDoc = subCollection.document.cloneDoc();\n          subCollection.addRow(newDoc);\n          newDoc.buildDocument(entry, skipPostBuild);\n          childArray.push(newDoc.document);\n        });\n        this._document[subCollection.intentId] = childArray;\n        this._dbDocument[subCollection.intentId] = childArray;\n      }\n    });\n    return this._document;\n  }\n\n  buildDocument(docFromDB, skipPostBuild, withAutoSave) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    try {\n      if (!withAutoSave)\n        this._state.duringBuild = true; // -- setting the auto save changes trigger to ignoring changes\n      let doc = {};\n      _.forEach(docFromDB, (value, key) => {\n        if (key === '_id') {\n          this._id = value;\n        } else if (key === 'docId') {\n          this.docId = value\n        } else if (key === 'allowEdit') {\n          this.allowEdit = value\n        } else if (key === 'allowDelete') {\n          this.allowDelete = value\n        } else if (key === 'rowMenu') {\n          this.rowMenu = value\n        } else {\n          let v = docFromDB[key];\n          if (typeof v === 'object' && _.get(v, 'text')) {\n            v = _.get(v, 'text')\n          }\n          if (typeof v === 'object' && _.get(v, 'fileName')) {\n            v = {\n              value: _.get(v, 'value'),\n              fileName: _.get(v, 'fileName')\n            }\n          }\n          if (this.f[key]) {\n            // this.f[key].duringBuild = true;\n            this.f[key].value = v;\n            doc[key] = this.f[key].value;\n          } else {\n            _.forEach(this._fields, field => {\n              if (field._intentId === key || field.title === key || field.dbName === key) {\n                // field.duringBuild = true;\n                field.value = v;\n                doc[field._intentId] = field.value;\n              }\n            });\n          }\n        }\n      });\n      if (!skipPostBuild) {\n        this.onPostBuild(this, docFromDB);\n      }\n      this._state.duringBuild = false; // -- auto save changes trigger to the usual state\n      return this._document;\n    } catch (error) {\n      D.log({ message: 'Error building document', data: docFromDB });\n      this._state.addSystemErrorToStack(45, null, error.message);\n    }\n  }\n\n  buildDocumentFromUserMessage(messageFromUser) {\n    let _ = this._state._;\n    this._state.duringBuild = true; // -- setting the auto save changes trigger to ignoring changes\n\n    let messageFromUserRefactored = {};\n    _.forEach(messageFromUser.fields, message => {\n      messageFromUserRefactored[message.id] = message;\n    });\n\n    _.forEach(this._fields, field => {\n      if (_.get(messageFromUserRefactored[field.intentId], 'fileName')) {\n        field.value = {\n          value: _.get(messageFromUserRefactored[field.intentId], 'value'),\n          fileName: _.get(messageFromUserRefactored[field.intentId], 'fileName')\n        }\n      } else {\n        field.value = _.get(messageFromUserRefactored[field.intentId], 'value');\n      }\n    })\n\n    this._state.duringBuild = false;\n  }\n\n  clearDocument() {\n    let _ = this._state._;\n    let D = this._state.developer;\n    this._document = {};\n    this._dbDocument = {};\n    _.forEach(this._fields, field => {\n      if (!field.primaryKey) {\n        field._value = field._originalValue;\n      }\n    });\n  }\n\n  processDataFromDB(payload) {\n    if (Array.isArray(payload)) {\n      if (payload.length === 1) {\n        let result = {};\n        if (this.hasSubDocs) {\n          result = this.buildDocumentFromContainer(payload[0])\n        } else {\n          result = this.buildDocument(payload[0]);\n        }\n        return result\n      } else if (payload.length > 1) {\n        this._state.addErrorToStack(7, 'Multiple records returned by query while expecting only one', payload);\n      } else return {}\n    } else {\n      return this.buildDocument(payload)\n    }\n  }\n\n  async loadDocument(query) {\n    let start = Date.now();\n    if (this._subDoc) {\n      this._state.addSystemErrorToStack(7, `Sub documents cannot be loaded ${this._intentId}`);\n      return\n    }\n    if (!this._collection) {\n      this._state.addSystemErrorToStack(7, `Collection not assigned to document ${this._intentId}`);\n      return\n    }\n    let _ = this._state._;\n    let R = this._state.R;\n    let D = this._state.developer;\n    this.clearDocument();\n    this.docId = this._state.user.userId;\n    this.clearAutoSaveBuffer();\n    let primaryKey = {};\n    if (query) {\n      primaryKey = query;\n    } else {\n      primaryKey = this.getPrimaryKey();\n    }\n    if (_.size(primaryKey) > 0) {\n      let results = await this._state.db.getDataFromCollection({\n        collection: this._collectionDBName,\n        local: this.collection.local,\n        query: primaryKey,\n        expectOneResult: true,\n        system: _.get(this.collection, 'system'),\n        cache: _.get(this.collection, '_cache'),\n        securedFields: this.getSecuredFieldsArray()\n      });\n      if (_.get(results, 'statusCode') === 200) {\n        let payload = results.body;\n        let result = this.processDataFromDB(payload);\n        await this.onPostLoad(this);\n        return result;\n      } else {\n        this._state.addSystemErrorToStack(7, 'Error reading MongoDB');\n      }\n    } else {\n      this._state.addErrorToStack(7, 'You need to add some values to the primary key or passing a value in query before calling loadDocument(query)');\n    }\n  }\n\n  get deltaDoc() {\n    let _ = this._state._;\n    let delta = {};\n    let D = this._state.developer;\n    _.forEach(this._fields, field => {\n      if (field.getAutoSavedValueChanged()) {\n        delta[field.dbName || field._intentId] = field.value;\n      }\n    })\n    if (this.hasSubDocs) {\n      _.forEach(this._subDocs, subDoc => {\n        let deltaSubDoc = subDoc.deltaDoc;\n        if (_.size(deltaSubDoc) > 0) {\n          _.forEach(deltaSubDoc, (value, key) => {\n            delta[`${subDoc.intentId}.${key}`] = value;\n          });\n        }\n      });\n      // has an issue and have to check properly\n      _.forEach(this._subCollections, subCollection => {\n        delta[subCollection.intentId] = subCollection.rowAsDocumentsArray()\n      })\n    }\n    return delta;\n  }\n\n  //sync is a flag to indicate that the save is coming from an offline sync and not from a save\n  async saveDelta(sync, withKey) {\n    //TODO: saveDelta is not yet fully functional\n    let D = this._state.developer;\n    let _ = this._state._;\n    await this.onSave(this);\n    if (this._subDoc) {\n      this._state.addSystemErrorToStack(7, `Sub documents cannot be saved ${this._intentId}`);\n      return\n    }\n    let query = {};\n    if (withKey) {\n      query = withKey\n    } else {\n      query = this.getPrimaryKey();\n    }\n    let options = {\n      upsert: true // or 1\n    };\n    D.info({\n      message: 'Saving doc delta',\n      data: { collection: this._collectionDBName, document: this.deltaDoc, query }\n    })\n    if (this._autoIndex) {\n      await this.saveToIndex();\n    }\n    await this._state.db.updateDataInCollection({\n      collection: this._collectionDBName,\n      document: this.deltaDoc,\n      query,\n      options,\n      audit: this._audit,\n      sync,\n      system: _.get(this.collection, 'system'),\n      securedFields: this.getSecuredFieldsArray(),\n      cache: this.collection.cache\n    });\n  }\n\n  async save(sync, withKey, legacy) {\n    //sync is a flag to indicate that the save is coming from an offline sync and not from a save\n    let D = this._state.developer;\n    let _ = this._state._;\n    await this.onSave(this);\n    if (this._subDoc) {\n      this._state.addSystemErrorToStack(7, `Sub documents cannot be saved ${this._intentId}`);\n      return\n    }\n    let query = {};\n    if (withKey) {\n      query = withKey\n    } else {\n      query = this.getPrimaryKey();\n    }\n    let options = {\n      upsert: true // or 1\n    };\n    D.info({ message: 'Saving doc', data: { collection: this._collectionDBName, document: this._dbDocument, query } })\n    if (this._autoIndex) {\n      await this.saveToIndex();\n    }\n    await this._state.db.updateDataInCollection({\n      collection: this._collectionDBName,\n      document: legacy ? this._document : this._dbDocument,\n      local: this.collection?.local,\n      query,\n      options,\n      audit: this._audit,\n      sync,\n      system: _.get(this.collection, 'system'),\n      securedFields: this.getSecuredFieldsArray(),\n      cache: this.collection.cache\n    });\n  }\n\n  async legacySave(sync, withKey) {\n    await this.save(sync, withKey, true)\n  }\n\n  get indexName() {\n    return `${_ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.PREFIXES.INDEX}_${this._state.currentUserDomain}_${this._collectionDBName}`\n  }\n\n  async queryKeyFromIndex() {\n    let D = this._state.developer;\n    let _ = this._state._;\n    let primaryKey = this.getPrimaryKey();\n    let queryObject = _Utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getTermQueryForObject(primaryKey, this._state);\n    let payload = await this._state.db.getDataFromIndexWithQueryObject(this.indexName, queryObject);\n    if (!_.get(payload, \"errorMessage\") && !_.get(payload, \"error\")) {\n      return payload\n    }\n  }\n\n  async loadDocumentFromIndex() {\n    let _ = this._state._;\n    let D = this._state.developer;\n    this.clearDocument();\n    let payload = await this.queryKeyFromIndex();\n    let result = await this.processDataFromDB(payload);\n    //D.log({message: 'Results from index', data: result});\n    return result;\n  }\n\n  async saveToIndex() {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let payload = await this.queryKeyFromIndex();\n    if (payload) {\n      D.info({ message: 'Updating record in ES' });\n      let docToUpdate = _.cloneDeep(this._dbDocument);\n      docToUpdate.id = _.get(payload[0], '_id');\n      await this._state.db.updateDataInIndex({ index: this.indexName, doc: docToUpdate });\n    } else {\n      D.info({ message: 'Inserting record in ES' });\n      await this._state.db.writeDataIntoIndex({ index: this.indexName, doc: this._dbDocument });\n    }\n  }\n\n  async delete() {\n    let D = this._state.developer;\n    let _ = this._state._;\n    D.info({ message: 'Deleting doc', data: { collection: this._collectionDBName, document: this._dbDocument } })\n    let query = this.getPrimaryKey();\n    await this._state.db.deleteDataFromCollection({\n      collection: this._collectionDBName,\n      document: this._dbDocument,\n      query,\n      local: this.collection?.local,\n      system: _.get(this.collection, 'system')\n    });\n  }\n\n  rebuildDocumentObject() {\n    let _ = this._state._;\n    if (_.size(this._document) === 0) {\n      _.forEach(this._fields, field => {\n        if (!field.temp) {\n          this._document[field._intentId] = field.value;\n          this._dbDocument[field.dbName || field._intentId] = field.value;\n        }\n      })\n    }\n    if (this.hasSubDocs) {\n      _.forEach(this._subDocs, subDoc => {\n        if (!subDoc.temp) {\n          this._document[subDoc.intentId] = subDoc.rebuildDocumentObject();\n          this._dbDocument[subDoc.intentId] = this._document[subDoc.intentId];\n        }\n      })\n      _.forEach(this._subCollections, subCollection => {\n        if (!subCollection.temp) {\n          let rowDocuments = []\n          _.forEach(subCollection.rows, row => {\n            rowDocuments.push(row.rebuildDocumentObject());\n          });\n          this._document[subCollection.intentId] = rowDocuments;\n          this._dbDocument[subCollection.intentId] = this._document[subCollection.intentId];\n        }\n      })\n    }\n    return this._document\n  }\n\n  getSecuredFieldsArray() {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let securedFieldsArray = [];\n    _.forEach(this._fields, field => {\n      if (field.encrypted) {\n        securedFieldsArray.push(field.dbName || field.id);\n      }\n    })\n    if (this.hasSubDocs) {\n      _.forEach(this._subDocs, subDoc => {\n        let subDocArray = subDoc.getSecuredFieldsArray();\n        _.forEach(subDocArray, entry => {\n          securedFieldsArray.push(`${subDoc.intentId}.${entry}`)\n        });\n      })\n      _.forEach(this._subCollections, subCollection => {\n        let subDoc = subCollection.document;\n        let subDocArray = subDoc.getSecuredFieldsArray();\n        _.forEach(subDocArray, entry => {\n          securedFieldsArray.push(`${subDoc.intentId}.${entry}`)\n        });\n      })\n    }\n    return securedFieldsArray\n  }\n\n  get document() {\n    let _ = this._state._;\n    if (_.size(this._document) === 0) {\n      _.forEach(this._fields, field => {\n        this._document[field._intentId] = field.value;\n      })\n    }\n    return this._document;\n  }\n\n  set document(doc) {\n    this._document = doc;\n  }\n\n  get hasSubDocs() {\n    return this._subDocs.length > 0 || this._subCollections.length > 0;\n  }\n\n  get autoSave() {\n    return this._autoSave;\n  }\n\n  set autoSave(autoSave) {\n    this._autoSave = autoSave;\n  }\n\n  addChildDoc(child) {\n    this.docId = this._state.user.userId; \n    if (child.dataType === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TYPES.DOC) {\n      this._subDocs.push(child)\n    } else if (child.dataType === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.TYPES.COLLECTION) {\n      this._subCollections.push(child)\n    } else {\n      this._state.addSystemErrorToStack(7, `Child must be instance of either Doc or Collection classes ${this._intentId}`);\n      return false\n    }\n    this._children[child.intentId] = child;\n    return true\n  }\n\n  get children() {\n    return this._children\n  }\n\n  get onMatching() {\n    return state => {\n      let inputControlId = state.messageFromUser.controlId || state.messageFromUser.formId;\n      return (\n        state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.RESPONSES.FORM_RESPONSE &&\n        !state.messageFromUser.currentField &&\n        inputControlId === this.formId\n      );\n    };\n  }\n\n  async _callEvents(state) {\n    if (this._parent && this._parent._intentId === state.currentControlId) {\n      state.currentControlId = this._parent._intentId;\n    } else {\n      state.currentControlId = this.intentId;\n    }\n    if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CONFIRM) await this.onSubmit();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CANCEL) await this.onCancel();\n    else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CLOSE) await this.onClose();\n    else state.addSystemErrorToStack(29, _Error__WEBPACK_IMPORTED_MODULE_3__.Error.getErrorMessageforCodeAndLang(29));\n    if (state.responsesArray.length === 0) {\n      state.addSilentResponse();\n    }\n  }\n\n  get onResolution() {\n    return async state => {\n      console.log(\"In Doc resolution\");\n      let _ = state._;\n      let docId = _.get(state.messageFromUser, 'docId');\n      let tabId = _.get(state.messageFromUser, 'tabId');\n      if (docId) {\n        let parentDocId = _.get(state.messageFromUser, 'parentDocId');\n        this.loadDocFromAutoSaveBuffer(tabId, docId, parentDocId);\n      }\n      if (!docId || _.get(state.messageFromUser, 'action') === _ALLConstants__WEBPACK_IMPORTED_MODULE_1__.ALL_CONSTANTS.ACTIONS.CONFIRM) {\n        let document = _Utils__WEBPACK_IMPORTED_MODULE_2__.Utils.formResponseAsObject(state.messageFromUser);\n        this.buildDocument(document);\n      }\n      state.currentControlId = this.intentId;\n      if (tabId) {\n        this.tabId = tabId;\n      }\n      await this._callEvents(state);\n    };\n  }\n\n  overrideParentDocId(parentDocId) {\n    let _ = this._state._;\n    if (this._parentDoc) {\n      this._parentDoc.overrideParentDocId(parentDocId)\n    } else {\n      if (this._collection) {\n        let collection = _.get(this._state.intents, this._collection);\n        if (collection._parentDoc) {\n          collection._parentDoc.overrideParentDocId(parentDocId)\n        } else {\n          if (_.size(this._children) > 0) {\n            this.docId = parentDocId\n          }\n        }\n      }\n    }\n  }\n\n  loadDocFromAutoSaveBuffer(tabId, docId, parentDocId) {\n    if (this.autoSave) {\n      let _ = this._state._;\n      if (docId) this.docId = docId;\n      if (parentDocId) this.overrideParentDocId(parentDocId);\n      this._state.duringBuild = true;\n      _.forEach(this._fields, field => {\n        field.setValueFromAutoSave(tabId, parentDocId);\n      })\n      if (this._subCollections?.length > 0) {\n        _.forEach(this._subCollections, subCollection => {\n          subCollection.clearRows();\n          subCollection.loadRowsFromAutoSaveBuffer(tabId);\n          this._document[subCollection.intentId] = subCollection.rowAsDocumentsArray();\n          this._dbDocument[subCollection.intentId] = subCollection.rowAsDocumentsArray();\n        });\n      }\n      this._state.duringBuild = false;\n    }\n  }\n\n  generateAutoSaveBufferFromDoc() {\n    if (!this.docId) {\n      this.docId = this._state.getUniqueId();\n      this._fields.forEach(field => {\n        field.setAutoSaveFieldValue(field.value);\n\n      });\n    }\n  }\n\n  getAutoSavePath(tabId, parentDocId) {\n    let state = this._state;\n    try {\n      let _ = state._;\n      let D = state.developer;\n      let tabIdToLoad = tabId || state.currentTabId || this.tabId;\n      if (this._parentDoc) {\n        let docPath = this._parentDoc.getAutoSavePath(tabIdToLoad, parentDocId);\n        return `${docPath}.${this.intentId}`\n      } else {\n        let collectionName = _.get(this, '_collection');\n        if (collectionName) {\n          let collection = _.get(state.intents, collectionName); //It will be present if the doc is correctly defined for storage\n          if (collection) {\n            let docPath = collection.getAutoSavePath(tabIdToLoad, parentDocId);\n            let docIdToUse = this.docId;\n            if (!collection._parentDoc) {\n              if (parentDocId) {\n                docIdToUse = parentDocId\n              }\n            }\n            return state._version >= 3 ? `${docPath}.${docIdToUse}` : `${docPath}.${this.intentId}`\n          }\n        }\n      }\n    } catch (error) {\n      state.addSystemErrorToStack(999, error.message, this.intentId)\n    }\n  }\n\n  clearAutoSaveBuffer(tabId, docId, parentDocId) {\n    if (!this.autoSave) return;\n    let _ = this._state._;\n    let autoSaveBuffer = this._state.autoSaveBuffer;\n    let tabIdToUse = tabId || this._state.currentTabId || this.tabId;\n    if (docId) this.docId = docId;\n    if (parentDocId) this.overrideParentDocId(parentDocId);\n    if (_.get(autoSaveBuffer, tabIdToUse)) {\n      let path = this.getAutoSavePath(tabIdToUse, parentDocId);\n      if (path) {\n        _.unset(autoSaveBuffer, path);\n      }\n    }\n  }\n\n  clearAutoSaveBufferChanges(tabId, docId, parentDocId) {\n    let _ = this._state._;\n    let autoSaveBufferChanges = this._state.autoSaveBufferChanges;\n    let tabIdToUse = tabId || this._state.currentTabId || this.tabId;\n    if (docId) this.docId = docId;\n    if (parentDocId) this.overrideParentDocId(parentDocId);\n    if (_.get(autoSaveBufferChanges, tabIdToUse)) {\n      let path = this.getAutoSavePath(tabIdToUse, parentDocId);\n      if (path) {\n        _.unset(autoSaveBufferChanges, path);\n      }\n    }\n  }\n\n  addCollectionToSection(collection, section) {\n    let D = this._state.developer;\n    if (!section.forCollection) {\n      D.systemError({message: \"Trying to add a collection in a normal section\"});\n      return;\n    }\n    if (!collection.isSubCollection) {\n      collection.setParentDoc(this);\n    } else if (collection.parentDoc.intentId !== this.intentId) {\n      return D.systemError({message: \"Trying to add a collection with other parentDoc\"});\n    }\n    this.version = 4;\n    collection.sectionId = section.intentId; \n    this._sectionCollections[section.intentId] = collection;\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Doc.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Error.js":
/*!**********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Error.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Error: function() { return /* binding */ Error; }\n/* harmony export */ });\nclass Error {\n  static getErrorMessageforCodeAndLang(errorCode, lang) {\n    let errorsLibrary = {\n      0: {\n        en: 'No error',\n      },\n      1: {\n        en: 'The valid values for RunLocation are Edge and Cloud',\n      },\n      2: {\n        en: 'RunLocation attribute is mandatory',\n      },\n      3: {\n        en: 'The onResolution function is mandatory',\n      },\n      4: {\n        en:\n          'To process your request, I need to reach the cloud and you appear to be offline at this moment. Please try again later',\n      },\n      5: {\n        en: 'Error in edge bot logic with message ',\n      },\n      6: {\n        en: 'NLP.js cannot be called with other data than string',\n      },\n      7: {\n        en: 'Error processing botResolver in backend',\n      },\n      8: {\n        en: 'Error in cloud bot logic with message ',\n      },\n      9: {\n        en: 'The name for the bot name already exists for your domain, please change it and try again',\n      },\n      10: {\n        en: 'An unknown problem has appeared during the bot publication process. Please contact FrontM support.',\n      },\n      11: {\n        en: 'Logic error in onError function',\n      },\n      12: {\n        en: 'Wrong debug command',\n      },\n      13: {\n        en: 'I Cannot run inApp purchases in the cloud',\n      },\n      14: {\n        en: 'Invalid message adding a response',\n      },\n      15: {\n        en:\n          'I have not received the authorisation to activate the notifications. You can request me to activate the notifications in any time.',\n      },\n      16: {\n        en: 'I could not register your device for notifications at this moment. Please try again later',\n      },\n      17: {\n        en:\n          'I could not modify your password. Please be sure that your old password is correct and that you are following the FrontM password policy',\n      },\n      18: {\n        en: 'Capability not available on the cloud',\n      },\n      19: {\n        en: 'I encountered a problem unregistering your device for notifications',\n      },\n      20: {\n        en: 'I could not deregister your device for notifications at this moment. Please try again later',\n      },\n      21: {\n        en: 'Invalid intent object found',\n      },\n      22: {\n        en: 'Ambiguous NLP.js results',\n      },\n      23: {\n        en: 'This method requires an array of Strings',\n      },\n      24: {\n        en: 'Invalid NLP.js Id',\n      },\n      25: {\n        en: 'Invalid backend capability',\n      },\n      26: {\n        en: 'Backend capabilities are not present on edge',\n      },\n      27: {\n        en: 'Error running predictors with message ',\n      },\n      28: {\n        en: 'Bad table action ',\n      },\n      29: {\n        en: 'Bad form action ',\n      },\n      30: {\n        en: 'Action not recognized during video call',\n      },\n      31: {\n        en: 'Error while encrypting data',\n      },\n      32: {\n        en: 'Error while decrypting data',\n      },\n      33: {\n        en: 'Could not send push notification ',\n      },\n      34: {\n        en: 'Ambiguous intent matching. Please review your forms, tables and containers looking for duplicated names',\n      },\n      35: {\n        en: 'Ambiguous intent matching. Please review your intentIds looking for duplicated names or check your matching rules',\n      },\n      36: {\n        en: 'Could not write data in DB',\n      },\n      37: {\n        en: 'Error calling service',\n      },\n      38: {\n        en: 'Unidentified intent or control'\n      },\n      39: {\n        en: 'Bad data from cache in backend'\n      },\n      40: {\n        en: 'The Record you are trying to open is not available offline'\n      },\n      41: {\n        en: 'Invalid coordinates'\n      },\n      42: {\n        en: 'Error synchronising data '\n      },\n      43: {\n        en: 'Error sending a message in backend'\n      },\n      45: {\n        en: 'Error building document'\n      },\n      46: {\n        en: 'Bad field action ',\n      },\n      47: {\n        en: 'Bad container action ',\n      },\n      48: {\n        en: 'Bad map action ',\n      },\n      49: {\n        en: 'Bad geofence action ',\n      },\n      50: {\n        en: 'The data property is too big and it cannot be logged. Message: '\n      },\n      51: {\n        en: 'Duplicated entries in autoSave buffer'\n      },\n      52: {\n        en: 'The autoSave buffer is empty'\n      },\n      53: {\n        en: 'Location not available or with very weak signal'\n      },\n      54: {\n        en: 'Location not available on the cloud'\n      },\n      55: {\n        en: 'SQS Messages can only be sent from the cloud'\n      },\n      56: {\n        en: 'Your system appears to be offline. Please check your internet connection and try again later'\n      },\n      57: {\n        en: 'Field value error'\n      },\n      58: {\n        en: 'Error in video meeting'\n      },\n      59: {\n        en: 'Error in timelines response'\n      },\n      60: {\n        en: 'OpenAI response in error'\n      },\n      999: {\n        en: ''\n      }\n    };\n\n    return errorsLibrary[errorCode][lang];\n  }\n\n  constructor(state, errorCode, errorMessage) {\n    this._errorCode = errorCode;\n    if (errorCode < 1000) {\n      if (errorMessage) {\n        this._errorMessage = Error.getErrorMessageforCodeAndLang(errorCode, state.lang) + ' ' + errorMessage;\n      } else {\n        this._errorMessage = Error.getErrorMessageforCodeAndLang(errorCode, state.lang);\n      }\n    } else {\n      this._errorMessage = errorMessage;\n    }\n  }\n\n  get errorCode() {\n    return this._errorCode;\n  }\n\n  get errorMessage() {\n    return this._errorMessage;\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Error.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Field.js":
/*!**********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Field.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; }\n/* harmony export */ });\n/* harmony import */ var _Intent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n/* harmony import */ var _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FormFieldTypes */ \"../../Bitbucket/frontmjs/core/FormFieldTypes.js\");\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _Error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Error */ \"../../Bitbucket/frontmjs/core/Error.js\");\n\n\n\n\n\nclass Field extends _Intent__WEBPACK_IMPORTED_MODULE_0__.Intent {\n\n  dataType = _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.TYPES.FIELD;\n\n  constructor(intentId, {\n      tabId,\n      doc,\n      primaryKey = false,\n      title,\n      activeIconUrl,\n      inactiveIconUrl,\n      type,\n      mandatory = false,\n      validation = false,\n      readOnly = false,\n      value,\n      options,\n      info,\n      minLength,\n      maxLength,\n      height,\n      maxSelectionOptions,\n      section,\n      column = 0,\n      hidden = false,\n      quickView = true,\n      lookup = false,\n      lookUpCollection,\n      lookUpFilter,\n      valueFromLookUp,\n      lookUpForeignKey,\n      searchKey = false,\n      temp = false,\n      includeInQuickEdit = false,\n      onMessage = self => {\n      },\n      onResponse = self => {\n      },\n      onInit = async self => {\n      },\n      state,\n      onlineStatus = 0, //0, online (no changes in colour), 1 offline on sync and 2 offline out of sync\n      pointType,\n      iconType,\n      routeId,\n      iconColor,\n      iconUrl,\n      fileScope,\n      encrypted = false,\n      dbName\n    }\n  ) {\n    super(intentId, state, tabId);\n    this.onMoveOut = async () => {\n    };\n    this.onClick = async () => {\n    };\n    this.onSearch = async () => {\n    };\n    this.onCompletion = async () => {\n    };\n    this.onInit = onInit;\n    this.onMessage = onMessage;\n    this.onResponse = onResponse;\n    if ((typeof primaryKey !== 'boolean' || !title || !type) && !lookup && type !== _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.COLOR_FIELD) {\n      state.addSystemErrorToStack(7, 'Field title or type missing on field ' + intentId);\n      return\n    }\n    this.title = title;\n    this.type = type;\n    this.primaryKey = primaryKey;\n    this.mandatory = mandatory;\n    this.validation = validation;\n    this.readOnly = readOnly;\n    this._originalValue = value;\n    this.options = options;\n    this.info = info;\n    this.maxLength = maxLength;\n    this.minLength = minLength;\n    this.maxSelectionOptions = maxSelectionOptions;\n    if (section && !section.forCollection) {\n      this.section = section;\n    }\n    this.column = column;\n    this.hidden = hidden;\n    this.temp = temp;\n    this.lookup = lookup;\n    this.onlineStatus = onlineStatus;\n    this._changed = false;\n    this.fileScope = fileScope;\n    this._defaultValue = value;\n    this.quickView = quickView;\n    this.lookUpCollection = lookUpCollection;\n    this.includeInQuickEdit = includeInQuickEdit;\n    this.activeIconUrl = activeIconUrl;\n    this.inactiveIconUrl = inactiveIconUrl;\n    this._encrypted = encrypted;\n    this._height = height;\n    this._dbName = dbName || this.intentId;\n    if (lookUpFilter) {\n      if (Array.isArray(lookUpFilter)) {\n        this.lookUpFilter = lookUpFilter;\n      } else {\n        this.lookUpFilter = [lookUpFilter];\n      }\n    }\n    if (Array.isArray(lookUpForeignKey)) {\n      this.lookUpForeignKey = lookUpForeignKey;\n    } else {\n      this.lookUpForeignKey = [lookUpForeignKey];\n    }\n    this.valueFromLookUp = valueFromLookUp;\n    this.searchKey = searchKey;\n    this._doc = null;\n    this._pointType = pointType;\n    this._iconType = iconType;\n    this._routeId = routeId;\n    this._iconColor = iconColor;\n    this._iconUrl = iconUrl;\n    this.disableHistoryLogging();\n    if (doc) {\n      this.formId = doc.intentId;\n      this._doc = doc;\n      this._index = doc.addField(this);\n    }\n    if (value) this.value = value;\n  }\n\n  resetProperties() {\n    this._value = this._originalValue;\n  }\n\n  cloneField(doc, suffix) {\n    let fieldName = typeof suffix === \"undefined\" ? this.intentId : this.intentId + suffix;\n    let newField = new Field(fieldName, {\n      doc: doc,\n      tabId: this.tabId,\n      primaryKey: this.primaryKey,\n      title: this.title,\n      type: this.type,\n      mandatory: this.mandatory,\n      validation: this.validation,\n      readOnly: this.readOnly,\n      options: this.options,\n      info: this.info,\n      minLength: this.minLength,\n      maxLength: this.maxLength,\n      maxSelectionOptions: this.maxSelectionOptions,\n      section: this.section,\n      fileScope: this.fileScope,\n      column: this.column,\n      hidden: this.hidden,\n      quickView: this.quickView,\n      lookup: this.lookup,\n      lookUpCollection: this.lookUpCollection,\n      lookUpFilter: this.lookUpFilter,\n      valueFromLookUp: this.valueFromLookUp,\n      lookUpForeignKey: this.lookUpForeignKey,\n      searchKey: this.searchKey,\n      temp: this.temp,\n      state: doc._state,\n      onResponse: this.onResponse,\n      onInit: this.onInit,\n      onMessage: this.onMessage,\n      dbName: this.dbName,\n      activeIconUrl: this.activeIconUrl,\n      inactiveIconUrl: this.inactiveIconUrl,\n      routeId: this._routeId,\n      height: this._height\n    });\n    newField._changed = this._changed;\n    return newField\n  }\n\n  message(skipOnResponse, withDefault) {\n    this.runOnResponseLogic(skipOnResponse);\n    let _ = this._state._;\n    let v = this.value;\n    let type = this.type;\n    let fileName = '';\n    if (typeof this.value === 'object' && _ !== null && _.get(this.value, 'fileName')) {\n      v = _.get(this.value, 'value');\n      fileName = _.get(this.value, 'fileName')\n    }\n    if (this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.COORDINATES) {\n      v = `${v[0]}, ${v[1]}`;\n      type = _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.TEXT_FIELD;\n    }\n    return {\n      id: this.intentId,\n      tabId: this.tabId,\n      title: this.title,\n      type: type,\n      info: this.info,\n      mandatory: this.mandatory,\n      validation: this.validation,\n      readOnly: this.readOnly,\n      primaryKey: this.primaryKey,\n      value: withDefault ? this._defaultValue : v,\n      fileName: fileName,\n      maxLength: this.maxLength,\n      minLength: this.minLength,\n      maxSelectionOptions: this.maxSelectionOptions,\n      section: _.get(this.section, 'intentId'),\n      column: this.column,\n      options: this.options,\n      search: this.search,\n      hidden: this.hidden,\n      index: this._index,\n      onlineStatus: this.onlineStatus,\n      pointType: this._pointType,\n      iconType: this._iconType,\n      fileScope: this.fileScope,\n      quickView: this.quickView,\n      activeIconUrl: this.activeIconUrl,\n      inactiveIconUrl: this.inactiveIconUrl,\n      routeId: this._routeId,\n      iconColor: this._iconColor,\n      iconUrl: this._iconUrl,\n      height: this._height\n    };\n  }\n\n  runOnResponseLogic(skipOnResponse) {\n    if (!skipOnResponse) {\n      this.onMessage(this);\n      this.onResponse(this);\n    }\n  }\n\n  shortMessage(skipOnResponse, withDefault) {\n    let _ = this._state._;\n    this.runOnResponseLogic(skipOnResponse);\n    let v = this.value;\n    let type = this.type;\n    let fileName = '';\n    if (typeof this.value === 'object' && _ !== null && _.get(this.value, 'fileName')) {\n      v = _.get(this.value, 'value');\n      fileName = _.get(this.value, 'fileName')\n    }\n    if (this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.COORDINATES) {\n      v = `${v[0]}, ${v[1]}`;\n      type = _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.TEXT_FIELD;\n    }\n    return [\n      this.intentId,\n      this.tabId,\n      this.title,\n      type,\n      this.info,\n      this.mandatory,\n      this.validation,\n      this.readOnly,\n      this.primaryKey,\n      withDefault ? this._defaultValue : v,\n      fileName,\n      this.maxLength,\n      this.minLength,\n      _.get(this.section, 'intentId'),\n      this.column,\n      this.options,\n      this.search,\n      this.hidden,\n      this._index,\n      this.onlineStatus,\n      this._pointType,\n      this._iconType,\n      this.fileScope,\n      this.quickView,\n      this.maxSelectionOptions,\n      this.height\n    ];\n  }\n\n  updateFieldFromMessage(message) {\n    let _ = this._state._;\n    if (message && message.hasOwnProperty(\"id\") && message.id === this.id) {\n      this.tabId = _.get(message, \"tabId\", this.tabId);\n      this.title = _.get(message, \"title\", this.title);\n      this.type = _.get(message, \"type\", this.type); // Check\n      this.info = _.get(message, \"info\", this.info);\n      this.mandatory = _.get(message, \"mandatory\", this.mandatory);\n      this.validation = _.get(message, \"validation\", this.validation);\n      this.readOnly = _.get(message, \"readOnly\", this.readOnly);\n      this.primaryKey = _.get(message, \"primaryKey\", this.primaryKey);\n      this.maxLength = _.get(message, \"maxLength\", this.maxLength);\n      this.minLength = _.get(message, \"minLength\", this.minLength);\n      this.maxSelectionOptions = _.get(message, \"maxSelectionOptions\", this.maxSelectionOptions);\n      this.column = _.get(message, \"column\", this.column);\n      this.options = _.get(message, \"options\", this.options);\n      this.search = _.get(message, \"search\", this.search);\n      this.hidden = _.get(message, \"hidden\", this.hidden);\n      this._index = _.get(message, \"index\", this._index);\n      this.onlineStatus = _.get(message, \"onlineStatus\", this.onlineStatus);\n      this._pointType = _.get(message, \"pointType\", this._pointType);\n      this._iconType = _.get(message, \"iconType\", this._iconType);\n      this.fileScope = _.get(message, \"fileScope\", this.fileScope);\n      this.quickView = _.get(message, \"quickView\", this.quickView);\n      this.height = _.get(message, \"height\", this.height);\n    }\n  }\n\n  get dbName() {\n    return this._dbName;\n  }\n\n  set dbName(dbName) {\n    this._dbName = dbName;\n  }\n\n  get encrypted() {\n    return this._encrypted;\n  }\n\n  get pointType() {\n    return this._pointType\n  }\n\n  set pointType(pointType) {\n    this._pointType = pointType;\n  }\n\n  get iconType() {\n    return this._iconType\n  }\n\n  set iconType(iconType) {\n    this._iconType = iconType;\n  }\n\n  get height() {\n    return this._height\n  }\n\n  set height(height) {\n    this._height = height;\n  }\n\n  get routeId() {\n    return this._routeId\n  }\n\n  set routeId(routeId) {\n    this._routeId = routeId;\n  }\n\n  set doc(doc) {\n    this.formId = doc.formId;\n    this._doc = doc;\n    this._index = doc.addField(this);\n  }\n\n  get doc() {\n    return this._doc;\n  }\n\n  get value() {\n    let _ = this._state._;\n    if (!_.isArray(this._value) && typeof this._value === 'object' && _.size(this._value) === 0) {\n      //Nothing to do\n    } else {\n      return this._value;\n    }\n  }\n\n  get tempValue() {\n    return this.getAutoSavedValue();\n  }\n\n  getAutoSavePath(tabId, parentDocId) {\n    let state = this._state;\n    let _ = state._;\n    try {\n      let docPath = this.doc.getAutoSavePath(tabId, parentDocId);\n      if (docPath) {\n        return `${docPath}.${this.id}`;\n      }\n    } catch (error) {\n      state.addSystemErrorToStack(999, 'Error in field getAutoSavePath', this.id)\n    }\n  }\n\n  setAutoSaveFieldValue(value) {\n    let state = this._state;\n    if (this.doc.autoSave && this.doc.docId) {\n      let _ = state._;\n      let path = this.getAutoSavePath();\n      if (!path) return\n      if (value || value === 0) {\n        _.set(this.doc._state.autoSaveBuffer, path, value);\n      } else {\n        if (_.get(this.doc._state.autoSaveBuffer, path)) {\n          _.unset(this.doc._state.autoSaveBuffer, path)\n        }\n      }\n      if (!this.doc._state.duringBuild) {\n        _.set(this.doc._state.autoSaveBufferChanges, path, true);\n      }\n    }\n  }\n\n  getAutoSavedValue(tabId, parentDocId) {\n    let state = this.doc._state;\n    if (this.doc.autoSave) {\n      let _ = state._;\n      let path = this.getAutoSavePath(tabId, parentDocId);\n      if (path) {\n        let v = _.get(this.doc._state.autoSaveBuffer, path);\n        return _.get(this.doc._state.autoSaveBuffer, path);\n      }\n    }\n  }\n\n  getAutoSavedValueChanged(tabId, parentDocId) {\n    let state = this.doc._state;\n    if (this.doc.autoSave) {\n      let _ = state._;\n      let path = this.getAutoSavePath(tabId, parentDocId);\n      if (path) {\n        return _.get(this.doc._state.autoSaveBufferChanges, path);\n      }\n    }\n  }\n\n  clearAutoSavedValue() {\n    this.setAutoSaveFieldValue()\n  }\n\n  setValueFromAutoSave(tabId, parentDocId) {\n    let _ = this._state._;\n    let autoSavedValue = this.getAutoSavedValue(tabId, parentDocId);\n    this.value = _.isNil(autoSavedValue) ? this.value : autoSavedValue;\n  }\n\n  set value(value) {\n    if (!this._state.stateInitialized) {\n      this._state.initializationErrorMessages.push(`Values cannot be initialized outside a function. Default value ignored. Field ${this.intentId}`);\n      return\n    }\n    if (!this._doc) {\n      return\n    }\n    let _ = this._state._;\n    if (this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.COORDINATES && !Array.isArray(value)) {\n      this._state.addSystemErrorToStack(41)\n    }\n    if (!Array.isArray(value) && typeof value === 'object' && _.size(value) === 0) return;\n    let v = value;\n    if (typeof v === 'string' && (this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.DATE || this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.DATETIME)) {\n      // v = new Date(value).getTime();\n      if (v.substring(0, 5) === '#date') {\n        v = parseInt(v.substring(6, 19));\n      } else {\n        v = parseInt(v);\n      }\n    }\n    if (this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.LOOKUP && typeof v === 'object' && _.size(v) > 1) {\n      v = _.get(v, 'text')\n    }\n    if (this.type !== _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.COLOR_FIELD) {\n      if (v !== this.tempValue) {\n        this._change = true;\n      }\n      this.setAutoSaveFieldValue(v);\n      if (!this.temp) {\n        this._doc._document[this._intentId] = v;\n        this._doc._dbDocument[this.dbName || this._intentId] = v;\n      }\n    }\n    this._doc._documentForShortResponse[this._intentId] = v;\n    this._value = v;\n  }\n\n  get id() {\n    return this.intentId;\n  }\n\n  get onMatching() {\n    return state => {\n      let _ = state._;\n      let inputControlId = state.messageFromUser.controlId || state.messageFromUser.formId;\n      return (this.doc &&\n        (state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.RESPONSES.FORM_RESPONSE || state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.RESPONSES.TABLE_RESPONSE || state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.RESPONSES.CONTAINER_RESPONSE) &&\n        state.messageFromUser.currentField === this.id &&\n        (inputControlId === this.formId || inputControlId === this.doc._filteredCollectionName || inputControlId === this.doc._collection)\n      );\n    };\n  }\n\n  autoSaveLogic(state, currentFieldValue) {\n    if (!this._doc) {\n      return\n    }\n    let _ = this._state._;\n    let D = this._state.developer;\n    if (this._doc.autoSave) {\n      if (typeof currentFieldValue !== 'undefined' && currentFieldValue !== null) {\n        if (typeof currentFieldValue === 'object' && _.size(currentFieldValue) > 0 && this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.LOOKUP && this.lookUpCollection) {\n          this.value = _.get(currentFieldValue, 'text');\n          let lookupArray = state.getField(_ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.PREFIXES.FIELD_LOOKUP_PREFIX + this.id);\n          let index = _.findIndex(lookupArray, entry => {\n            return _.get(entry, 'info') === _.get(currentFieldValue, 'info');\n          });\n          if (index > -1) {\n            let lookUpRecord = _.get(lookupArray[index], 'doc');\n            let changedFields = [];\n            _.forEach(this._doc.fields, field => {\n              if (field.valueFromLookUp) {\n                _.forEach(lookUpRecord, (value, key) => {\n                  if (key === field.valueFromLookUp) {\n                    field.value = lookUpRecord[key];\n                    changedFields.push(field.message(true));\n                  }\n                });\n              }\n            });\n            if (changedFields.length > 0) {\n              if (state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.RESPONSES.TABLE_RESPONSE) {\n                state.addInLineFormChangeResponse(this._doc.message(_ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.CHANGE, changedFields, null, true, true));\n              } else {\n                state.addFormChangeResponse(this._doc.message(_ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.CHANGE, changedFields, null, null, true));\n              }\n            }\n          }\n        } else {\n          if (currentFieldValue === '' || _.get(currentFieldValue, 'text') === '') {\n            this.clearAutoSavedValue();\n          } else {\n            this.value = currentFieldValue;\n          }\n          state.storeAutoSaveBuffer();\n        }\n      }\n    }\n  }\n\n  async lookupLogic(state) {\n    if (!this._doc) {\n      return\n    }\n    let _ = state._;\n    //{\"formId\":\"caseDoc\",\"action\":\"search\",\"currentField\":\"casePatient\",\"currentFieldValue\":\"aaaaaaa\"}\n    let currentFieldValue = _.get(state.messageFromUser, 'currentFieldValue', _.get(state.messageFromUser, 'content.currentFieldValue'));\n    //let currentField = state._.get(state.messageFromUser, 'currentField');\n    if (currentFieldValue !== '' && this.lookUpCollection) {\n      let query = {};\n      let and = [];\n      if (this.lookUpFilter) {\n        let i = 0;\n        _.forEach(this.lookUpFilter, filter => {\n          let filterValue = filter.tempValue;\n          if (filterValue !== null) {\n            let fieldQuery = {};\n            fieldQuery[this.lookUpForeignKey[i]] = filterValue;\n            and.push(fieldQuery);\n          }\n          i++\n        });\n      }\n      let or = {};\n      let orArray = [];\n      this.lookUpCollection.document.fields.forEach(field => {\n        let fieldQuery = {};\n        if (field.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.NUMBER_FIELD) {\n          fieldQuery[field.id] = field.value;\n        } else {\n          let regexSearch = {};\n          regexSearch['$regex'] = `^(.*?)${currentFieldValue}`;\n          regexSearch['$options'] = `i`;\n          fieldQuery[field.id] = regexSearch;\n        }\n        orArray.push(fieldQuery);\n      });\n      or['$or'] = orArray;\n      and.push(or);\n      query['$and'] = and;\n      let rows = await this.lookUpCollection.loadCollectionWithQuery({ query });\n      let resultsArray = [];\n      let queryResults = [];\n      _.forEach(this.lookUpCollection.rows, doc => {\n        let text = this.valueFromLookUp ? doc.document[this.valueFromLookUp] : doc.getPrimaryKeyAsStringForSearch(doc.getPrimaryKey());\n        let info = doc.getPrimaryKeyAsStringForSearch(doc.getNonPrimaryKey());\n        let newResultEntry = {\n          text,\n          info: info !== \"\" ? info : null\n        }\n        // D.log({message: 'Result entry', data: newResultEntry});\n        resultsArray.push(newResultEntry);\n        let resultsToStore = _.cloneDeep(newResultEntry);\n        resultsToStore.doc = doc.document;\n        queryResults.push(resultsToStore);\n      });\n      if (_.get(this.doc, '_state.messageTypeFromUser') === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.RESPONSES.TABLE_RESPONSE) {\n        let results = this._doc.message(_ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.RESULTS, {\n          field: this.id,\n          results: resultsArray\n        }, null, true, true);\n        state.addInLineFormChangeResponse(results);\n      } else {\n        let results = this._doc.message(_ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.RESULTS, {\n          field: this.id,\n          results: resultsArray\n        }, null, null, true);\n        state.addFormChangeResponse(results);\n      }\n      state.setField(_ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.PREFIXES.FIELD_LOOKUP_PREFIX + this.id, queryResults);\n    }\n  }\n\n  get onResolution() {\n    return async state => {\n      let _ = state._;\n      let D = state.developer;\n      let currentFieldValue = _.get(state.messageFromUser, 'currentFieldValue', _.get(state.messageFromUser, 'content.currentFieldValue'));\n      let currentFileValue = _.get(state.messageFromUser, 'fileName', _.get(state.messageFromUser, 'content.fileName'));\n      if (currentFileValue) {\n        currentFieldValue = {\n          value: currentFieldValue,\n          fileName: currentFileValue\n        }\n      }\n      if (this._doc && this._doc._parent && this._doc._parent._intentId === state.currentControlId) {\n        state.currentControlId = this._doc._parent._intentId;\n      } else {\n        state.currentControlId = this._doc.intentId;\n      }\n      let docId = _.get(state.messageFromUser, 'docId');\n      if (docId) {\n        let tabId = _.get(state.messageFromUser, 'tabId');\n        let parentDocId = _.get(state.messageFromUser, 'parentDocId');\n        this.doc.loadDocFromAutoSaveBuffer(tabId, docId, parentDocId);\n      }\n      if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.MOVE) {\n        //console.log('Inside on resolution for ' + this.id);\n        state.messageFromUser.oldFieldValue = this.tempValue;\n        if (this.validation || currentFieldValue !== state.messageFromUser.oldFieldValue || this.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_1__.FormFieldTypes.RADIOBUTTON) {\n          if (currentFieldValue !== state.messageFromUser.oldFieldValue) {  \n            this.autoSaveLogic(state, currentFieldValue);\n          }\n          await this.onMoveOut();\n        }\n      } else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.CLICK) {\n        this.autoSaveLogic(state, currentFieldValue);\n        await this.onClick();\n      } else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.SEARCH) {\n        this.autoSaveLogic(state, currentFieldValue);\n        await this.lookupLogic(state);\n        await this.onSearch();\n      } else if (state.messageFromUser.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.COMPLETION) {\n        this.autoSaveLogic(state, currentFieldValue);\n        await this.onCompletion();\n      } else state.addSystemErrorToStack(46, _Error__WEBPACK_IMPORTED_MODULE_3__.Error.getErrorMessageforCodeAndLang(46));\n      state.developer.debug({ message: 'About to leave onResolution' });\n      if (state.responsesArray.length === 0) {\n        state.addSilentResponse();\n      }\n    }\n  }\n\n  set onResponse(onResponse) {\n    this._onResponse = onResponse;\n  }\n\n  get onResponse() {\n    return this._onResponse;\n  }\n\n  sendValidationResponse({\n    result = true,\n    message\n  }) {\n    let response = {\n      field: this.id,\n      validationResult: result,\n      validationMessage: message\n    }\n    this._state.addFormChangeResponse(\n      this.doc.message(_ALLConstants__WEBPACK_IMPORTED_MODULE_2__.ALL_CONSTANTS.ACTIONS.VALIDATION, response)\n    )\n  }\n\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Field.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/File.js":
/*!*********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/File.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   File: function() { return /* binding */ File; }\n/* harmony export */ });\n/* harmony import */ var _FormFieldTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FormFieldTypes */ \"../../Bitbucket/frontmjs/core/FormFieldTypes.js\");\n\nclass File {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n    let capabilities = state.context.capabilities.capabilities;\n    let context = null;\n    if (capabilities) {\n      context = state.context.capabilities;\n    } else {\n      context = state.context;\n    }\n    this['_context'] = context;\n  }\n\n  read() {\n    let s3Params = {\n      Bucket: envConfig.BOT_LOGO_BUCKET,\n      CopySource: conversationBucket + '/' + conversationId + '/' + fileName,\n      Key: botName.replace(/[^A-Z0-9]+/gi, '_') + '_' + botId + '.' + fileExtension,\n      ACL: 'public-read',\n    };\n    return s3.copyObject(s3Params).promise();\n  }\n\n  async createQRCode(qrText, qrImageName) {\n    if (!qrText) {\n      throw new Error('qrText is required');\n    }\n\n    if (!qrImageName) {\n      qrImageName = `${this._state.getUniqueId()}.png`;\n    }\n\n    try {\n      let { QRCode, config, env, aws } = this._context;\n      let s3 = new aws.S3();\n\n      let qrString = QRCode.toDataURL(qrText);\n      let base64Data = Buffer.from(qrString.replace(/^data:image\\/\\w+;base64,/, \"\"), 'base64');\n      let bucket = config[env].CONVERSATIONS_BUCKET;\n      let conversationId = this._state.conversationId;\n      let params = {\n        Bucket: bucket,\n        Key: `${conversationId}/${qrImageName}`,\n        Body: base64Data,\n        ContentType: 'image/png',\n        ContentEncoding: 'base64',\n      };\n      this._state.developer.log({ message: 'createQRCode', data: { bucket, conversationId, qrImageName } });\n      await s3.upload(params).promise();\n      return qrImageName;\n\n    } catch (err) {\n      throw new Error('Error while creating QR Code' + err.message);\n    }\n  }\n\n  // options has the following schema\n  // headers - Array of strings of field names, collection - name of the collection, limit - number of entried you want in your csv file\n  // withAutoDownload = true will add a header for auto download when accessing the file with a url\n  async generateCsvFileFromMongo(query, options, conversationId, fileName, withAutoDownload) {\n    if (options && options.headers && options.headerTitles && options.collection && fileName && conversationId) {\n      let startTime = Date.now();\n      let { stream, config, env, frontmlib, aws, moment } = this._context;\n      const { headers, headerTitles, collection, limit, sort, projection, skip } = options;\n      let stringCSV = \"\";\n      let headerString = headerTitles.join(',') + '\\n';\n      this._botState.developer.log({\n        message: 'generateCsvFileFromMongo: Header String Logging',\n        data: { headerString }\n      });\n      stringCSV = stringCSV + headerString;\n      let finalProjection = {};\n      headers.map(h => {\n        finalProjection[h] = 1\n      })\n      collection.document.cache = false;\n      await collection.loadCollectionWithQuery({\n        query: query || {},\n        projection: finalProjection,\n        sort: sort || {},\n        skip: skip || 0,\n        limit: limit || 100,\n        collation: {}\n      })\n      if (collection.rows.length > 0) {\n        let s3 = new aws.S3();\n        const moment = this._botState.moment;\n        let finalArr = collection.rows.map(row => {\n          return headers.map(h => {\n            let value;\n            for (const field of row.fields) {\n              if (field.id === h || field.dbName === h) {\n                if (field.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_0__.FormFieldTypes.DATETIME || field.type === _FormFieldTypes__WEBPACK_IMPORTED_MODULE_0__.FormFieldTypes.DATE) {\n                  let dateValue = new Date(field.value);\n                  value = !isNaN(dateValue) ? moment(dateValue).format('YYYY/MM/DD hh:mm:ss Z') : \" \";\n                } else if (typeof field.value !== \"string\" && typeof field.value !== \"undefined\")\n                  value = field.value.toString()\n                else\n                  value = field.value\n              }\n            }\n            return value || '\" \"'\n          })\n        })\n        let final = finalArr.map(e => e.join(\",\")).join(\"\\n\");\n        stringCSV = stringCSV + final;\n        this._botState.developer.log({\n          message: 'generateCsvFileFromMongo: final csv string before upload',\n          data: { stringCSV }\n        });\n        fileName = fileName || `mongoUpload${this._botState.UUID()}.csv`;\n        let bucket = config[env].CONVERSATIONS_BUCKET;\n        let params = { Bucket: bucket, Key: `${conversationId}/${fileName}`, Body: stringCSV };\n        if (withAutoDownload) {\n          params.ContentDisposition = `attachment;filename=\"${fileName}\"`;\n          params.ACL = 'public-read';\n        }\n        try {\n          let dataSaved = await s3.upload(params).promise();\n          this._botState.developer.log({\n            message: 'generateCsvFileFromMongo: Successfully Uploaded to S3',\n            data: { datafromUpload: dataSaved }\n          });\n          return dataSaved;\n        } catch (err) {\n          this._botState.developer.log({\n            message: 'generateCsvFileFromMongo: Error Uploading to S3',\n            data: { err }\n          });\n          return { error: err };\n        }\n      } else {\n        this._botState.developer.log({ message: 'generateCsvFileFromMongo: No Data from MongoDb' });\n      }\n    } else {\n      this._botState.developer.log({ message: 'generateCsvFileFromMongo: Validation failed' });\n    }\n  }\n\n  async generateCsvFileFromDynamo(query, options, conversationId, fileName) {\n    // todo: add error handling for input params\n    let startTime = Date.now();\n    //let {stream, config, env, frontmlib, aws, moment} = this._context.capabilities;\n    let { stream, config, env, frontmlib, aws, moment } = this._context;\n    let s3 = new aws.S3();\n\n    let { headers, specialFields } = options;\n    let specialFieldNames = Object.keys(options.specialFields || {});\n    let defaultsObj = this._(headers)\n      .mapKeys()\n      .mapValues(function () {\n        return '';\n      })\n      .value();\n\n    const inStream = new stream.Readable({\n      read() {\n      },\n    });\n    let bucket = config[env].CONVERSATIONS_BUCKET;\n    let params = { Bucket: bucket, Key: `${conversationId}/${fileName}`, Body: inStream };\n    this._state.developer.log({ message: 'generateCsvFileFromDynamo', data: { bucket, conversationId, fileName } });\n\n    let uploadPromise = new Promise(async (resolve, reject) => {\n      s3.upload(params, function (err, data) {\n        if (err !== null) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n      let headerString = '\"' + headers.join('\",\"') + '\"\\n';\n      inStream.push(headerString);\n      this._state.developer.log({ message: 'generateCsvFileFromDynamo: Wrote header to the csv file' });\n      do {\n        let { Items, LastEvaluatedKey } = await frontmlib.dbGetWithPagination(\n          query.TableName,\n          query.IndexName,\n          query.KeyConditionExpression,\n          query.FilterExpression,\n          query.ExpressionAttributeValues,\n          query.ExclusiveStartKey || null,\n          query.Fields,\n          query.options\n        );\n        this._state.developer.log({\n          message: 'generateCsvFileFromDynamo: got items from dynamo',\n          data: { size: this._.size(Items), LastEvaluatedKey }\n        });\n        this._.map(Items, obj => {\n          let newObjWithHeaders = this._({})\n            .assign(defaultsObj, this._.pick(obj, headers))\n            .value();\n          if (specialFieldNames) {\n            this._.forEach(specialFieldNames, headerName => {\n              let headerProcessor = specialFields[headerName];\n              let fieldValue = newObjWithHeaders[headerName];\n              if (!this._.isNumber(fieldValue) && this._.isEmpty(fieldValue)) {\n                return true;\n              }\n              switch (headerProcessor.type) {\n                case 'dateTime':\n                  newObjWithHeaders[headerName] = moment(this._.toNumber(fieldValue)).format(\n                    headerProcessor.format || 'DD/MMMM/YYYY hh:mm a'\n                  );\n                  break;\n              }\n            });\n          }\n          let line = this._(newObjWithHeaders)\n            .values()\n            .join('\",\"');\n          inStream.push(`\"${line}\"\\n`);\n        });\n\n        if (!LastEvaluatedKey || _.size(Items) === 0) {\n          break;\n        }\n        query.ExclusiveStartKey = LastEvaluatedKey;\n      } while (query.ExclusiveStartKey !== null);\n\n      inStream.push(null);\n      inStream.on('end', () => {\n        let totalTime = Date.now() - startTime;\n        this._state.developer.log({\n          message: 'generateCsvFileFromDynamo: totalTime to create csv in generateCsvFileFromDynamo:',\n          data: { totalTime }\n        });\n      });\n      inStream.on('error', data => {\n        this._state.developer.log({ message: 'generateCsvFileFromDynamo: Stream erred', data: data });\n        reject(data);\n      });\n    });\n\n    try {\n      let response = await uploadPromise;\n      this._state.developer.log({ message: 'generateCsvFileFromDynamo: final response:', data: response });\n      return response;\n    } catch (err) {\n\n    }\n  }\n\n  async compressVideo(bucket, filename) {\n    let params = {\n      'Records': [\n        {\n          's3': {\n            'bucket': {\n              'name': bucket\n            },\n            'object': {\n              'key': filename\n            }\n          }\n        }\n      ]\n    };\n    return this._state.callLambda('videoConverterLambda', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n  async validateGeoJSON(bucket, fileName) {\n    let params = {\n      bucket,\n      fileName\n    };\n    return this._state.callLambda('geoJSONValidationLambda', params, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      })\n      .catch(error => {\n        console.log(\"26. adding system error\");\n        this._state.addSystemErrorToStack(7, error.message);\n      });\n  }\n\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/File.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/FormFieldTypes.js":
/*!*******************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/FormFieldTypes.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FormFieldTypes: function() { return /* binding */ FormFieldTypes; }\n/* harmony export */ });\nclass FormFieldTypes {\n  static TEXT_FIELD = 'text_field';\n  static NUMBER_FIELD = 'number';\n  static TEXT_AREA = 'text_area';\n  static RICH_TEXT_AREA = 'rich_text_area';\n  static CHECKBOX = 'checkbox';\n  static RADIOBUTTON = 'radiobutton';\n  static DROPDOWN = 'dropdown';\n  static SWITCH = 'switch';\n  static SLIDER = 'slider';\n  static DATE = 'date';\n  static DATETIME = 'datetime';\n  static TIME = 'time';\n  static MULTI_SELECTION = 'multi_selection';\n  static PASSWORD_FIELD = 'password_field';\n  static LOOKUP = 'lookup';\n  static IMAGE_FIELD = 'image_field';\n  static VIDEO_FIELD = 'video_field';\n  static FILE_FIELD = 'file_field';\n  static BUTTONS_FIELD = 'buttons_field';\n  static CHAT_FIELD = 'chat_field';\n  static VIDEO_CALL_FIELD = 'video_call_field';\n  static VOICE_CALL_FIELD = 'voice_call_field';\n  static ROW_MENU_FIELD = 'row_menu_field';\n  static COLOR_FIELD = 'color_field';\n  static ALERT_FIELD = 'alert_field';\n  static COORDINATES = 'coordinates_field';\n  static GEO_POINT_FIELD = 'geo_point_field';\n  static GEO_AREA_FIELD = 'geo_area_field';\n  static OBJECT_DROPDOWN = 'object_dropdown';\n  static OBJECT_LOOKUP = 'object_lookup';\n  static OBJECT_MULTI_SELECTION = 'object_multi_selection';\n  static MAP_AREA = 'map_area';\n  static MAP_DATA = 'map_data';\n  static PHONE_NUMBER_FIELD = 'phone_number';\n  static EMAIL_FIELD = 'email_field';\n  static COLOR_PICKER_FIELD = 'color_picker';\n  static ICON_FIELD = 'icon_field';\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/FormFieldTypes.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Geofence.js":
/*!*************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Geofence.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Geofence: function() { return /* binding */ Geofence; }\n/* harmony export */ });\n/* harmony import */ var _Intent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n/* harmony import */ var _Error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Error */ \"../../Bitbucket/frontmjs/core/Error.js\");\n\n\n\nclass Geofence extends _Intent__WEBPACK_IMPORTED_MODULE_0__.Intent {\n  static GEOFENCE_MESSAGE() {\n    return 'geofence';\n  }\n\n  static GEOFENCE_RESPONSE() {\n    return 'geofence_response';\n  }\n\n  static SAVE_ACTION() {\n    return 'save';\n  }\n\n  static NEW_ACTION() {\n    return 'new';\n  }\n\n  static UPDATE_ACTION() {\n    return 'update';\n  }\n\n  static DISPLAY_ACTION() {\n    return 'display';\n  }\n\n  static DELETE_ACTION() {\n    return 'delete';\n  }\n\n  constructor(intentId, { tabId, id, name, description, color, coordinates, state }) {\n    super(intentId, state, tabId);\n    this.onSave = async () => {\n    };\n    this.onDelete = async () => {\n    };\n    this._id = id;\n    this._name = name;\n    this._description = description;\n    this._color = color;\n    this._coordinates = coordinates;\n  }\n\n  message(action) {\n    return {\n      options: {\n        controlId: this.intentId,\n        tabId: this.tabId,\n        id: this._id, //Mandatory\n        name: this._name,\n        description: this._description,\n        color: this._color,\n        action,\n      },\n      coordinates: this._coordinates,\n    };\n  }\n\n  get onMatching() {\n    return state => {\n      return (\n        state.messageTypeFromUser === Geofence.GEOFENCE_RESPONSE() && state.messageFromUser.controlId === this.intentId\n      );\n    };\n  }\n\n  get onResolution() {\n    return async state => {\n      state.currentControlId = this.intentId;\n      if (state.messageFromUser.action === Geofence.SAVE_ACTION()) await this.onSave();\n      else if (state.messageFromUser.action === Geofence.DELETE_ACTION()) await this.onDelete();\n      else state.addSystemErrorToStack(49, _Error__WEBPACK_IMPORTED_MODULE_1__.Error.getErrorMessageforCodeAndLang(49));\n      if (state.responsesArray.length === 0) {\n        state.addSilentResponse();\n      }\n    };\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Geofence.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/InputQueue.js":
/*!***************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/InputQueue.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass InputQueue {\n    #queue;\n    constructor() {\n        this.#queue = [];\n    }\n\n    isEmpty() {\n        return this.#queue.length === 0;\n    }\n\n    addMessage(message, action) {\n        if (!message || !action) {\n            return false;\n        }\n        this.#queue.push({ message, action });\n    }\n\n    pollMessage() {\n        if (this.isEmpty()) {\n            return false;\n        }\n        return this.#queue.shift();\n    }\n    \n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (InputQueue);\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/InputQueue.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Intent.js":
/*!***********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Intent.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Intent: function() { return /* binding */ Intent; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n\n\nclass Intent {\n  static SPEECH() {\n    return 'speech';\n  }\n\n  static LOCATION() {\n    return '__location_';\n  }\n\n  static CONTACT() {\n    return '__contact_';\n  }\n\n  static IMAGE() {\n    return '__image_';\n  }\n\n  static VIDEO() {\n    return '__video_';\n  }\n\n  static FILE() {\n    return '__file_';\n  }\n\n  constructor(intentId, state, tabId) {\n    this['_intentId'] = intentId;\n    this['_runLocation'] = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE;\n    this['_edgeEvents'] = [];\n    this['_cloudEvents'] = [];\n    this['_presentEvent'] = '';\n    this['_nlpId'] = '';\n    this['_smartSuggestions'] = [];\n    this['_dependencies'] = [];\n    this['_logHistory'] = true;\n    this['_silentIntent'] = false;\n    this._onPrediction = () => {};\n    this.tabId = tabId || intentId;\n    this.onInit = async self => {};\n    if (state) {\n      this._state = state;\n      this._state.setIntentWithId(intentId, this);\n    }\n  }\n  resetProperties () {\n  }\n\n  runOnCloud() {\n    this._runLocation = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD;\n  }\n\n  runOnCloudWithEdgeEvents(events) {\n    if (events && Array.isArray(events) && events.length > 0) {\n      this._edgeEvents = events;\n    }\n    this._runLocation = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD;\n  }\n\n  runOnEdge() {\n    this._runLocation = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE;\n  }\n\n  runOnEdgeWithCloudEvents(events) {\n    if (events && Array.isArray(events) && events.length > 0) {\n      this._cloudEvents = events;\n    }\n    this._runLocation = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE;\n  }\n\n  disableHistoryLogging() {\n    this._logHistory = false;\n  }\n\n  silenceIntent() {\n    this._silentIntent = true;\n  }\n\n  get silentIntent() {\n    return this._silentIntent;\n  }\n\n  get logHistory() {\n    return this._logHistory;\n  }\n\n  get runLocation() {\n    if (this._edgeEvents.indexOf(this._presentEvent) > -1) {\n      return _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE;\n    }\n    if (this._cloudEvents.indexOf(this._presentEvent) > -1) {\n      return _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE;\n    }\n    return this._runLocation;\n  }\n\n  get onValidation() {\n    return this._onValidation;\n  }\n\n  set onValidation(onValidationBlock) {\n    this._onValidation = onValidationBlock;\n  }\n\n  get onError() {\n    return this._onError;\n  }\n\n  set onError(onErrorBlock) {\n    this._onError = onErrorBlock;\n  }\n\n  get id() {\n    return this._intentId\n  }\n\n  get intentId() {\n    return this._intentId;\n  }\n\n  set nlpId(nlpId) {\n    this._nlpId = nlpId;\n  }\n\n  get nlpId() {\n    return this._nlpId;\n  }\n\n  get suggestionsArray() {\n    return this._smartSuggestions;\n  }\n\n  set suggestionsArray(suggestions) {\n    this._smartSuggestions = suggestions;\n  }\n\n  setEnglishSmartSuggestions(suggestions) {\n    if (Array.isArray(suggestions)) {\n      this._smartSuggestions = [\n        {\n          lang: 'en',\n          list: suggestions.reverse(),\n        },\n      ];\n    } else {\n      this._state.developer.warning({message: \"The suggestions argument must be an array\", data: this._intentId})\n    }\n  }\n\n  setEnglishSmartSuggestionsWithCondition(defaultSuggestions, newSuggestions, conditionBlock) {\n    if (Array.isArray(newSuggestions) && Array.isArray(defaultSuggestions)) {\n      if (conditionBlock()) {\n        this._smartSuggestions = [\n          {\n            lang: 'en',\n            list: newSuggestions.reverse(),\n          },\n        ];\n      } else {\n        this._smartSuggestions = [\n          {\n            lang: 'en',\n            list: defaultSuggestions.reverse(),\n          },\n        ];\n      }\n    } else {\n      this._smartSuggestions = [\n        {\n          lang: 'en',\n          list: ['Invalid smart suggestion type. Must be array'],\n        },\n      ];\n    }\n  }\n\n  setSmartSuggestions(lang, suggestions) {\n    this._smartSuggestions = [\n      {\n        lang: lang,\n        list: suggestions,\n      },\n    ];\n  }\n\n  matchSuggestions() {\n    if (typeof this._state.messageFromUser === 'string') {\n      let findSuggestion = suggestion => {\n        let list = suggestion.list;\n        return list.includes(this._state.messageFromUser);\n      };\n      return !!this._smartSuggestions.find(findSuggestion);\n    }\n    return false;\n  }\n\n  get onMatching() {\n    return this._onMatching;\n  }\n\n  set onMatching(matcher) {\n    this._onMatching = matcher;\n  }\n\n  get onResolution() {\n    return this['_onResolution'];\n  }\n\n  set onResolution(resolver) {\n    this['_onResolution'] = resolver;\n  }\n\n  get onPrediction() {\n    return this['_onPrediction'];\n  }\n\n  set onPrediction(predictor) {\n    this['_onPrediction'] = predictor;\n  }\n\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Intent.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/JobScheduler.js":
/*!*****************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/JobScheduler.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JobScheduler: function() { return /* binding */ JobScheduler; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _MessageTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MessageTypes */ \"../../Bitbucket/frontmjs/core/MessageTypes.js\");\n\n\n\nclass JobScheduler {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n  }\n\n  addNewJob(client, params, jobId, repeats) {\n    let scheduleJobParams = {\n      jobId: jobId,\n      capability: 'ScheduleBatchJob',\n      conversation: this._state.conversation,\n      params: this._state.cleanFieldsForSave(params),\n      repeats: repeats,\n      requestUuid: this._state.getUniqueId(),\n      scheduledCapability: this._state.conversation.bot + '_CustomCap',\n      userEmail: this._state.user.userEmail,\n      userId: this._state.user.userId,\n      userDomain: this._state.conversation.userDomain,\n      botId: this._state.conversation.bot,\n      client: client,\n      schedule: this._.get(params, 'schedule'),\n    };\n    return this._state.callLambda('SystemCapabilities', scheduleJobParams, 'RequestResponse').then(response => {\n      return JSON.parse(response.Payload);\n    });\n  }\n\n  scheduleMessage(\n    {\n      toBot = this._state.conversation.bot,\n      toUser,\n      messages,\n      jobId = this._state.getUniqueId(),\n      schedule = Date.now(),\n      repeats,\n      client = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT,\n      realTimeMessage = true,\n      v1Compatibility = false\n    }) {\n\n    let requestUuid = this._state.getUniqueId();\n\n    let generateFullMessageForMessage = msg => {\n      let messageToSend = msg;\n      if (!realTimeMessage) {\n        let state = toBot === this._state.botId ? this._state.stateToBackEnd() : { state: {} };\n        state.state.messageFromUser = msg;\n        state.state.messageTypeFromUser = 'object';\n        state.state.fromGreeting = false;\n        state.state.responsesArray = [];\n        state.state._syncToCloud = {};\n        state.state._syncToEdge = {};\n        // state.state._delayedNotification = [];\n        state.state._activeIntent = '';\n        //D.log({message: 'Setting v1Compatibility'});\n        if (!realTimeMessage && v1Compatibility) {\n          //v1Compatibility generates simple responses in case of bot to bot messages\n          state.state.v1Compatibility = true;\n        }\n        messageToSend = state;\n      }\n      //D.log({message: 'Bot to bot message content', data: messageToSend});\n      return {\n        content: [messageToSend],\n        contentType: _MessageTypes__WEBPACK_IMPORTED_MODULE_1__.MessageTypes.BOT_TO_BOT(),\n        requestUuid: requestUuid,\n        createdBy: this._state.user.userId,\n        createdOn: Date.now(),\n        messageId: this._state.getUniqueId(),\n      }\n    }\n\n    let _ = this._state._;\n    let allMessages = [];\n    if (Array.isArray(messages)) {\n      _.forEach(messages, msg => {\n        allMessages.push(generateFullMessageForMessage(msg))\n      })\n    } else {\n      allMessages.push(generateFullMessageForMessage(messages))\n    }\n\n    let params = {\n      target: {\n        bot: toBot,\n        users: Array.isArray(toUser) ? toUser : toUser ? [toUser] : toUser,\n        userDomain: this._state.currentUserDomain\n      },\n      action: 'get',\n      bot: this._state.conversation.bot || _.get(this._state.context, 'botManifest.botId'),\n      sync: true,\n      userDomain: this._state.conversation.userDomain,\n      email: this._state.user.userEmail,\n      conversation: this._state.conversation,\n      requestUuid,\n      messages: allMessages,\n      realTimeMessage\n    }\n    let scheduleJobParams = {\n      jobId,\n      capability: 'ScheduleBatchJob',\n      conversation: this._state.conversation,\n      params,\n      repeats,\n      requestUuid,\n      scheduledCapability: 'BroadCastMessageCapability',\n      userEmail: this._state.user.userEmail,\n      userId: this._state.user.userId,\n      userDomain: this._state.conversation.userDomain,\n      botId: this._state.conversation.bot,\n      client: client,\n      schedule\n    };\n    return this._state.callLambda('SystemCapabilities', scheduleJobParams, 'RequestResponse')\n      .then(response => {\n        return JSON.parse(response.Payload);\n      });\n  }\n\n  deleteJob(jobId) {\n    let scheduleJobParams = {\n      jobId: jobId,\n      capability: 'DeleteBatchJob',\n    };\n    return this._state.callLambda('SystemCapabilities', scheduleJobParams, 'RequestResponse')\n  }\n\n  scheduleLocalJob(jobId, interval) {\n    let bgTaskOptions = {\n      key: jobId,\n      botId: this._state.context.botManifest.botId,\n      timeInterval: interval,\n      conversationId: this._state.conversationId,\n    };\n    let backgroundTaskQueue = this._state.context.getCapability('BackgroundTaskQueue');\n    return backgroundTaskQueue.enqueue(bgTaskOptions);\n  }\n\n  stopLocalJob(jobId) {\n    let backgroundTaskQueue = this._state.context.getCapability('BackgroundTaskQueue');\n    let bgTaskOptions = {\n      key: jobId,\n      botId: this._state.context.botManifest.botId,\n      conversationId: this._state.conversationId,\n    };\n    return backgroundTaskQueue.dequeue(bgTaskOptions);\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/JobScheduler.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/LocationServices.js":
/*!*********************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/LocationServices.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocationServices: function() { return /* binding */ LocationServices; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _MessageTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MessageTypes */ \"../../Bitbucket/frontmjs/core/MessageTypes.js\");\n\n\n\nclass LocationServices {\n  static START_TRACKING() {\n    return 'startTracking';\n  }\n\n  static STOP_TRACKING() {\n    return 'stopTracking';\n  }\n\n  static VESSEL() {\n    return 'vessel';\n  }\n\n  static FLIGHT() {\n    return 'flight';\n  }\n\n  static TRACKER_BOT() {\n    return 'tracker-bot';\n  }\n\n  constructor(state) {\n    this._state = state;\n    this._ = state._;\n    let capabilities = state.context.capabilities.capabilities;\n    if (capabilities) {\n      this._turf = state.context.capabilities.turf;\n    } else {\n      this._turf = state.context.turf;\n    }\n    // this._turf = state.context.turf;\n    this.offlineMaps = {};\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT && this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n      this.offlineMaps = this._state.context.getCapability('OfflineMap');\n    }\n  }\n\n  getDeviceLocation() {\n    if (this._state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n      return this._state.context.getCapability('DeviceLocation').getDeviceLocation()\n        .catch(error => {\n          //come back\n          this._state.addSystemErrorToStack(53, null, error);\n        })\n    } else {\n      this._state.addSystemErrorToStack(54);\n      return Promise.resolve();\n    }\n  }\n\n  async getLocationWithQuery(query) {\n    try {\n      let stringQuery = query\n      if (typeof stringQuery !== 'string') {\n        stringQuery = JSON.stringify(query)\n      }\n      let response = await this._state.api.callService(\n        'Geocode',\n        { queryParams: 'q=' + stringQuery }\n      )\n\n      if (!response) {\n        return []\n      }\n      return JSON.parse(response)\n    } catch (err) {\n      this._state.developer.log({ message: 'Getting error while calling Geocode: ' + err.message });\n      return {\n        error: 'err',\n      };\n    }\n  }\n\n  startLocationTracking(precision = 5, heartbeatInterval = 180) {\n    return this._state.context.getCapability('LocationTracker').start_tracking(\n      {\n        botId: this._state.context.botManifest.botId,\n        conversationId: this._state.conversationId,\n      },\n      precision,\n      heartbeatInterval\n    );\n  }\n\n  stopLocationTracking() {\n    return this._state.context.getCapability('LocationTracker').stop_tracking({\n      botId: this._state.context.botManifest.botId,\n      conversationId: this._state.conversationId,\n    });\n  }\n\n  async saveMap({\n      name,\n      neBound,\n      swBound,\n      minZoom = 12,\n      maxZoom = 16,\n      progressListener = this.progressListener,\n      errorListener = this.errorListener\n    }\n  ) {\n    let state = this._state;\n    let D = state.developer;\n    if (state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      try {\n        if (state.maps[name]) {\n          await this.deleteMap(name)\n        }\n        state.maps[name] = true;\n        await this.offlineMaps.saveMap(\n          name,\n          neBound,\n          swBound,\n          minZoom,\n          maxZoom,\n          (\n            completedResourceCount,\n            completedResourceSize,\n            completedTileCount,\n            completedTileSize,\n            name,\n            percentage,\n            requiredResourceCount,\n            state\n          ) => {\n            D.log({ message: \"Progress being made downloading map\", data: percentage });\n          },\n          (\n            offLinePack,\n            error\n          ) => {\n            D.log({ message: \"Error downloading map\", data: error });\n          }\n        );\n      } catch (err) {\n        D.log({ message: \"Error downloading map\", data: err });\n      }\n    } else {\n      D.warning({ message: \"Maps cannot be downloaded on web app for now\" })\n    }\n  }\n\n  async deleteMap(name) {\n    await this.offlineMaps.deleteMap(name);\n    delete this._state.maps[name];\n  }\n\n  async startTracking(assetType, assetDetails, schedule, intentId) {\n    let trackingSessionId = this._state.getUniqueId();\n    let messageToTracker = {\n      intentId: LocationServices.START_TRACKING(),\n      jobId: trackingSessionId,\n      assetType: assetType,\n      assetDetails: assetDetails,\n    };\n    if (schedule) {\n      messageToTracker.repeats = schedule;\n    }\n    if (intentId) {\n      messageToTracker.respondsTo = {\n        userId: this._state.user.userId,\n        botId: this._state.conversation.bot,\n        userDomain: this._state.conversation.userDomain,\n        intentId: intentId,\n      };\n    }\n    await this._state.notification.sendBroadcastNotificationToBot(\n      LocationServices.TRACKER_BOT(),\n      this._state.conversation.userDomain,\n      _MessageTypes__WEBPACK_IMPORTED_MODULE_1__.MessageTypes.BOT_TO_BOT(),\n      messageToTracker\n    );\n    return trackingSessionId;\n  }\n\n  startTrackingVessel(assetDetails, schedule, intentId) {\n    return this.startTracking(LocationServices.VESSEL(), assetDetails, schedule, intentId);\n  }\n\n  startTrackingFlight(assetDetails, schedule, intentId) {\n    return this.startTracking(LocationServices.FLIGHT(), assetDetails, schedule, intentId);\n  }\n\n  stopTracking(trackingSessionId) {\n  }\n\n  getLatestKnownLocation(asset, trackingSessionId, tableName) {\n    let params = {\n      capability: 'AssetTrackerCapability',\n      capabilityFileName: 'assetTrackerCapability',\n      action: 'getLatestAssetLocation',\n      assetId: asset,\n      sessionId: trackingSessionId,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n    };\n    if (tableName) {\n      params['tableName'] = tableName;\n    }\n    return this._state.callCapability(params);\n  }\n\n  getLocation(asset, trackingSessionId, from, to, tableName) {\n    let params = {\n      capability: 'AssetTrackerCapability',\n      capabilityFileName: 'assetTrackerCapability',\n      action: 'getAssetLocationForDuration',\n      assetId: asset,\n      sessionId: trackingSessionId,\n      from: from,\n      to: to,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n    };\n    if (tableName) {\n      params['tableName'] = tableName;\n    }\n    return this._state.callCapability(params);\n  }\n\n  getLocationWithPagination(asset, trackingSessionId, pageSize = 50, last, tableName) {\n    let params = {\n      capability: 'AssetTrackerCapability',\n      capabilityFileName: 'assetTrackerCapability',\n      action: 'getAssetLocationsWithPagination',\n      assetId: asset,\n      sessionId: trackingSessionId,\n      pageSize,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n    };\n    if (last) {\n      params.last = last;\n    }\n    if (tableName) {\n      params['tableName'] = tableName;\n    }\n    return this._state.callCapability(params);\n  }\n\n  storeNewLocation(trackingSessionId, assetId, assetDetails, createdOn, tableName) {\n    let params = {\n      capability: 'AssetTrackerCapability',\n      capabilityFileName: 'assetTrackerCapability',\n      action: 'addNewLocation',\n      assetId: assetId,\n      sessionId: trackingSessionId,\n      details: assetDetails,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n    };\n    if (createdOn) {\n      params.createdOn = createdOn;\n    }\n    if (tableName) {\n      params['tableName'] = tableName;\n    }\n    return this._state.callCapability(params);\n  }\n\n  async getWeatherOnLocation(latitude, longitude) {\n    const location = `${latitude},${longitude}`;\n    const WEATHER_SERVICE = 'MaritimeWeather';\n    try {\n      let response = this._state.api.callService(WEATHER_SERVICE, { queryParams: 'q=' + location });\n      return response;\n    } catch (err) {\n      d.log({ message: 'Getting error while calling WEATHER_SERVICE ' + JSON.stringify(err) });\n      return {\n        error: err,\n      };\n    }\n  }\n\n  getPolygonsThatContainsLocation(location, polygonList) {\n    let foundPolygons = [];\n    let turfPoint = this._turf.point(location);\n    try {\n      this._.forEach(polygonList, poly => {\n        let polygon = this._turf.polygon(poly.coordinates);\n        if (this._turf.booleanPointInPolygon(turfPoint, polygon)) {\n          foundPolygons.push(poly);\n        }\n      });\n      return foundPolygons;\n    } catch (err) {\n      throw err;\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/LocationServices.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/LogEntrytype.js":
/*!*****************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/LogEntrytype.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogEntrytype: function() { return /* binding */ LogEntrytype; }\n/* harmony export */ });\nclass LogEntrytype {\n  static SYSTEM_ERROR() {\n    return 'SYSTEM_ERROR';\n  }\n\n  static USER_ERROR() {\n    return 'USER_ERROR';\n  }\n\n  static WARNING() {\n    return 'WARNING';\n  }\n\n  static INFO() {\n    return 'INFO';\n  }\n\n  static DEBUG() {\n    return 'DEBUG';\n  }\n\n  static LOG() {\n    return 'LOG';\n  }\n\n  static PERF() {\n    return 'PERF';\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/LogEntrytype.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Marketplace.js":
/*!****************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Marketplace.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Marketplace: function() { return /* binding */ Marketplace; }\n/* harmony export */ });\nclass Marketplace {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n  }\n\n  validateActivationCode(code, userId, userEmail) {\n    let params = {\n      capability: 'SubscribeDomainRole',\n      capabilityFileName: 'subscribeDomainRole',\n      verificationCode: code,\n      sync: true,\n      userId: userId || this._state.user.userId,\n      userEmail: userEmail || this._state.user.userEmail,\n      conversation: this._state.conversation,\n    };\n    return this._state.callCapability(params);\n  }\n\n  activateDomainsOnEdge(domains) {\n    return this._state.context.getCapability('authContext').setDomains(domains, this._state.context);\n  }\n\n  autoInstallAllBotsOnEdge() {\n    return this._state.context.getCapability('RemoteBotInstall').syncronizeBots();\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Marketplace.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/MessageTypes.js":
/*!*****************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/MessageTypes.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageTypes: function() { return /* binding */ MessageTypes; }\n/* harmony export */ });\nclass MessageTypes {\n  static MESSAGE_TYPE_STRING() {\n    return 10;\n  }\n\n  static MESSAGE_TYPE_IMAGE() {\n    return 30;\n  }\n\n  static MESSAGE_TYPE_VIDEO() {\n    return 40;\n  }\n\n  static MESSAGE_TYPE_AUDIO() {\n    return 60;\n  }\n\n  static MESSAGE_TYPE_HTML() {\n    return 140;\n  }\n\n  static BACKEND_RESPONSE() {\n    return 150;\n  }\n\n  static BOT_TO_BOT() {\n    return 160;\n  }\n\n  static SOCKET_RECONNECTION() {\n    return 170;\n  }\n\n  static MESSAGE_TYPE_LIST() {\n    return 200;\n  }\n\n  static MESSAGE_TYPE_SLIDER() {\n    return 210;\n  }\n\n  static MESSAGE_TYPE_BUTTON() {\n    return 220;\n  }\n\n  static MESSAGE_TYPE_FORM() {\n    return 230;\n  }\n\n  static MESSAGE_TYPE_MAP() {\n    return 240;\n  }\n\n  static MESSAGE_TYPE_SMART_SUGGESTIONS() {\n    return 250;\n  }\n\n  static MESSAGE_TYPE_WEB_CARD() {\n    return 260;\n  }\n\n  static MESSAGE_TYPE_STD_NOTIFICATION() {\n    return 270;\n  }\n\n  static MESSAGE_TYPE_CRITICAL_NOTIFICATION() {\n    return 280;\n  }\n\n  static MESSAGE_TYPE_LOCATION() {\n    return 290;\n  }\n\n  static MESSAGE_TYPE_PDF() {\n    return 300;\n  }\n\n  static MESSAGE_TYPE_TEXT() {\n    return 320;\n  }\n\n  static MESSAGE_TYPE_OTHER_FILE() {\n    return 330;\n  }\n\n  static MESSAGE_TYPE_CSV() {\n    return 340;\n  }\n\n  static MESSAGE_TYPE_JAVASCRIPT() {\n    return 350;\n  }\n\n  static MESSAGE_TYPE_FORM2() {\n    return 400;\n  }\n\n  static MESSAGE_TYPE_MENU() {\n    return 410;\n  }\n\n  static MESSAGE_TYPE_TABLE() {\n    return 420;\n  }\n\n  static MESSAGE_TYPE_CONTACT_CARD() {\n    return 430;\n  }\n\n  static MESSAGE_TYPE_DATA_CARD() {\n    return 440;\n  }\n\n  static MESSAGE_TYPE_FORM_RESPONSE() {\n    return 450;\n  }\n\n  static MESSAGE_TYPE_STRIPE() {\n    return 460;\n  }\n\n  static MESSAGE_TYPE_STRIPE_RESPONSE() {\n    return 470;\n  }\n\n  static MESSAGE_TYPE_CLOSE_FORM() {\n    return 480;\n  }\n\n  static MESSAGE_TYPE_MAP_RESPONSE() {\n    return 490;\n  }\n\n  static MESSAGE_TYPE_SEARCH_BOX() {\n    return 510;\n  }\n\n  static MESSAGE_TYPE_SEARCH_BOX_RESPONSE() {\n    return 520;\n  }\n\n  static MESSAGE_TYPE_CARDS() {\n    return 530;\n  }\n\n  static MESSAGE_TYPE_CARD_ACTION() {\n    return 540;\n  }\n\n  static MESSAGE_RUN_MODE() {\n    return 550;\n  }\n\n  static SHORT_TABLE_RESPONSE() {\n    return 1000;\n  }\n\n  static SHORT_CONTAINER_RESPONSE() {\n    return 1100;\n  }\n\n  static MESSAGE_VOICE_CALL() {\n    return 1200;\n  }\n\n  static SHORT_FORM_RESPONSE() {\n    return 1300;\n  }\n\n  static MESSAGE_TYPE_TIMELINE_LIST() {\n    return 2000;\n  }\n\n  static MESSAGE_TYPE_TIMELINE_POST() {\n    return 2100;\n  }\n\n  static MESSAGE_TYPE_SURVEY() {\n    return 3000;\n  }\n\n  static MESSAGE_TYPE_SURVEY_RESPONSE() {\n    return 3001;\n  }\n\n  static DASHBOARD() {\n    return 5000;\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/MessageTypes.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/NLP.js":
/*!********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/NLP.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NLP: function() { return /* binding */ NLP; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _MessageTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MessageTypes */ \"../../Bitbucket/frontmjs/core/MessageTypes.js\");\n\n\n\nclass NLP {\n  static OPEN_AI() {\n    return 'openAI';\n  }\n\n  static DEFAULT_ASSISTANT_NAME() {\n    return 'AI';\n  }\n\n  static CONVERSATION_CONTEXT_FIELD() {\n    return \"_conversationContextField\"\n  }\n\n  constructor(state) {\n    this['_state'] = state;\n    this._nlpEngine = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.NLP.ENGINES.OPEN_AI;\n    this._nlpAlias = '';\n    this._assistantName = state.systemId || NLP.DEFAULT_ASSISTANT_NAME();\n    this._nlpIds = [this._assistantName]; //For backward compatibility\n    this._automaticSuggestions = true;\n  }\n\n  getKeyForPrompt() {\n    return `${_ALLConstants__WEBPACK_IMPORTED_MODULE_0__.PREFIXES.LLM_CONTEXT}${this._state.conversationId}_${this._assistantName}`;\n  }\n\n  async clearConversationContext() {\n    await this._state.db.deleteOneKeyInCache(this.getKeyForPrompt());\n  }\n\n  set assistantName(name) {\n    this._assistantName = name;\n  }\n\n  get assistantName() {\n    return this._assistantName;\n  }\n\n  set nlpEngine(nlpEngine) {\n    this._nlpEngine = nlpEngine;\n  }\n\n  get nlpEngine() {\n    return this._nlpEngine;\n  }\n\n  get nlpIds() {\n    return this._nlpIds;\n  }\n\n  set automaticSuggestions(automaticSuggestions) {\n    this._automaticSuggestions = automaticSuggestions;\n  }\n\n  get automaticSuggestions() {\n    return this._automaticSuggestions;\n  }\n\n  addNlp(nlpId) {\n    let _ = this._state._;\n    let index = _.findIndex(this.nlpIds, existingId => {\n      return existingId === nlpId\n    });\n    if (index === -1) {\n      this._nlpIds.push(nlpId);\n    }\n  }\n\n  get nlpAlias() {\n    return this._nlpAlias;\n  }\n\n  set nlpAlias(nlpAlias) {\n    this._nlpAlias = nlpAlias;\n  }\n\n  getNlpParameters(nlpParameters) {\n    return nlpParameters;\n    let parsedParameters = {};\n    let fields = nlpParameters.fields;\n    let _ = this._state._;\n    let processFields = field => {\n      switch (fields[field].kind) {\n        case 'stringValue': {\n          parsedParameters[field] = fields[field].stringValue;\n          break;\n        }\n        case 'numberValue': {\n          parsedParameters[field] = fields[field].numberValue;\n          break;\n        }\n        case 'structValue': {\n          parsedParameters[field] = this.getNlpParameters(fields[field].structValue);\n          break;\n        }\n        case 'listValue': {\n          let listFromNLP = _.get(fields[field], 'listValue.values');\n          let listToBot = [];\n          _.each(listFromNLP, value => {\n            if (_.get(value, 'structValue')) {\n              listToBot.push(this.getNlpParameters(_.get(value, 'structValue')));\n            } else {\n              listToBot.push(_.get(value, 'stringValue') || _.get(value, 'numberValue') || 'unknownType');\n            }\n          });\n          parsedParameters[field] = listToBot;\n          break;\n        }\n        default:\n          break;\n      }\n    };\n    this._state.R.forEach(processFields, this._state.R.keys(fields));\n    return parsedParameters;\n  }\n\n  runNlpForMessage(message) {\n    let state = this._state;\n    let D = state.developer;\n    let _ = state._;\n    let R = state.R;\n    let nlpBotsList = this.nlpIds;\n    D.info({ message: 'Starting NLP.js event', data: nlpBotsList });\n    if (this.nlpEngine === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.NLP.ENGINES.DIALOGFLOW) {\n      if (nlpBotsList.length > 0) {\n        let params = {\n          capability: 'NLP2',\n          capabilityFileName: 'nlpv2',\n          queryString: message,\n          nlpIds: nlpBotsList,\n          sync: true,\n          userId: state.user.userId,\n          conversation: state.conversation,\n        };\n        return state.callCapability(params).then(dataArray => {\n          let startNLP = Date.now();\n          _.each(dataArray, nlpResponse => {\n            D.info({ message: 'Response from NLP.js', data: nlpResponse });\n            if (nlpResponse.error === 'Invalid NLP.js ID') {\n              state.addSystemErrorToStack(24, nlpResponse.nlpId);\n              return;\n            }\n            let nlpParameters = '';\n            let action = nlpResponse.action;\n            let nlpId = nlpResponse.nlpId;\n            D.info({ message: 'Found NLP.js action: ', data: action });\n            if (nlpResponse.parameters && _.size(nlpResponse.parameters) > 0) {\n              nlpParameters = nlpResponse.parameters;\n              D.info({ message: 'Found NLP.js parameters: ', data: nlpParameters });\n            }\n            let suggestions = [];\n            if (nlpResponse.messages) {\n              _.forEach(nlpResponse.messages, entry => {\n                if (entry.type === 4) {\n                  if (entry.payload.messages) {\n                    state.addSmartSuggestionsArray([\n                      {\n                        lang: state.lang,\n                        list: entry.payload.messages,\n                      },\n                    ]);\n                    suggestions = entry.payload.messages;\n                  }\n                }\n              });\n            }\n            state.nlpResults[nlpId] = {\n              speech: '',\n            };\n            if (nlpResponse.speech && nlpResponse.speech !== '') {\n              state.nlpResults[nlpId].speech = nlpResponse.speech;\n            }\n            state.nlpResults[nlpId].action = action;\n            state.nlpResults[nlpId].nlpParameters = this.getNlpParameters(nlpParameters);\n            state.nlpResults[nlpId].nlpSuggestions = suggestions;\n          });\n          D.logCurrentEventDurationWithStartTime('nlpAnalysis', startNLP, Date.now());\n        })\n      } else {\n        D.warning({ message: 'No NLP.js Engine added to the bot' });\n      }\n    }\n    return [];\n  }\n\n  async addContextPromptsToChat(currentPrompt) {\n    let D = this._state.developer;\n    let context = [];\n    context.push({\n      role: \"system\",\n      content: `The name of the user talking with you is ${this._state.user.userName}. Today is ${new Date().toLocaleDateString()} and the current time is ${new Date().toLocaleTimeString()}. The user is running a micro-app called ${this._state.botName} with description and purpose of ${this._state.botDescription}.`\n    });\n\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      context.push({\n        role: \"system\",\n        content: `The user talking to you is connected from a mobile phone using a mobile app called onship. When you give instructions take that in consideration`\n      });\n      if (this._state.platform !== \"\") {\n        context.push({\n          role: \"system\",\n          content: `The mobile platform that the user is using is ${this._state.platform}`\n        });\n      }\n      if (this._state.osVersion !== \"\") {\n        context.push({\n          role: \"system\",\n          content: `The mobile operating system version that the user is using is ${this._state.osVersion}`\n        });\n      }\n      if (this._state.phoneModel !== \"\") {\n        context.push({\n          role: \"system\",\n          content: `The mobile phone model that the user is using is ${this._state.phoneModel}`\n        });\n      }\n      if (this._state.brand !== \"\") {\n        context.push({\n          role: \"system\",\n          content: `The mobile phone brand that the user is using is ${this._state.brand}`\n        });\n      }\n    } else {\n      let webBrowserCommonPrompt = await this._state.getSystemStaticData(_ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.NLP.FIELDS.WEB_BROWSER_COMMON_PROMPT);\n      D.debug({ message: \"webBrowserCommonPrompt\", data: webBrowserCommonPrompt });\n      if (webBrowserCommonPrompt && Array.isArray(webBrowserCommonPrompt)) {\n        context = context.concat(webBrowserCommonPrompt);\n      }\n    }\n    context = context.concat(currentPrompt);\n    return context\n  }\n\n  extractObjectFromMessage(message) {\n    try {\n      const startIndex = message.indexOf('{'); // Find the starting index of the JSON object\n      const endIndex = message.lastIndexOf('}'); // Find the ending index of the JSON object\n      const jsonObjectString = message.substring(startIndex, endIndex + 1); // Extract the JSON object as a string\n      // Parse the JSON object\n      return JSON.parse(jsonObjectString)\n    } catch (error) {\n      return false\n    }\n  }\n\n  formatMarkdownAsHTML(message) {\n    let D = this._state.developer;\n    let state = this._state;\n    if (state.marked) {\n      // Create a renderer\n      let renderer = new state.marked.Renderer();\n\n      renderer.link = function (href, title, text) {\n        let link = state.marked.Renderer.prototype.link.call(this, href, title, text);\n        return link.replace(\"<a\", \"<a target='_blank' rel='noopener noreferrer'\");\n      };\n      state.marked.setOptions({ renderer: renderer })\n      return state.marked.parse(message);\n    } else {\n      D.warning({ message: \"Marked is not present\" });\n    }\n    return message\n  }\n\n  getAPIKeyFromParameters(param) {\n    const NO_SERVICE = \"NO_SERVICE\";\n    if (param) {\n      if (Array.isArray(param)) {\n        let index = Math.floor(Math.random() * param.length);\n        return param[index] || NO_SERVICE\n      } else if (typeof param === \"string\") {\n        return param\n      }\n    }\n    return NO_SERVICE\n  }\n\n  async callOpenAIWithMessageFromUser({\n    service = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.LLM_SERVICE.CHAT,\n    userPrompt,\n    role = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.OPEN_AI_ROLES.USER\n  }) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    D.debug({ message: \"Assistant Name\", data: this._assistantName });\n    if (typeof this._state.messageFromUser === \"string\" || userPrompt || this._state.messageFromUser?.intentId === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS) {\n      let defaultNLPKey = service === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.LLM_SERVICE.CHAT ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.NLP.FIELDS.DEFAULT_CHAT_NLP_KEY : _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.NLP.FIELDS.DEFAULT_NLP_KEY;\n      let defaultPromptKey = service === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.LLM_SERVICE.CHAT ? _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.NLP.FIELDS.DEFAULT_CHAT_PROMPT_KEY : _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.NLP.FIELDS.DEFAULT_PROMPT_KEY;\n      let history = [];\n      let promptName = this._assistantName !== NLP.DEFAULT_ASSISTANT_NAME() ? `${this._assistantName.toLowerCase()}Prompt` : defaultPromptKey;\n      let prompt = await this._state.getStaticData(promptName, null, true) || await this._state.getSystemStaticData(defaultPromptKey) || [];\n\n      let nlpName = this._assistantName !== NLP.DEFAULT_ASSISTANT_NAME() ? `${this._assistantName.toLowerCase()}NLP` : defaultNLPKey;\n      let nlpParameters = await this._state.getStaticData(nlpName, null, true) || await this._state.getSystemStaticData(defaultNLPKey) || {};\n\n      if (service === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.LLM_SERVICE.CHAT) {\n        let newContent = {};\n        if (this._state.messageFromUser?.intentId === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS) {\n          newContent = {\n            role: _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.OPEN_AI_ROLES.SYSTEM,\n            content: \"Generate 3 relevant follow up questions for the content above, impersonating the user, with each question in less than 8 words and in JSON object with the questions within an array identified as \\\"q\\\"\"\n          }\n          this._state.addActiveIntent(_ALLConstants__WEBPACK_IMPORTED_MODULE_0__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS);\n        } else {\n          newContent = {\n            role,\n            content: userPrompt || this._state.messageFromUser\n          }\n        }\n        history = await this._state.db.getObjectFromCache(this.getKeyForPrompt()) || [];\n        D.debug({ message: \"Context\", data: history });\n        if (typeof history === \"string\") {\n          history = [];\n        }\n        prompt = await this.addContextPromptsToChat(prompt);\n        if (this._state.messageFromUser?.intentId !== _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS) {\n          history.push(newContent);\n          prompt = prompt.concat(history);\n        } else {\n          prompt = prompt.concat(newContent);\n        }\n      } else {\n        if (typeof prompt === \"string\") {\n          prompt = prompt.concat(userPrompt);\n        }\n      }\n\n      let options = {\n        body: {\n          model: nlpParameters.model,\n          messages: prompt,\n          temperature: nlpParameters.temperature,\n          max_tokens: nlpParameters.max_tokens,\n          top_p: nlpParameters.top_p,\n          frequency_penalty: nlpParameters.frequency_penalty,\n          presence_penalty: nlpParameters.presence_penalty,\n          stop: nlpParameters.stop,\n          user: this._state.user.userId\n        }\n      }\n      D.debug({ message: \"Call to openAI\", data: options });\n      let response = await this._state.api.callService(this.getAPIKeyFromParameters(nlpParameters?.apiServiceNames), options);\n      D.debug({ message: \"Response from openAI\", data: response });\n      const DEFAULT_MESSAGE = \"We are not able to process your message at this time, please try again later\";\n      let openAIContent = response?.choices[0]?.message?.content;\n      let text = \"\";\n      let openAICallPassed = true;\n      if (typeof openAIContent === \"string\") {\n        text = openAIContent\n        text = text.replace(\"OnShip\", \"onship\");\n        text = text.replace(\"Onship\", \"onship\");\n        text = text.trim();\n      } else {\n        openAICallPassed = false;\n        text = DEFAULT_MESSAGE;\n        this._state.addSystemErrorToStack(60, null, response);\n        this._state.clearError();\n        if (this._state.messageFromUser?.intentId === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS) {\n          return\n        }\n      }\n      if (this._state.messageFromUser?.intentId !== _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS) {\n        if (service === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.LLM_SERVICE.CHAT) {\n          if (text === DEFAULT_MESSAGE) {\n            history.pop()\n          } else {\n            history.push({\n              role: _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.OPEN_AI_ROLES.SYSTEM,\n              content: text\n            });\n          }\n          const DEFAULT_MAX_CONTEXT_LENGTH = 20;\n          let maxSize = nlpParameters?.maxContextLength ? nlpParameters.maxContextLength : DEFAULT_MAX_CONTEXT_LENGTH;\n          if (history.length > maxSize) {\n            history.splice(0, history.length - maxSize);\n          }\n          await this._state.db.setOneValueInCache(this.getKeyForPrompt(), history);\n        }\n      }\n      let object = this.extractObjectFromMessage(text);\n      if (object === false) {\n        if (this._automaticSuggestions && this._state.platform !== \"android\") {\n          if (openAICallPassed) {\n            await this._state.notification.sendMessageToUserInBot(\n              _MessageTypes__WEBPACK_IMPORTED_MODULE_1__.MessageTypes.BOT_TO_BOT(),\n              {\n                intentId: _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS\n              },\n              [this._state.user.userId],\n              this._state.botId,\n              this._state.currentUserDomain,\n              false,\n              null,\n              false\n            )\n          }\n        }\n        return this.formatMarkdownAsHTML(text)\n      } else {\n        return object\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/NLP.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Notification.js":
/*!*****************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Notification.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Notification: function() { return /* binding */ Notification; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n\n\nclass Notification {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      this['notification'] = this._state.context.getCapability('Notification');\n    }\n  }\n\n  sendEmail(to, title, body, attachments, from, cc) {\n    let params = {\n      capability: 'SendEmailCustomCapability',\n      capabilityFileName: 'email',\n      address: to,\n      cc,\n      fromEmail: from,\n      htmlBody: body,\n      title: title,\n      sync: true,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n      attachments: [],\n    };\n    let allAttachments = [];\n    if (attachments) {\n      this._.each(attachments, attachment => {\n        let a = {\n          fileContentName: attachment.name,\n        };\n        if (attachment.type === 'csv' || attachment.type === 'string') {\n          a.stringContent = attachment.content;\n        } else {\n          a.jsonContent = attachment.content;\n        }\n        allAttachments.push(a);\n      });\n      params.attachments = allAttachments;\n    }\n    return this._state.callCapability(params);\n  }\n\n  sendIMMessage() {\n    //console.log('Sending IM message');\n    let messageToSend = {\n      messageId: this._state.messageIdFromUser,\n      contentType: this._state.messageTypeIntFromUser,\n      createdOn: this._state.messageCreatedOnFromUser,\n      createdBy: this._state.user.userId, //this._state.messageCreatedByFromUser,\n      content: this._state.messageContentFromUser,\n      options: this._state.messageOptionsFromUser,\n    };\n    //console.log(JSON.stringify(messageToSend));\n    let params = {\n      capability: 'SendIMMessage',\n      capabilityFileName: 'sendIMMessage',\n      sync: true,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n      messages: [messageToSend],\n      isNewConversation: false,\n    };\n    return this._state.callCapability(params);\n  }\n\n  async sendVoipPushNotificationToUserDevices(\n    userDevices,\n    sns,\n    conversationId,\n    message,\n    data\n  ) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let createVoipMsg = function (conversationId) {\n      let apsMsg = {\n        aps: {\n          alert: message,\n          data: {\n            videoSessionId: _.get(data, 'videoSessionId'),\n            botId: _.get(data, 'botId'),\n            userDomain: _.get(data, 'userDomain'),\n            userId: _.get(data, 'userId'),\n            videoControlId: _.get(data, 'videoControlId'),\n            video: _.get(data, 'video'),\n            mediasoupHost: _.get(data, 'mediasoupHost'),\n            codec: _.get(data, 'codec'),\n            iAmHost: _.get(data, 'iAmHost'),\n            startWithVideoMuted: _.get(data, 'startWithVideoMuted'),\n            preConnectCallCheck: _.get(data, 'preConnectCallCheck'),\n            uid: _.get(data, 'uid'),\n            ur: _.get(data, 'ur'),\n            callAction: _.get(data, 'callAction'),\n            conversationId,\n            roomName: _.get(data, 'roomName'),\n            brand: _.get(data, 'brand')\n          },\n          sound: _.get(data, 'soundName', 'default')\n        }\n      };\n\n      let gcmMsg = {\n        data: {\n          message: message,\n          conversationId,\n          videoSessionId: _.get(data, 'videoSessionId'),\n          botId: _.get(data, 'botId'),\n          userDomain: _.get(data, 'userDomain'),\n          userId: _.get(data, 'userId'),\n          videoControlId: _.get(data, 'videoControlId'),\n          video: _.get(data, 'video'),\n          mediasoupHost: _.get(data, 'mediasoupHost'),\n          iAmHost: _.get(data, 'iAmHost'),\n          startWithVideoMuted: _.get(data, 'startWithVideoMuted'),\n          preConnectCallCheck: _.get(data, 'preConnectCallCheck'),\n          uid: _.get(data, 'uid'),\n          ur: _.get(data, 'ur'),\n          callAction: _.get(data, 'callAction'),\n          codec: _.get(data, 'codec'),\n          soundName: _.get(data, 'soundName'),\n          roomName: _.get(data, 'roomName'),\n          brand: _.get(data, 'brand')\n        },\n        time_to_live: 10,\n        priority: 'high'\n      };\n\n      let snsMsg = {\n        default: message,\n        GCM: JSON.stringify(gcmMsg),\n        APNS_VOIP: JSON.stringify(apsMsg),\n        APNS_VOIP_SANDBOX: JSON.stringify(apsMsg)\n      };\n\n      return JSON.stringify(snsMsg);\n    };\n\n    let callVoipMessage = function (conversationId, sns, message, arn) {\n      let snsParams = {\n        Message: createVoipMsg(conversationId, message),\n        MessageStructure: 'json',\n        MessageAttributes: {\n          'AWS.SNS.MOBILE.APNS.TTL': {\n            DataType: 'String',\n            StringValue: '10'\n          },\n          'AWS.SNS.MOBILE.APNS.PRIORITY': {\n            DataType: 'String',\n            StringValue: '10'\n          },\n          'AWS.SNS.MOBILE.APNS.PUSH_TYPE': {\n            DataType: 'String',\n            StringValue: 'voip'\n          }\n        },\n        TargetArn: arn\n      };\n      return sns.publish(snsParams).promise();\n    };\n\n    _.forEach(userDevices, (arn) => {\n      callVoipMessage(conversationId, sns, message, arn)\n        .then(() => {\n          this._state.developer.info({\n            message: 'Push notification sent with no error'\n          });\n        })\n        .catch((err) => {\n          this._state.developer.warning({\n            message: 'Could not send push notification to a device',\n            data: JSON.stringify(err)\n          });\n          //console.log('Push notification error');\n          return (\n            'error occurred while sending notification to :' + arn\n          );\n        });\n    });\n  }\n\n  async sendVoipCallPushNotifications(conversations, message, data, onlyAndroid, onlyIOS, ignoreTimeDelay) {\n    let state = this._state;\n    let R = state.R;\n    let _ = state._;\n    let D = state.developer;\n\n    let sns = new this._state.aws.SNS({ apiVersion: '2010-03-31' });\n    let devices = [];\n    let notificationsTargets = {};\n    let keys = []\n    for (let i = 0; i < conversations.length; i++) {\n      let conversation = conversations[i];\n      //_.forEach(conversations, (conversation) => {\n      let participants = _.get(conversation, 'participants') || [];\n      for (let j = 0; j < participants.length; j++) {\n        let participant = participants[j];\n        //_.forEach(_.get(conversation, 'participants'), (participant) => {\n        if (participant !== _.get(conversation, 'bot')) {\n          let notificationKey = `PUSH_NOTIFICATION_KEY_${participant}`;\n          let previousNotificationTime = await this._state.getSharedField(notificationKey)\n          if ((Date.now() - _.get(previousNotificationTime, 'timeStamp', 0)) > 10000 || ignoreTimeDelay) { //If a notification was sent less than 10 seconds before, for the participant, we block the next one\n            await this._state.setSharedField(notificationKey, {\n                timeStamp: Date.now()\n              },\n              10); //Redis entry expires within 10 seconds\n            let key = `People_${participant}`;\n            keys.push(key);\n            notificationsTargets[key] = {\n              conversationId: conversation.conversationId\n            };\n          }\n        }\n      }\n    }\n    if (_.isEmpty(notificationsTargets)) {\n      return\n    }\n    let people = await this._state.db.getMultipleValuesFromCache(keys);\n    let allDevices = [];\n    let webPushAppType = await this._state.getStaticData(\"webPushAppType\");\n    let sendWebPush = function (person) {\n      D.log({ message: \"webPushAppType\", data: webPushAppType });\n      if (webPushAppType) {\n        let params = {\n          pushType: \"WEB_PUSH\",\n          action: \"SendNotification\",\n          webPushAppType,\n          userId: _.get(person, \"userId\"),\n          userEmail: _.get(person, \"emailAddress\"),\n          message: {\n            title: \"FrontM Notifications\",\n            text: message\n          }\n        };\n        D.log({ message: \"params\", data: params });\n        return state.callLambda(\"PushNotificationHandler\", params, \"Event\");\n      }\n    }\n    let webPushPromises = [];\n    _.forEach(people, (person, key) => {\n      let parsedPerson = JSON.parse(person.content);\n      //Deduplicate devices here\n      let personDevices = _.get(parsedPerson, 'voipDevices', []);\n      for (let [i, device] of personDevices.entries()) {\n        let index = _.findIndex(allDevices, currentDevice => {\n          return currentDevice === device\n        })\n        if (index > -1) {\n          personDevices.splice(i, 1);\n        } else {\n          if (onlyAndroid) {\n            if (device.includes(\"APN\")) {\n              personDevices.splice(i, 1);\n            }\n          } else if (onlyIOS) {\n            if (device.includes(\"GCM\")) {\n              personDevices.splice(i, 1);\n            }\n          }\n          allDevices.push(device);\n        }\n      }\n      if (_.size(personDevices) > 0) {\n        notificationsTargets[key].devices = personDevices\n      } else {\n        delete notificationsTargets[key]\n      }\n      webPushPromises.push(sendWebPush(parsedPerson));\n    });\n    await Promise.all(webPushPromises);\n    for (let i = 0; i < _.keys(notificationsTargets).length; i++) {\n      let key = _.keys(notificationsTargets)[i];\n      let target = notificationsTargets[key];\n      //_.forEach(notificationsTargets, (target) => {\n      await this.sendVoipPushNotificationToUserDevices(\n        _.get(target, 'devices'),\n        sns,\n        _.get(target, 'conversationId'),\n        message,\n        data\n      );\n      D.info({ message: 'Sent to device', data: target });\n    }\n  }\n\n  async sendPushNotificationToUserDevices(userDevices, sns, conversationId, message, data) {\n    let _ = this._state._;\n    let createSNSMsg = function (conversationId) {\n      let apsMsg = {\n        aps: {\n          alert: message,\n          sound: _.get(data, 'soundName', 'default'),\n        },\n        videoSessionId: _.get(data, 'videoSessionId'),\n        botId: _.get(data, 'botId'),\n        userDomain: _.get(data, 'userDomain'),\n        userId: _.get(data, 'userId'),\n        videoControlId: _.get(data, 'videoControlId'),\n        video: _.get(data, 'video'),\n        conversationId\n      };\n\n      let gcmMsg = {\n        collapse_key: 'FrontM messages',\n        notification: {\n          title: message,\n          conversationId,\n          botId: _.get(data, 'botId'),\n          userDomain: _.get(data, 'userDomain'),\n          userId: _.get(data, 'userId'),\n          soundName: _.get(data, 'soundName')\n        },\n        data: {\n          message: message,\n          conversationId,\n          videoSessionId: _.get(data, 'videoSessionId'),\n          botId: _.get(data, 'botId'),\n          userDomain: _.get(data, 'userDomain'),\n          userId: _.get(data, 'userId'),\n          videoControlId: _.get(data, 'videoControlId'),\n          video: _.get(data, 'video'),\n          soundName: _.get(data, 'soundName')\n        },\n      };\n\n      let snsMsg = {\n        default: message,\n        GCM: JSON.stringify(gcmMsg),\n        APNS: JSON.stringify(apsMsg),\n        APNS_SANDBOX: JSON.stringify(apsMsg),\n      };\n\n      return JSON.stringify(snsMsg);\n    };\n\n    let callSNS = function (conversationId, sns, message, arn) {\n      let snsParams = {\n        Message: createSNSMsg(conversationId, message),\n        MessageStructure: 'json',\n        Subject: 'New Message',\n        TargetArn: arn,\n      };\n      return sns.publish(snsParams).promise();\n    };\n\n    _.forEach(userDevices, arn => {\n      callSNS(conversationId, sns, message, arn)\n        .then(() => {\n          this._state.developer.info({ message: 'Push notification sent with no error' });\n        })\n        .catch(err => {\n          this._state.developer.warning({\n            message: 'Could not send push notification to a device',\n            data: JSON.stringify(err),\n          });\n          //console.log('Push notification error');\n          return 'error occurred while sending notification to :' + arn;\n        });\n    });\n  }\n\n  async sendPushNotifications(conversations, message, data) {\n    let R = this._state.R;\n    let _ = this._state._;\n    let D = this._state.developer;\n\n    D.debug({\n      message: \"Sending push\", data: {\n        conversations,\n        message,\n        data\n      }\n    });\n    let sns = new this._state.aws.SNS({ apiVersion: '2010-03-31' });\n    let devices = [];\n    let notificationsTargets = {};\n    let keys = [];\n    _.forEach(conversations, conversation => {\n      _.forEach(_.get(conversation, 'participants'), participant => {\n        if (participant !== _.get(conversation, 'bot')) {\n          let key = `People_${participant}`;\n          keys.push(key);\n          notificationsTargets[key] = {\n            conversationId: conversation.conversationId,\n          };\n        }\n      });\n    });\n    if (keys.length > 0) {\n      let people = await this._state.db.getMultipleValuesFromCache(keys);\n      _.forEach(people, (person, key) => {\n        let parsedPerson = JSON.parse(person.content);\n        notificationsTargets[key].devices = devices.concat(_.get(parsedPerson, 'devices', []));\n      });\n      // D.debug({message: 'Targets ', data: R.toString(notificationsTargets)});\n      _.forEach(notificationsTargets, target => {\n        this.sendPushNotificationToUserDevices(_.get(target, 'devices'), sns, _.get(target, 'conversationId'), message, data)\n          .then(() => {\n            //console.log(\"notification sent\");\n          })\n      });\n    } else {\n      D.warning({ message: \"No participants within the conversation\" });\n    }\n  }\n\n  async ringParticipantsInConversationList(conversations, alertMessage, data) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    //D.debug({message: 'In ring request'});\n    for (let i = 0; i < conversations.length; i++) {\n      let conversation = conversations[i];\n      let conversationId = _.get(conversation, 'conversationId');\n      let participants = _.get(conversation, 'participants');\n      for (let l = 0; l < participants.length; l++) {\n        let participant = participants[l];\n        data.conversationId = conversationId;\n        if (participant !== this._state.user.userId) {\n          await this.sendVoipPushNotifications(participant, alertMessage, data)\n        }\n      }\n    }\n  }\n\n  async sendVoipPushNotifications(receiverUserId, alertMessage, data) {\n    let R = this._state.R;\n    let _ = this._state._;\n    let D = this._state.developer;\n    try {\n      //D.debug({message: 'In sending push'});\n      let createVoipMsg = function (alertMessage, data) {\n        let apsMsg = {\n          aps: {\n            alert: alertMessage,\n            data,\n          }\n        };\n        let androidMessage = {\n          notification: {\n            title: alertMessage,\n            body: data.message,\n            sound: 'incallmanager_ringback.mp3',\n            android_channel_id: '500'\n          },\n          data,\n          \"priority\": \"high\",\n        };\n        let snsMsg = {\n          APNS_VOIP_SANDBOX: JSON.stringify(apsMsg),\n          APNS_VOIP: JSON.stringify(apsMsg),\n          GCM: JSON.stringify(androidMessage),\n        };\n        return JSON.stringify(snsMsg);\n      }\n\n      let sendVoipNotification = function (alertMessage, data, arn, sns) {\n        let snsParams = {\n          Message: createVoipMsg(alertMessage, data),\n          MessageStructure: 'json',\n          MessageAttributes: {\n            \"AWS.SNS.MOBILE.APNS.PRIORITY\": { \"DataType\": \"String\", \"StringValue\": \"10\" },\n            \"AWS.SNS.MOBILE.APNS.PUSH_TYPE\": { \"DataType\": \"String\", \"StringValue\": \"voip\" }\n          },\n          TargetArn: arn,\n        };\n        return sns.publish(snsParams).promise();\n      };\n      let frontmLib = this._state.frontmlib;\n      let receiver = await frontmLib.dbGetWithKey('People', { userId: receiverUserId });\n      let voipDevices = _.get(receiver, 'Item.voipDevices', []);\n\n      let sns = new this._state.aws.SNS({ apiVersion: '2010-03-31' });\n      _.forEach(voipDevices, arn => {\n        sendVoipNotification(alertMessage, data, arn, sns)\n          .then(() => {\n            this._state.developer.info({ message: `Voip Push notification sent with no error: ${arn}` });\n          })\n          .catch(err => {\n            this._state.developer.warning({\n              message: `Could not send voip push notification to a device to: ${arn}`,\n              data: JSON.stringify(err),\n            });\n            //console.log('Voip Push notification error');\n          });\n      });\n    } catch (error) {\n      D.warning({ message: 'Fail voip push', data: error.message })\n    }\n  }\n\n  endCall({ receiverUserId, videoSessionId, video }) {\n    let params = {\n      capability: 'VoipCapability',\n      capabilityFileName: 'voipCapability',\n      action: 'sendVoipPushNotification',\n      callAction: 'CallEnd',\n      callerUserId: this._state.user.userId,\n      receiverUserId, videoSessionId, video,\n    };\n    return this._state.callCapability(params);\n  }\n\n  async ringMultipleUsers(conversations, alertMessage, data) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let callerId = this._state.user.userId;\n    let receivers = [];\n    for (let i = 0; i < conversations.length; i++) {\n      let conversation = conversations[i];\n      await this.sendVoipCallPushNotifications(conversation, alertMessage, data);\n    }\n  }\n\n  ringSingleUser(receiverUserId, alertMessage, data) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let callerId = this._state.user.userId;\n\n    let params = {\n      capability: 'VoipCapability',\n      capabilityFileName: 'voipCapability',\n      action: 'sendVoipPushNotification',\n      callAction: 'CallStart',\n      callerUserId: callerId,\n      receiverUserId,\n      videoSessionId: data.videoSessionId,\n      video: data.video || false,\n      alertMessage\n    };\n    return this._state.callCapability(params);\n  }\n\n  handleCallConnected({ callerUserId, receiverUserId }) {\n    let params = {\n      capability: 'VoipCapability',\n      capabilityFileName: 'voipCapability',\n      action: 'handleMultiUserCalls',\n      callAction: 'CallConnected',\n      callerUserId,\n      receiverUserId,\n    };\n    return this._state.callCapability(params);\n  }\n\n  inviteUsers(emailIds) {\n    let params = {\n      capability: 'InviteUsers',\n      capabilityFileName: 'userInvitation',\n      emailIds: emailIds,\n      sync: true,\n      userId: this._state.user.userId,\n      conversation: this._state.conversation,\n    };\n\n    let capabilities = this._state.context.capabilities.capabilities;\n    let capFileName = params.capabilityFileName;\n    let capabilityModule = capabilities[capFileName];\n    if (capabilityModule) {\n      //console.log('Executing the capability module');\n      return capabilityModule.execute(params, this._state.context.capabilities);\n    } else {\n      return this._state.callLambda('EmailLambda', params, 'RequestResponse').then(response => {\n        //console.log('Back from email lambda ' + JSON.stringify(response));\n        return JSON.parse(response.Payload);\n      });\n    }\n  }\n\n  isDeviceRegisteredForPush() {\n    return this.notification.deviceInfo().then(deviceInfo => {\n      if (this._state._.isEmpty(deviceInfo)) {\n        return false;\n      }\n      return deviceInfo.isRegistered;\n    });\n  }\n\n  registerDeviceForPushOnEdge() {\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      this.notification.requestPermission();\n    }\n  }\n\n  deregisterDeviceForPushOnEdge() {\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      return this.notification\n        .deregister()\n        .then(notificationDeviceInfo => {\n          return notificationDeviceInfo;\n        })\n        .catch(error => {\n          this._state.addSystemErrorToStack(19, JSON.stringify(error));\n        });\n    } else {\n      this._state.addSystemErrorToStack(18);\n    }\n  }\n\n  registerDeviceForPushOnBackend(notificationDeviceInfo) {\n    try {\n      let conversation = this._state.conversation;\n      let userId = this._state.user.userId;\n      let params = {\n        capability: 'RegisterDevice',\n        capabilityFileName: 'deviceRegistration',\n        deviceToken: notificationDeviceInfo.deviceId,\n        deviceType: notificationDeviceInfo.deviceType,\n        sync: true,\n        userId: userId,\n        conversation: conversation,\n      };\n      return this._state.callCapability(params);\n    } catch (error) {\n      this._state.addSystemErrorToStack(16, null, error.message);\n    }\n  }\n\n  deregisterDeviceForPushOnBackend(notificationDeviceInfo) {\n    try {\n      let conversation = this._state.conversation;\n      let userId = this._state.user.userId;\n      let params = {\n        capability: 'DeregisterDevice',\n        capabilityFileName: 'deviceRegistration',\n        deviceToken: notificationDeviceInfo.deviceId,\n        deviceType: notificationDeviceInfo.deviceType,\n        sync: true,\n        userId: userId,\n        conversation: conversation,\n      };\n      return this._state.callCapability(params);\n    } catch (error) {\n      this._state.addSystemErrorToStack(16, null, error.message);\n    }\n  }\n\n  sendDelayedNotification(params) {\n    return this._state.callCapability(params)\n  }\n\n  generateFullMessageForMessage(msg, target, type, realTimeMessage, v1Compatibility) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    let requestId = this._state.getUniqueId();\n    let messageToSend = msg;\n    if (!realTimeMessage) {\n      let state = _.get(target, 'bot') === this._state.botId ? this._state.stateToBackEnd() : { state: {} };\n      state.state.messageFromUser = msg;\n      state.state.messageTypeFromUser = 'object';\n      state.state.fromGreeting = false;\n      state.state.responsesArray = [];\n      state.state._syncToCloud = {};\n      state.state._syncToEdge = {};\n      // state.state._delayedNotification = [];\n      state.state._activeIntent = '';\n      state.state.responseToClient = _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT;\n      //D.log({message: 'Setting v1Compatibility'});\n      if (!realTimeMessage && v1Compatibility) {\n        //v1Compatibility generates simple responses in case of bot to bot messages\n        state.state.v1Compatibility = true;\n      }\n      messageToSend = state;\n    }\n    //D.log({message: 'Bot to bot message content', data: messageToSend});\n    let size = this._state.sizeOfObject(JSON.stringify(messageToSend));\n    if (size >= 200000) {\n      D.log({\n        message: '********** Danger danger danger!! Your PARAMS is too big!! **********',\n        data: size\n      });\n    }\n    return {\n      content: [messageToSend],\n      contentType: type,\n      requestUuid: requestId,\n      createdBy: this._state.user.userId,\n      createdOn: Date.now(),\n      messageId: this._state.getUniqueId(),\n    }\n  }\n\n  sendNotification(target, type, message, realTimeMessage, v1Compatibility) {\n    try {\n      let _ = this._state._;\n      let messages = [];\n      if (Array.isArray(message)) {\n        _.forEach(message, msg => {\n          messages.push(this.generateFullMessageForMessage(msg, target, type, realTimeMessage, v1Compatibility))\n        })\n      } else {\n        messages.push(this.generateFullMessageForMessage(message, target, type, realTimeMessage, v1Compatibility))\n      }\n      //this._state.addRequestId(requestId);\n      let requestUuid = this._state.getUniqueId();\n      let params = {\n        target: target,\n        capability: 'BroadCastMessageCapability',\n        capabilityFileName: 'broadCastMessage',\n        action: 'get',\n        bot: this._state.conversation.bot || _.get(this._state.context, 'botManifest.botId'),\n        userDomain: this._state.conversation.userDomain,\n        requestUuid,\n        sync: true,\n        email: this._state.user.userEmail,\n        conversation: this._state.conversation,\n        realTimeMessage,\n        messages,\n      };\n      return this._state.online().then(online => {\n        if (online) {\n          //console.log('HERE BOT TO BOT***');\n          let lambda = new this._state.aws.Lambda();\n          return lambda\n            .invoke({\n              FunctionName: 'CapabilityExecutorLambda',\n              InvocationType: 'Event',\n              Payload: JSON.stringify(params, null, 0),\n            })\n            .promise();\n          // return this._state.callCapability(params);\n        } else {\n          this._state.addDelayedNotification(params);\n          return Promise.resolve()\n        }\n      })\n    } catch (error) {\n      this._state.addSystemErrorToStack(16, null, error.message);\n    }\n  }\n\n  sendMessageToUserInBot(type, message, userIds, botId, userDomain, realTimeMessage, delay, v1Compatibility) {\n    let _ = this._state._;\n    let D = this._state.developer;\n    if (!userIds || _.isEmpty(userIds)) {\n      D.warning({ message: \"The userIds array is empty. This request acts as a broadcast and could duplicate messages\" })\n    }\n    let target = {\n      bot: botId || this._state.botId,\n      userDomain: userDomain || this._state.currentUserDomain,\n      users: userIds,\n    };\n    D.debug({ message: \"Sending bot to bot to\", data: target});\n    D.debug({ message: \"Sending bot to bot with message\", data: message});\n    if (delay) { //Delay in milliseconds\n      setTimeout(() => {\n        return this.sendNotification(target, type, message, realTimeMessage, v1Compatibility);\n      }, delay);\n    } else {\n      return this.sendNotification(target, type, message, realTimeMessage, v1Compatibility);\n    }\n  }\n  \n  async sendQueueMessageToUserInBot({type, message, userIds, botId, userDomain, realTimeMessage = false, queue}){\n    let _ = this._state._;\n    let D = this._state.developer;\n    if (!queue) {\n      D.systemError({ message: \"Missing queue url, not sending the message\" });\n      return;\n    }\n\n    if (!userIds || _.isEmpty(userIds)) {\n      D.warning({ message: \"The userIds array is empty. This request acts as a broadcast and could duplicate messages\" })\n    }\n    let target = {\n      bot: botId || this._state.botId,\n      userDomain: userDomain || this._state.currentUserDomain,\n      users: userIds,\n    };\n\n    if (!Array.isArray(message)) {\n      message = [message];\n    }\n\n    let messages = _.map(message, msg => {\n      return this.generateFullMessageForMessage(msg, target, type, realTimeMessage, false);\n    });\n\n    let queuePayload = {\n      target, \n      botId: this._state.conversation.bot || _.get(this._state.context, 'botManifest.botId'),\n      userDomain: this._state.conversation.userDomain,\n      email: this._state.user.userEmail,\n      conversation: this._state.conversation,\n      realTimeMessage\n    }\n    for (let msg of messages) {\n      queuePayload.messages = [msg];\n      await this._state.sendMessageToQueue(queue, queuePayload);\n    }\n  }\n\n  sendBroadcastNotificationToBot(botId, userDomain, type, message, realTimeMessage, delay, v1Compatibility) {\n    let target = {\n      bot: botId || this._state.botId,\n      userDomain: userDomain || this._state.currentUserDomain,\n    };\n    if (delay) { //Delay in milliseconds\n      setTimeout(() => {\n        return this.sendNotification(target, type, message, realTimeMessage, v1Compatibility);\n      }, delay);\n    } else {\n      return this.sendNotification(target, type, message, realTimeMessage, v1Compatibility);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Notification.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Orders.js":
/*!***********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Orders.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Orders: function() { return /* binding */ Orders; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n\n\nclass Orders {\n  static PAYMENT_CODES() {\n    return { TOP_UP_WALLET: '100', PURCHASE_PRODUCT: '101' };\n  }\n\n  static CURRENT_STRIPE_TRANSACTIONS() {\n    return 'currentStripeTransactions';\n  }\n\n  constructor(state) {\n    this['_state'] = state;\n    this['context'] = state.context;\n    this['userId'] = state.user.userId;\n    this['conversation'] = state.conversation;\n    this['location'] = state.location;\n    this._state.developer.log({ message: 'Initialising Orders' });\n    if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT && this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n      if (this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n        this._state.developer.log({ message: 'Initialising InAppPurchases' });\n        this['inAppPurchaseCap'] = this.context.getCapability('InAppPurchase');\n        this['productTypes'] = this.inAppPurchaseCap.ProductTypes;\n      } else {\n        this['inAppPurchaseCap'] = 'false';\n        this['productTypes'] = [];\n      }\n    }\n  }\n\n  createNewStripeTransaction(amount, currency, description) {\n    let currentTransactions = this._state.getField(Orders.CURRENT_STRIPE_TRANSACTIONS()) || [];\n    let transactionId = this._state.UUID();\n    currentTransactions.push({ transactionId, amount, currency, description });\n    this._state.setField(Orders.CURRENT_STRIPE_TRANSACTIONS(), currentTransactions);\n    return transactionId;\n  }\n\n  getStripeTransaction(transactionId) {\n    let currentTransactions = this._state.getField(Orders.CURRENT_STRIPE_TRANSACTIONS()) || [];\n    let index = this._state._.findIndex(currentTransactions, transaction => {\n      return transaction.transactionId === transactionId;\n    });\n    return index === -1 ? null : currentTransactions[index];\n  }\n\n  removeStripeTransaction(transactionId) {\n    let currentTransactions = this._state.getField(Orders.CURRENT_STRIPE_TRANSACTIONS()) || [];\n    let index = this._state._.findIndex(currentTransactions, transaction => {\n      return transaction.transactionId === transactionId;\n    });\n    this._state._.pullAt(currentTransactions, [index]);\n    this._state.setField(Orders.CURRENT_STRIPE_TRANSACTIONS(), currentTransactions);\n  }\n\n  inAppPurchase(product) {\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.LOCATIONS.CLOUD || this._state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.CLIENTS.WEBCLIENT) {\n      this._state.addSystemErrorToStack(13);\n      return;\n    }\n    this._state.developer.log({ message: 'About to buy product ' + product + ' of type ' + this.productTypes.VOIP });\n    return this.inAppPurchaseCap.buyProduct({\n      productCode: product,\n      productName: this.productTypes.VOIP,\n    });\n  }\n\n  processStripePayment() {\n    let { transactionId, currency, amount, paymentSuccessful } = this._state.messageFromUser;\n    if (paymentSuccessful) {\n      let stateTransaction = this.getStripeTransaction(transactionId);\n      if (stateTransaction === null) {\n        return { error: 'Invalid transaction id' };\n      }\n\n      let { transactionId: stateTransactionId, currency: stateCurrency, amount: stateAmount } = stateTransaction;\n      if (stateTransactionId !== transactionId) {\n        return { error: 'Invalid transaction id' };\n      }\n      if (stateAmount !== amount) {\n        return {\n          error: 'There is a discrepancy in amounts. Please report to the support team',\n        };\n      }\n      if (stateCurrency !== currency) {\n        return {\n          error: 'There is a discrepancy in currencies. Please report to the support team',\n        };\n      }\n      this.removeStripeTransaction(transactionId);\n      return { error: 0 };\n    } else {\n      this.removeStripeTransaction(transactionId);\n      return { error: 'Your stripe payment was not successful' };\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Orders.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/SFTP.js":
/*!*********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/SFTP.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SFTP: function() { return /* binding */ SFTP; }\n/* harmony export */ });\nclass SFTP {\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n    let capabilities = state.context.capabilities.capabilities;\n    if (capabilities) {\n      this['_context'] = state.context.capabilities;\n      this['_sftpClient'] = state.context.capabilities.ssh2SftpClient;\n    } else {\n      this['_context'] = state.context;\n      this['_sftpClient'] = state.context.ssh2SftpClient;\n    }\n  }\n\n  async connect(host, port, username, password) {\n    try {\n      let sftpClient = new this._sftpClient();\n      await sftpClient.connect({ host, port, username, password });\n      return sftpClient;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  async disconnect(sftpClient) {\n    try {\n      await sftpClient.end();\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  async getFilesList(sftpClient, path) {\n    try {\n      return await sftpClient.list(path);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  async downloadFileToS3(sftpClient, S3, fromPath, toPath, fileName) {\n    try {\n      let config = this._.get(this._context, 'capabilities.config');\n      let env = this._.get(this._context, 'capabilities.env');\n      if (!config) {\n        config = this._.get(this._context, 'config');\n        env = this._.get(this._context, 'env');\n      }\n\n      let stream = await sftpClient.get(`${fromPath}/${fileName}`);\n      let putParams = { Bucket: config[env].CONVERSATIONS_BUCKET, Key: `${toPath}/${fileName}`, Body: stream };\n      await S3.putObject(putParams).promise();\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  async putFileToFTPServer(sftpConnection, readStream, remotePath) {\n    try {\n      let D = this._state.developer;\n      await sftpConnection.put(readStream, remotePath);\n    } catch (err) {\n      D.systemError({\n        message: 'putFileToFTPServer:Error occurred while putting the file to the server',\n        errorCode: err.message,\n        data: err\n      });\n      throw err;\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/SFTP.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Schedules.js":
/*!**************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Schedules.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Schedules: function() { return /* binding */ Schedules; }\n/* harmony export */ });\nclass Schedules {\n\n  static SCHD_INDEX() {\n    return 'scheduler';\n  }\n\n  static SCHD_MASTER_DB() {\n    return 'schedulerMaster';\n  }\n\n  static SCHD_DETAIL_DB() {\n    return 'schedulerDetail';\n  }\n\n  constructor(state) {\n    this['_state'] = state;\n    this['_'] = state._;\n    // this['_context'] = state.context;\n    let capabilities = state.context.capabilities.capabilities;\n    let context = null;\n    if (capabilities) {\n      context = state.context.capabilities;\n    } else {\n      context = state.context;\n    }\n    this['_context'] = context;\n    this['userId'] = state.user.userId;\n    this['conversation'] = state.conversation;\n    this['location'] = state.location;\n  }\n\n  _validateResources(resourceData) {\n    let {\n      domain, resourceName, resourceId, resourceType, resourceSubType,\n      availStartTime, availEndTime, dailyStartTime, dailyEndTime, weeklyOffDays, adhocOffTime\n    } = resourceData;\n\n    if (!domain || !resourceName || !resourceId ||\n      !resourceType || !resourceSubType ||\n      // !multiTask || !availableStatus ||\n      !availStartTime || !availEndTime)\n      return false;\n\n    if (availStartTime >= availEndTime) return false;\n\n    if (dailyStartTime && dailyStartTime < 0) return false;\n\n    if (dailyEndTime && dailyEndTime > 24) return false;\n    // we will have to handle the below condition in the bot.\n    // We have to consider 2 days worth of booking\n    //eg: 4 PM to 2PM (4PM on 19th - 2PM 20th)\n    // if (dailyStartTime >= dailyEndTime) return false;\n\n    if (weeklyOffDays && !(Array.isArray(weeklyOffDays))) return false;\n\n    if (adhocOffTime && !(Array.isArray(adhocOffTime))) return false;\n\n    return true;\n\n    // #TODO Add more validations\n  }\n\n  _getWeekdaysBetweenDates(inReqStartTime, inReqEndTime, tz) {\n    const { momentTimeZone } = this._context;\n    const momentStart = momentTimeZone.tz(inReqStartTime, tz);\n    const momentFinal = momentTimeZone.tz(inReqEndTime, tz);\n    const diff = momentFinal.diff(momentStart, \"days\");\n\n    if (diff >= 7) {\n      return momentTimeZone.weekdays();\n    }\n\n    const firstDay = momentStart.day();\n    const weekdaysBetween = [];\n\n    for (let i = 0; i <= diff; i++) {   // use % to loop to beginning again (e.g: start at friday and have +4)\n      weekdaysBetween.push(momentTimeZone.weekdays((firstDay + i) % 7));\n    }\n    return weekdaysBetween;\n  };\n\n  _extractTimeDetails(inReqStartTime, inReqEndTime, resourceTimezone) {\n    let enteredTz = resourceTimezone || \"GMT +00:00 (Etc/GMT)\";\n    let timezoneString = enteredTz ? enteredTz.split(\"(\")[1].substring(0, enteredTz.split(\"(\")[1].length - 1) : \"Etc/GMT\";\n    const { moment, momentTimeZone } = this._context;\n    //TODO:\n    // use timezone here to get the exact hours start\n    const reqStartHrs = momentTimeZone.tz(inReqStartTime, timezoneString).hours();\n    const reqEndHrs = momentTimeZone.tz(inReqEndTime, timezoneString).hours();\n    const reqIsMultiDay = !(momentTimeZone.tz(inReqStartTime, timezoneString).isSame(momentTimeZone.tz(inReqEndTime, timezoneString), 'day'));\n    const reqWeekDays = this._getWeekdaysBetweenDates(inReqStartTime, inReqEndTime, timezoneString);\n\n    return { reqStartHrs, reqEndHrs, reqIsMultiDay, reqWeekDays };\n  }\n\n  _checkAdhocOffTime(adhocSlots, inReqStartTime, inReqEndTime) {\n    let _ = this._;\n    let offTimeConflict = false;\n\n    if (!adhocSlots || !Array.isArray(adhocSlots) || adhocSlots.length < 1) return offTimeConflict;\n\n    _.forEach(adhocSlots, slot => {\n      // this._state.developer.log({ message: 'From Schedules, current adhoc slot ', data: slot });\n      if (inReqStartTime > slot.endTime || inReqEndTime < slot.startTime) { // no conflict\n        // this._state.developer.log({ message: 'From Schedules, current adhoc slot ', data: 'return true' });\n        return true;    // continue with next offline slot\n      } else {\n        offTimeConflict = true;   // conflict\n        // this._state.developer.log({ message: 'From Schedules, current adhoc slot ', data: 'return false' });\n        return false;    // break forEach\n      }\n    });\n    // this._state.developer.log({ message: 'From Schedules, offTimeConflict ', data: offTimeConflict });\n    return offTimeConflict;\n  };\n\n  async _checkConflictingBookings(id, inReqStartTime, inReqEndTime, scheduleIdArr) {\n    let _ = this._;\n    let bookingConflict = false;\n\n    if (!id || !inReqStartTime || !inReqEndTime) return bookingConflict;\n    let finalScheduleDataArr = [];\n    let additionalQuery = [];\n    if (scheduleIdArr && scheduleIdArr.length) {\n      for (const schedule of scheduleIdArr) {\n        let scheduleData = await this._state.db.getDataFromCollection({\n          collection: Schedules.SCHD_DETAIL_DB(),\n          action: 'query',\n          query: { _id: schedule },\n          projection: {},\n          sort: {},\n          skip: 0,\n          limit: 1,\n          collation: {},\n          expectOneResult: false,\n          cache: false\n        })\n        if (scheduleData && scheduleData.statusCode === 200 && scheduleData.body && scheduleData.body.length) {\n          finalScheduleDataArr.push(scheduleData.body[0]);\n        }\n      }\n      additionalQuery = finalScheduleDataArr.map(entry => {\n        return { $and: [{ bookedStartTime: { $eq: entry.bookedStartTime } }, { bookedEndTime: { $eq: entry.bookedEndTime } }] }\n      })\n    }\n    let initialOrQuery = [\n      { \"$and\": [{ \"bookedStartTime\": { \"$lte\": inReqStartTime } }, { \"bookedEndTime\": { \"$gt\": inReqStartTime } }] },\n      { \"$and\": [{ \"bookedStartTime\": { \"$lt\": inReqEndTime } }, { \"bookedEndTime\": { \"$gt\": inReqEndTime } }] },\n      { \"$and\": [{ \"bookedStartTime\": { \"$gt\": inReqStartTime } }, { \"bookedEndTime\": { \"$lte\": inReqEndTime } }] },\n    ]\n    let query = {\n      \"$and\": [\n        { \"origId\": id },\n        {\n          \"$or\": [...additionalQuery, ...initialOrQuery]\n        }\n      ]\n    }\n\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_DETAIL_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort: {},\n      skip: 0,\n      limit: 1,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body)) {\n      let allResponses = responsesArray.body;\n      let finalAllresponses = []\n      allResponses.map(sch => {\n        if (scheduleIdArr.indexOf(sch._id) === -1) {\n          finalAllresponses.push(sch)\n        }\n      })\n      bookingConflict = (_.size(finalAllresponses) > 0) ? true : false;\n    } else {\n      bookingConflict = true; // Database error, avoid overbooking, try booking again\n    }\n    return bookingConflict;\n  };\n\n  async _filterQueriedResources(inpResourceArray, inReqStartTime, inReqEndTime, scheduleIdArr) {\n    let _ = this._;\n    let outResourceArray = [];\n\n    if (!inpResourceArray || !Array.isArray(inpResourceArray) || inpResourceArray.length < 1) return outResourceArray;\n    if (inReqStartTime >= inReqEndTime) return outResourceArray;\n    let {\n      reqStartHrs,\n      reqEndHrs,\n      reqIsMultiDay,\n      reqWeekDays\n    } = this._extractTimeDetails(inReqStartTime, inReqEndTime, inpResourceArray[0].resourceTimezone);\n    this._state.developer.log({\n      message: 'From Schedules, extractTimeDetails resp',\n      data: { reqStartHrs, reqEndHrs, reqIsMultiDay, reqWeekDays }\n    });\n\n    for (const currRes of inpResourceArray) {\n      let { id, dailyStartTime, dailyEndTime, weeklyOffDays, adhocOffTime } = currRes;\n\n      let t1 = reqStartHrs >= dailyStartTime;\n      if (!(reqStartHrs >= dailyStartTime)) return;\n\n      let t2 = reqEndHrs <= dailyEndTime;\n      if (!(reqEndHrs <= dailyEndTime)) return;\n\n      let t3 = _.intersection(reqWeekDays, weeklyOffDays);\n      if (_.size(_.intersection(reqWeekDays, weeklyOffDays)) > 0) return;\n\n      let t4 = reqIsMultiDay && (dailyStartTime !== 0 || dailyEndTime !== 24);\n      if (reqIsMultiDay && (dailyStartTime !== 0 || dailyEndTime !== 24)) return;\n\n      if (this._checkAdhocOffTime(adhocOffTime, inReqStartTime, inReqEndTime)) return;\n\n      let existingBooking = await this._checkConflictingBookings(id, inReqStartTime, inReqEndTime, scheduleIdArr);\n      if (existingBooking) return;\n\n      outResourceArray.push(currRes);\n    }\n\n    return outResourceArray;\n\n  };\n\n  async createSingleResource(resource) {\n\n    this._state.developer.log({ message: 'From Schedules, createSingleRes with', data: resource });\n    let newResource = {};\n    let isValid = this._validateResources(resource);\n    if (isValid) {\n      newResource.id = this._state.getUniqueId();   // <--------------------------- Should we allow bot to set this?\n      // newResource.origId = resource.origId || this._state.getUniqueId();     // <----------------- What to do with this?\n      newResource.domain = resource.domain;  // replace by this._state.currentUserDomain\n      newResource.resourceId = resource.resourceId;\n      newResource.resourceName = resource.resourceName;\n      newResource.resourceType = resource.resourceType;\n      newResource.resourceSubType = resource.resourceSubType;\n      newResource.availStartTime = resource.availStartTime;\n      newResource.availEndTime = resource.availEndTime;\n      newResource.dailyStartTime = parseInt(resource.dailyStartTime) || 0;\n      newResource.dailyEndTime = parseInt(resource.dailyEndTime) || 24;\n      newResource.weeklyOffDays = resource.weeklyOffDays || [];\n      newResource.adhocOffTime = resource.adhocOffTime || [];\n      newResource.resourceTimezone = resource.resourceTimezone || \"GMT +00:00 (Etc/GMT)\"\n      newResource.multiTask = resource.multiTask; // bool, cannot set default\n      newResource.availableStatus = resource.availableStatus; // bool, cannot set default\n      let writeResp = await this._state.db.insertDocumentInCollection({\n        collection: Schedules.SCHD_MASTER_DB(),\n        document: newResource,\n        audit: false,\n        sync: false\n      });\n      // if (!writeResp.error && !writeResp.errorMessage) {\n      if (writeResp.statusCode === 200 && writeResp.body === 'success') {\n        // this._state.developer.log({ message: 'From Schedules Class Create success', data: writeResp });\n        return { 'status': 'success', newId: newResource.id };\n      } else {\n        this._state.developer.log({ message: 'From Schedules Class Create ERROR', data: writeResp });\n        return { 'status': 'error', newId: undefined };\n      }\n    } else {\n      this._state.developer.log({ message: 'From Schedules Class Create ERROR', data: \"Incomplete details\" });\n      return { 'status': 'error', newId: undefined };\n    }\n  }\n\n  async updateSingleResource(resource) {\n\n    // this._state.developer.log({ message: 'From Schedules, updateSingleRes with', data: resource });\n    let updResource = {};\n    let isValid = this._validateResources(resource);\n    if (isValid && resource.id) {\n      updResource.id = resource.id; // possibility of edit #TODO\n      // updResource.origId = resource.origId;                     // <----------------- What to do with this?\n      updResource.domain = resource.domain;\n      updResource.resourceId = resource.resourceId;\n      updResource.resourceName = resource.resourceName;\n      updResource.resourceType = resource.resourceType;\n      updResource.resourceSubType = resource.resourceSubType;\n      updResource.availStartTime = resource.availStartTime;\n      updResource.availEndTime = resource.availEndTime;\n      updResource.dailyStartTime = parseInt(resource.dailyStartTime) || 0;\n      updResource.dailyEndTime = parseInt(resource.dailyEndTime) || 24;\n      updResource.weeklyOffDays = resource.weeklyOffDays || [];\n      updResource.adhocOffTime = resource.adhocOffTime || [];\n      updResource.multiTask = resource.multiTask;\n      updResource.availableStatus = resource.availableStatus;\n      updResource.resourceTimezone = resource.resourceTimezone;\n\n      let query = {\n        id: resource.id\n      };\n      let options = {\n        upsert: true\n      };\n\n      let writeResp = await this._state.db.updateDataInCollection({\n        collection: Schedules.SCHD_MASTER_DB(),\n        document: updResource,\n        query,\n        options,\n        audit: false,\n        sync: false\n      });\n      // if (!writeResp.error && !writeResp.errorMessage) {\n      if (writeResp.statusCode === 200 && writeResp.body === 'success') {\n        // this._state.developer.log({ message: 'From Schedules Class Update success', data: writeResp });\n        return true;\n      } else {\n        this._state.developer.log({ message: 'From Schedules Class Update ERROR', data: writeResp });\n        return false;\n      }\n    } else {\n      this._state.developer.log({ message: 'From Schedules Class Update ERROR', data: \"Incomplete details\" });\n      return false;\n    }\n  }\n\n  async deleteSingleResource(resourceId) {\n\n    // this._state.developer.log({ message: 'From Schedules, deleteSingleRes with', data: resourceId });\n    if (!resourceId) return false;\n\n    let query = {\n      id: resourceId\n    };\n    // TODO - Check if we have to delete from DETAIL\n    // let delResp = await this._state.db.deleteDataFromIndexByID(Schedules.SCHD_INDEX(), '_doc', resourceId);\n    let delResp = await this._state.db.deleteDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      query,\n      audit: false,\n      sync: false\n    });\n    // if (!delResp.error && !delResp.errorMessage) {\n    if (delResp.statusCode === 200 && delResp.body === 'success') {\n      // this._state.developer.log({ message: 'From Schedules Class Delete success', data: delResp });\n      return true;\n    } else {\n      this._state.developer.log({ message: 'From Schedules Class Delete ERROR', data: delResp });\n      return false;\n    }\n  }\n\n  async createRecurringResource() {\n    // to be implemented\n  }\n\n  async updateRecurringResource() {\n    // to be implemented\n  }\n\n  async deleteRecurringResource() {\n    // to be implemented\n  }\n\n  async searchResourcesByInterval(startTime, endTime) {\n\n    this._state.developer.log({\n      message: 'From Schedules, searchResourcesByInterval with',\n      data: { startTime, endTime }\n    });\n    if (startTime >= endTime) return [];\n    let query = {\n      \"availStartTime\": { \"$lte\": startTime },\n      \"availEndTime\": { \"$gte\": endTime },\n      \"availableStatus\": true\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n    this._state.developer.log({ message: 'From Schedules Class searchResourcesByInterval QUERY', data: query });\n    // let responsesArray = await this._state.db.getDataFromIndexWithQueryObject(Schedules.SCHD_INDEX(), queryObj);\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByInterval RESP',\n      data: responsesArray\n    });\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0) {\n      let filterResp = await this._filterQueriedResources(responsesArray.body, startTime, endTime);\n      return filterResp;\n    } else {\n      return [];\n    }\n  }\n\n  async searchResourcesByIntervalByType(resType, startTime, endTime) {\n\n    this._state.developer.log({\n      message: 'From Schedules, searchResourcesByIntervalByType with',\n      data: { resType, startTime, endTime }\n    });\n    if (startTime >= endTime || !resType) return [];\n\n    let query = {\n      \"resourceType\": resType,\n      \"availStartTime\": { \"$lte\": startTime },\n      \"availEndTime\": { \"$gte\": endTime },\n      \"availableStatus\": true\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByIntervalByType QUERY',\n      data: query\n    });\n    // let responsesArray = await this._state.db.getDataFromIndexWithQueryObject(Schedules.SCHD_INDEX(), queryObj);\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0) {\n      let filterResp = await this._filterQueriedResources(responsesArray.body, startTime, endTime);\n      return filterResp;\n    } else {\n      return [];\n    }\n  }\n\n  async searchResourcesByIntervalBySubType(resSubType, startTime, endTime) {\n\n    this._state.developer.log({\n      message: 'From Schedules, searchResourcesByIntervalBySubType with',\n      data: { resSubType, startTime, endTime }\n    });\n\n    if (startTime >= endTime || !resSubType) return [];\n\n    let query = {\n      \"resourceSubType\": resSubType,\n      \"availStartTime\": { \"$lte\": startTime },\n      \"availEndTime\": { \"$gte\": endTime },\n      \"availableStatus\": true\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByIntervalBySubType RESP',\n      data: responsesArray\n    });\n    // let responsesArray = await this._state.db.getDataFromIndexWithQueryObject(Schedules.SCHD_INDEX(), query);\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0) {\n      let filterResp = await this._filterQueriedResources(responsesArray.body, startTime, endTime);\n      return filterResp;\n    } else {\n      return [];\n    }\n\n  }\n\n  async searchResourcesByIntervalByResId(resId, startTime, endTime, scheduleIdArr) {\n    if (startTime >= endTime || !resId) return [];\n\n    let gotConflict = await this._checkConflictingBookings(resId, startTime, endTime, scheduleIdArr);\n    if (gotConflict) return null;\n\n    let query = {\n      \"resourceId\": resId,\n      \"availStartTime\": { \"$lte\": startTime },\n      \"availEndTime\": { \"$gte\": endTime },\n      \"availableStatus\": true\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n\n    // if (responsesArray && responsesArray.length > 0)\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0) {\n      let filterResp = await this._filterQueriedResources(responsesArray.body, startTime, endTime, scheduleIdArr);\n      return filterResp;\n    } else {\n      return [];\n    }\n  }\n\n  async searchResourcesByIntervalByTypeSubType(resType, resSubType, startTime, endTime) {\n\n    this._state.developer.log({\n      message: 'From Schedules, searchResourcesByIntervalByTypeSubType with',\n      data: { resType, resSubType, startTime, endTime }\n    });\n    if (startTime >= endTime || !resType || !resSubType) return [];\n\n    let query = {\n      \"resourceType\": resType,\n      \"resourceSubType\": resSubType,\n      \"availStartTime\": { \"$lte\": startTime },\n      \"availEndTime\": { \"$gte\": endTime },\n      \"availableStatus\": true\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByIntervalByTypeSubType QUERY',\n      data: query\n    });\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByIntervalByTypeSubType RESP',\n      data: responsesArray\n    });\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0) {\n      let filterResp = await this._filterQueriedResources(responsesArray.body, startTime, endTime);\n      return filterResp;\n    } else {\n      return [];\n    }\n  }\n\n  async searchResourcesByIntervalByTypeSubTypeResId(resType, resSubType, resId, startTime, endTime) {\n\n    if (startTime >= endTime || !resType || !resSubType || !resId) return [];\n\n    let query = {\n      \"resourceType\": resType,\n      \"resourceSubType\": resSubType,\n      \"resourceId\": resId,\n      \"availStartTime\": { \"$lte\": startTime },\n      \"availEndTime\": { \"$gte\": endTime },\n      \"availableStatus\": true\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n\n    // this._state.developer.log({ message: 'From Schedules Class searchResourcesByInterval QUERY', data: query });\n\n    // let responsesArray = await this._state.db.getDataFromIndexWithQueryObject(Schedules.SCHD_INDEX(), queryObj);\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0) {\n      let filterResp = await this._filterQueriedResources(responsesArray.body, startTime, endTime);\n      return filterResp;\n    } else {\n      return [];\n    }\n  }\n\n  async searchResourcesByEventId(eventId) {\n\n    this._state.developer.log({ message: 'From Schedules, searchResourcesByEventId with', data: eventId });\n    if (!eventId || eventId === '') return [];\n\n    let query = {\n      \"eventId\": eventId\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n    this._state.developer.log({ message: 'From Schedules Class searchResourcesByEventId QUERY', data: query });\n\n    // let responsesArray = await this._state.db.getDataFromIndexWithQueryObject(Schedules.SCHD_INDEX(), queryObj);\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_DETAIL_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByEventId RESP',\n      data: responsesArray\n    });\n    // if (responsesArray && responsesArray.length > 0)\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0)\n      return responsesArray.body;\n    else\n      return [];\n  }\n\n  async searchResourcesByIds(idArrayIn) {\n\n    this._state.developer.log({ message: 'From Schedules, searchResourcesByIds with', data: idArrayIn });\n    if (!idArrayIn) return [];\n\n    let idArray;\n    if (Array.isArray(idArrayIn)) {\n      idArray = idArrayIn;\n    } else {\n      idArray = [idArrayIn];\n    }\n\n    if (idArray.length < 1) return [];\n\n    let query = {\n      \"resourceId\": { \"$in\": idArrayIn },\n      \"availableStatus\": true\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n\n    this._state.developer.log({ message: 'From Schedules Class searchResourcesByInterval QUERY', data: query });\n\n    // let responsesArray = await this._state.db.getDataFromIndexWithQueryObject(Schedules.SCHD_INDEX(), queryObj);\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_MASTER_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByIds RESP',\n      data: responsesArray\n    });\n    // if (responsesArray && responsesArray.length > 0)\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0)\n      return responsesArray.body;\n    else\n      return [];\n  }\n\n  async searchResourcesByResIdEventId(eventId, resId) {\n    this._state.developer.log({\n      message: 'From Schedules, searchResourcesByResIdEventId with',\n      data: { eventId, resId }\n    });\n    if (!eventId || eventId === '' || !resId || resId === '') return [];\n\n    let query = {\n      \"origId\": resId,\n      \"eventId\": eventId\n    }\n    let sort = {\n      \"availStartTime\": 1\n    }\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByResIdEventId QUERY',\n      data: query\n    });\n\n    // let responsesArray = await this._state.db.getDataFromIndexWithQueryObject(Schedules.SCHD_INDEX(), queryObj);\n    let responsesArray = await this._state.db.getDataFromCollection({\n      collection: Schedules.SCHD_DETAIL_DB(),\n      action: 'query',\n      query,\n      projection: {},\n      sort,\n      skip: 0,\n      limit: 999,\n      collation: {},\n      expectOneResult: false,\n      cache: false\n    });\n    this._state.developer.log({\n      message: 'From Schedules Class searchResourcesByResIdEventId RESP',\n      data: responsesArray\n    });\n    // if (responsesArray && responsesArray.length > 0)\n    //     return responsesArray;\n    if (responsesArray.statusCode === 200 && responsesArray.body && Array.isArray(responsesArray.body) && responsesArray.body.length > 0)\n      return responsesArray.body;\n    else\n      return [];\n  }\n\n  async getAvailableTimeSlots(resourceId, slotTime, startEpoch, endEpoch, scheduleIdArr) {\n    const state = this._state;\n    const _ = state._;\n    if (!resourceId || !slotTime || !startEpoch || !endEpoch) {\n      return [];\n    }\n    let takenSlots = await state.db.getDataFromCollection({\n      collection: Schedules.SCHD_DETAIL_DB(),\n      query: {\n        origId: resourceId,\n        bookedStartTime: { $gte: startEpoch },\n        bookedEndTime: { $lte: endEpoch }\n      },\n      projection: {\n        projection: { bookedStartTime: 1, bookedEndTime: 1 }\n      }\n    });\n    takenSlots = _.get(takenSlots, 'body', []);\n\n    let timeSlots = [];\n    while(endEpoch - startEpoch >= slotTime) {\n      let taken = false;\n      let endTime = startEpoch + slotTime;\n      _.forEach(takenSlots, e => {\n        // start time between a booked slot\n        let cantStart = e.bookedStartTime <= startEpoch && e.bookedEndTime > startEpoch;\n        // end time between a booked slot\n        let cantEnd = e.bookedStartTime < endTime && e.bookedEndTime > endTime;\n        // booked slot is included in new slot\n        let cantIncludes = startEpoch < e.bookedStartTime && endTime >= e.bookedEndTime\n        if (cantStart || cantEnd || cantIncludes) {\n          taken = true;\n          return;\n        }\n      });\n      if (!taken) {\n        timeSlots.push({start: startEpoch, end: startEpoch + slotTime })\n      }\n      startEpoch += slotTime;\n    }\n\n    return timeSlots;\n  }\n\n  async blockResource(resIdArrayIn, startTime, endTime, eventId) {\n    let resIdArray;\n    if (Array.isArray(resIdArrayIn)) {\n      resIdArray = resIdArrayIn;\n    } else {\n      resIdArray = [resIdArrayIn];\n    }\n\n    resIdArray = [...new Set(resIdArray)]; // get unique entries\n\n    if (startTime >= endTime || resIdArray.length < 1) return false;\n\n    let resultsArray = [];\n    for (let i = 0; i < resIdArray.length; i++) {\n      let currentID = resIdArray[i];\n      let resp = {};\n      // check once again for conflict before booking\n      let gotConflict = await this._checkConflictingBookings(currentID, startTime, endTime);\n      // this._state.developer.log({ message: 'From Schedules Class got conflict result', data: gotConflict });\n      if (gotConflict) {\n        resp[currentID] = undefined;\n        resultsArray.push(resp);\n        continue;\n      }\n      let newBooking = {};\n      newBooking._id = this._state.getUniqueId();  // this will be returned\n      newBooking.origId = currentID;\n      newBooking.bookedStartTime = startTime,\n        newBooking.bookedEndTime = endTime,\n        newBooking.eventId = eventId;\n      // this._state.developer.log({ message: 'From Schedules Class new bookings object result', data: newBooking });\n      let writeResp = await this._state.db.insertDocumentInCollection({\n        collection: Schedules.SCHD_DETAIL_DB(),\n        document: newBooking,\n        audit: false,\n        sync: false\n      });\n      // this._state.developer.log({ message: 'From Schedules Class new writeResp result', data: writeResp });\n      if (writeResp.statusCode === 200 && writeResp.body === 'success') {\n        // this._state.developer.log({ message: 'From Schedules Class blockResource success', data: writeResp });\n        resp[currentID] = newBooking._id;\n      } else {\n        // this._state.developer.log({ message: 'From Schedules Class blockResource ERROR', data: writeResp });\n        resp[currentID] = undefined;\n      }\n      resultsArray.push(resp);\n    }\n    return resultsArray;\n  }\n\n  async _internalUnblocker(resId) {\n\n    this._state.developer.log({ message: 'From Schedules, _internalUnblocker with', data: resId });\n    let query = {\n      _id: resId\n    };\n    let delResp = await this._state.db.deleteDataFromCollection({\n      collection: Schedules.SCHD_DETAIL_DB(),\n      query,\n      audit: false,\n      sync: false\n    });\n    if (delResp.statusCode === 200 && delResp.body === 'success') {\n      this._state.developer.log({ message: 'From Schedules Class _internalUnblocker success', data: delResp });\n      return { 'result': 'success', 'msg': 'Resource released' };\n    } else {\n      this._state.developer.log({ message: 'From Schedules Class _internalUnblocker ERROR', data: delResp });\n      return { 'result': 'error', 'msg': 'Resource was not released' };\n    }\n  }\n\n  async unBlockResource(resIdArrayIn) {\n\n    this._state.developer.log({ message: 'From Schedules, unBlockResource with', data: { resIdArrayIn } });\n    let resultsArray = [];\n    let resIdArray;\n    if (Array.isArray(resIdArrayIn)) {\n      resIdArray = resIdArrayIn;\n    } else {\n      resIdArray = [resIdArrayIn];\n    }\n\n    resIdArray = [...new Set(resIdArray)]; // get unique entries\n\n    if (resIdArray.length < 1) return false;\n    for (let i = 0; i < resIdArray.length; i++) {\n      let currentID = resIdArray[i];\n      let resp = {};\n      // resp[currentID] = await this._deleteAndStitch(currentID);\n      resp[currentID] = await this._internalUnblocker(currentID);\n      resultsArray.push(resp);\n    }\n    this._state.developer.log({ message: 'From Schedules, unBlockResource final', data: resultsArray });\n    return resultsArray;\n  }\n\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Schedules.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Security.js":
/*!*************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Security.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Security: function() { return /* binding */ Security; }\n/* harmony export */ });\nclass Security {\n  constructor(state) {\n    this._state = state;\n    this._ = state._;\n    this._frontmlib = state.frontmlib;\n  }\n\n  async createNewVerificationCode(role, customAction, numberOfLicenses, autoInstallBotIds, addCurrentConversationBot = true, allowAnonValidation = false) {\n    let verificationCode = this._state.UUID().substr(0, 10);\n    if (this._.isUndefined(autoInstallBotIds)) {\n      autoInstallBotIds = [];\n    }\n    if (!Array.isArray(autoInstallBotIds)) {\n      autoInstallBotIds = [autoInstallBotIds];\n    }\n    if (addCurrentConversationBot) autoInstallBotIds.push(this._state.conversation.bot);\n\n    let newCode = {\n      codeUsage: { existing: 0 },\n      domain: this._state.conversation.userDomain,\n      role: role,\n      verificationCode,\n      customAction,\n      botsToInstall: autoInstallBotIds,\n      allowAnonValidation\n    };\n    if (numberOfLicenses > 0) {\n      newCode.codeUsage.maximum = numberOfLicenses;\n    }\n    //console.log('New verification code being created', newCode);\n\n    try {\n      await this._frontmlib.dbPutItem('DomainVerification', newCode);\n      //console.log('Verification code created', newCode);\n      return verificationCode;\n    } catch (err) {\n      //console.log('Unable to create verification code', err);\n      return null;\n    }\n  }\n\n  async getVerificationCode(role) {\n    try {\n      let verificationCodeRow = await this._frontmlib.dbGetWithIndex(\n        'DomainVerification',\n        'domain-role-index',\n        '#domain = :domain AND #role = :role',\n        { ':domain': this._state.conversation.userDomain, ':role': role },\n        null,\n        { '#domain': 'domain', '#role': 'role' }\n      );\n      return verificationCodeRow.Items[0].verificationCode;\n    } catch (err) {\n      //console.log('Unable to get verification code', err);\n      return null;\n    }\n  }\n\n  async encryptData(data) {\n    try {\n      let key = await this._state.cc.getConfigurationForKey('encryptionKey');\n      return this._frontmlib.encryptData(key, data);\n    } catch (err) {\n      this._state.addSystemErrorToStack(31, err.message);\n    }\n  }\n\n  async decryptData(data) {\n    try {\n      return this._frontmlib.decryptData(data);\n    } catch (err) {\n      this._state.addSystemErrorToStack(32, err.message);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Security.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Sensors.js":
/*!************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Sensors.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sensors: function() { return /* binding */ Sensors; }\n/* harmony export */ });\nclass Sensors {\n  constructor(state) {\n    this._state = state;\n    this._ = state._;\n    this.R = state.R;\n  }\n\n  startMotionDetection(frequency) {\n    this._state.context\n      .getCapability('Accelerometer')\n      .startUpdates(this._state.context.botManifest.botId, this._state.conversationId, frequency);\n  }\n\n  stopMotionDetection() {\n    this._state.context\n      .getCapability('Accelerometer')\n      .stopUpdates(this._state.context.botManifest.botId, this._state.conversationId);\n  }\n}\n\nclass TrackingServices {\n  constructor(state) {\n    this._state = state;\n    this._ = state._;\n  }\n\n  startTracking() {\n    return this._state.context.getCapability('LocationTracker').start_tracking({\n      botId: this._state.context.botManifest.botId,\n      conversationId: this._state.conversationId,\n    });\n  }\n\n  stopTracking() {\n    return this._state.context.getCapability('LocationTracker').stop_tracking({\n      botId: this._state.context.botManifest.botId,\n      conversationId: this._state.conversationId,\n    });\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Sensors.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Sites.js":
/*!**********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Sites.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sites: function() { return /* binding */ Sites; }\n/* harmony export */ });\nclass Sites {\n  constructor(state) {\n    this['_state'] = state;\n    this['context'] = state.context;\n    this['userId'] = state.user.userId;\n    this['conversation'] = state.conversation;\n    this['_'] = state._;\n  }\n\n  getBaseParams() {\n    return {\n      capability: 'SitesCapability',\n      capabilityFileName: 'sitesCapability',\n      sync: true,\n      userId: this.userId,\n      conversation: this.conversation,\n    };\n  }\n\n  getSites() {\n    let params = this.getBaseParams();\n    params.action = 'GetUserSites';\n\n    return this._state.callCapability(params);\n  }\n\n  searchLocalSites(searchTerm, type) {\n    let params = this.getBaseParams();\n    params.action = 'SearchSites';\n    params.searchTerm = searchTerm;\n    params.siteType = type;\n\n    return this._state.callCapability(params);\n  }\n\n  searchGlobalSites(searchTerm, type, searchFields = ['IMO', 'MMSI']) {\n    let params = this.getBaseParams();\n    params.action = 'SearchGlobalSites';\n    params.searchTerm = searchTerm;\n    params.siteType = type;\n    params.searchFields = searchFields;\n\n    return this._state.callCapability(params);\n  }\n\n  deleteSite(site) {\n    let params = this.getBaseParams();\n    params.action = 'DeleteSite';\n    params.siteId = site.siteId;\n\n    return this._state.callCapability(params);\n  }\n\n  updateSite(site) {\n    let params = this.getBaseParams();\n    params.action = 'UpdateSite';\n    params.site = site;\n\n    return this._state.callCapability(params);\n  }\n\n  createSites(sites, type) {\n    let params = this.getBaseParams();\n    params.action = 'CreateSites';\n    params.sites = sites;\n    params.siteType = type;\n\n    return this._state.callCapability(params);\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Sites.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/State.js":
/*!**********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/State.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: function() { return /* binding */ D; },\n/* harmony export */   State: function() { return /* binding */ State; },\n/* harmony export */   _: function() { return /* binding */ _; },\n/* harmony export */   state: function() { return /* binding */ state; }\n/* harmony export */ });\n/* harmony import */ var _Developer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Developer */ \"../../Bitbucket/frontmjs/core/Developer.js\");\n/* harmony import */ var _Accounts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Accounts */ \"../../Bitbucket/frontmjs/core/Accounts.js\");\n/* harmony import */ var _Orders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Orders */ \"../../Bitbucket/frontmjs/core/Orders.js\");\n/* harmony import */ var _SFTP__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SFTP */ \"../../Bitbucket/frontmjs/core/SFTP.js\");\n/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Notification */ \"../../Bitbucket/frontmjs/core/Notification.js\");\n/* harmony import */ var _Marketplace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Marketplace */ \"../../Bitbucket/frontmjs/core/Marketplace.js\");\n/* harmony import */ var _JobScheduler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./JobScheduler */ \"../../Bitbucket/frontmjs/core/JobScheduler.js\");\n/* harmony import */ var _Contacts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Contacts */ \"../../Bitbucket/frontmjs/core/Contacts.js\");\n/* harmony import */ var _API__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./API */ \"../../Bitbucket/frontmjs/core/API.js\");\n/* harmony import */ var _DB__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DB */ \"../../Bitbucket/frontmjs/core/DB.js\");\n/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./File */ \"../../Bitbucket/frontmjs/core/File.js\");\n/* harmony import */ var _Sites__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Sites */ \"../../Bitbucket/frontmjs/core/Sites.js\");\n/* harmony import */ var _Sensors__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Sensors */ \"../../Bitbucket/frontmjs/core/Sensors.js\");\n/* harmony import */ var _LocationServices__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./LocationServices */ \"../../Bitbucket/frontmjs/core/LocationServices.js\");\n/* harmony import */ var _Security__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Security */ \"../../Bitbucket/frontmjs/core/Security.js\");\n/* harmony import */ var _NLP__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./NLP */ \"../../Bitbucket/frontmjs/core/NLP.js\");\n/* harmony import */ var _ContactCentre__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ContactCentre */ \"../../Bitbucket/frontmjs/core/ContactCentre.js\");\n/* harmony import */ var _Companies__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Companies */ \"../../Bitbucket/frontmjs/core/Companies.js\");\n/* harmony import */ var _Schedules__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Schedules */ \"../../Bitbucket/frontmjs/core/Schedules.js\");\n/* harmony import */ var _DeviceStorage__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./DeviceStorage */ \"../../Bitbucket/frontmjs/core/DeviceStorage.js\");\n/* harmony import */ var _Intent__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _MessageTypes__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./MessageTypes */ \"../../Bitbucket/frontmjs/core/MessageTypes.js\");\n/* harmony import */ var _Error__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./Error */ \"../../Bitbucket/frontmjs/core/Error.js\");\n/* harmony import */ var _Collection__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./Collection */ \"../../Bitbucket/frontmjs/core/Collection.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./Utils */ \"../../Bitbucket/frontmjs/core/Utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// import {Surveys} from \"./Surveys\";\n\n\n\n\n\n\n\n\nclass State {\n\n  static SOCKET_RECONNECTION_EVENT() {\n    return 'onSocketReconnection';\n  }\n\n  initStateProperties() {\n    this['_activeIntent'] = '';\n    this['_intentHistory'] = [];\n    this['_intentStats'] = {};\n    this['error'] = false;\n    this['errorStack'] = [];\n    this['responsesArray'] = [];\n    this['smartSuggestionsArray'] = [];\n    this.client = \"\";\n    this['_blockSuggestions'] = false;\n    this['toCustomCap'] = false;\n    this['_silentIntent'] = false;\n    this['intentResolved'] = false;\n    this['waitingCustomCap'] = 0;\n    this['location'] = {};\n    this['requestIdsArray'] = [];\n    this['context'] = null;\n    this['_'] = null;\n    this['R'] = null;\n    this['Immutable'] = null;\n    this['moment'] = null;\n    this['momentTimezone'] = null;\n    this['lastGreetingTime'] = 0;\n    this['lastUserActivity'] = 0;\n    this['MessageCapability'] = null;\n    this['fields'] = {};\n    this['sessionFields'] = {};\n    this['fieldsChanged'] = {};\n    this['fieldsCleared'] = [];\n    this['_oldFields'] = {};\n    this['currentWorkspace'] = '';\n    this['botId'] = \"\";\n    this['botName'] = \"\";\n    this['botDescription'] = \"\";\n    this['lastSession'] = Date.now();\n    this['amIOnline'] = true;\n    this['sendMessageParam'] = null;\n    this['disambiguate'] = false;\n    this['disambiguationNLPId'] = '';\n    this['_nlpResults'] = {};\n    this['_lastNLPResults'] = {};\n    this['_inputHistory'] = [];\n    this['_currentControlId'] = null;\n    this['fromGreeting'] = false;\n    this['_inSilence'] = false;\n    this['_routesQueue'] = {};\n    this['_dynamicIntents'] = {};\n    this._autoSavePresent = false;\n    this._syncToEdge = {};\n    this._syncToCloud = {};\n    this.autoSaveBuffer = {};\n    this.autoSaveBufferChanges = {};\n    this.duringBuild = false;\n    this._delayedNotification = [];\n    this.apiResponse = false;\n    this.messageTypeFromUser = \"\";\n    this.messageFromUser = \"\";\n    this.stateInitialized = false;\n    this.initializationErrorMessages = [];\n    this.osVersion = \"\";\n    this.brand = \"\";\n    this.phoneModel = \"\";\n    this.platform = \"\";\n    this.timeSensitiveMode = false;\n    this.userAgent = \"\";\n  }\n\n  constructor() {\n    this.initStateProperties();\n    this.user = {};\n    this.conversationId = \"\";\n    this.conversation = {};\n    this.lang = 'en';\n    this._conversational = true;\n    this._version = 4;\n    this._background = {\n      type: 0\n    };\n    this._sidebar = {\n      hidden: false,\n      frozen: false,\n    };\n    this._navbar = {\n      hidden: false,\n      frozen: false,\n    };\n    this.onlineRequired = false;\n    this._intents = {};\n    this['messageTypes'] = {};\n    this['logoutInProcess'] = false;\n    this['compatibilityMode'] = false;\n    this['waitingIcon'] = {};\n    this['_suggestionsLayout'] = 'horizontal';\n    this['chatButtonHidden'] = false;\n    this['_unitTestMode'] = false;\n    this['_cssFilePath'] = null;\n    this['_modal'] = false;\n    this.v1Compatibility = false;\n    this.appVersion = '';\n    this.autoResponse = false;\n    this.isRunning = false;\n    this._persistentState = true;\n    this._persistentOfflineData = true;\n    this._systemId = null;\n    if (!this.developer) this.developer = new _Developer__WEBPACK_IMPORTED_MODULE_0__.Developer(this);\n  }\n\n  init(message, conversation, user, location, stateFromStorage, context, args) {\n    this.initStateProperties();\n    this.ipDetails = conversation.ipDetails;\n    this.conversationId = conversation.conversationId;\n    this.conversation = conversation;\n    this.client = this.conversation.client;\n    this.responseToClient = this.client;\n    if (this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      this.osVersion = conversation?.OSVersion;\n      this.brand = conversation?.brand;\n      this.phoneModel = conversation?.model;\n      this.platform = conversation?.platform;\n    } else {\n      this.userAgent = conversation?.userAgent;\n    }\n    this.user = user;\n    this['location'] = location;\n    this.developer.init(this);\n    this.setContext(context);\n    if (!this['notification']) {\n      this['notification'] = new _Notification__WEBPACK_IMPORTED_MODULE_4__.Notification(this);\n      this['accounts'] = new _Accounts__WEBPACK_IMPORTED_MODULE_1__.Accounts(this);\n      this['orders'] = new _Orders__WEBPACK_IMPORTED_MODULE_2__.Orders(this);\n      this['sftp'] = location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD ? new _SFTP__WEBPACK_IMPORTED_MODULE_3__.SFTP(this) : {};\n      this['marketplace'] = new _Marketplace__WEBPACK_IMPORTED_MODULE_5__.Marketplace(this);\n      this['jobScheduler'] = new _JobScheduler__WEBPACK_IMPORTED_MODULE_6__.JobScheduler(this);\n      this['contacts'] = new _Contacts__WEBPACK_IMPORTED_MODULE_7__.Contacts(this);\n      this['api'] = new _API__WEBPACK_IMPORTED_MODULE_8__.API(this);\n      this['db'] = new _DB__WEBPACK_IMPORTED_MODULE_9__.DB(this);\n      this['file'] = location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD ? new _File__WEBPACK_IMPORTED_MODULE_10__.File(this) : {};\n      this['sites'] = new _Sites__WEBPACK_IMPORTED_MODULE_11__.Sites(this);\n      this['sensors'] = new _Sensors__WEBPACK_IMPORTED_MODULE_12__.Sensors(this);\n      this['locationServices'] = new _LocationServices__WEBPACK_IMPORTED_MODULE_13__.LocationServices(this);\n      this['security'] = new _Security__WEBPACK_IMPORTED_MODULE_14__.Security(this);\n      this['nlp'] = new _NLP__WEBPACK_IMPORTED_MODULE_15__.NLP(this);\n      this['cc'] = new _ContactCentre__WEBPACK_IMPORTED_MODULE_16__.ContactCentre(this);\n      this['companies'] = new _Companies__WEBPACK_IMPORTED_MODULE_17__.Companies(this);\n      this['schedules'] = new _Schedules__WEBPACK_IMPORTED_MODULE_18__.Schedules(this);\n      // this['surveys'] = new Surveys(this);\n    }\n    this.backendResponseType = 0; //1 -> State, 2 -> Sync, 0 -> Process as normal\n    // this['botId'] = this.conversation.bot || this._.get(this.context, 'botManifest.botId');\n    this.botId = this.conversation?.bot || this.context?.botManifest?.botId;\n    this.botName = this.context?.botManifest?.botName;\n    this.botDescription = this.context?.botManifest?.description;\n    if ((this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT || this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.EDGE_WEBCLIENT) && this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n      this['deviceStorage'] = new _DeviceStorage__WEBPACK_IMPORTED_MODULE_19__.DeviceStorage(this);\n    }\n    if (stateFromStorage) {\n      for (let propertyName in stateFromStorage) {\n        this[propertyName] = stateFromStorage[propertyName];\n      }\n    }\n    if (message) {\n      if (message.messageType) {\n        this['messageTypeFromUser'] = message.messageType;\n        this['messageFromUser'] = message.messageFromUser || '';\n      } else {\n        this['messageTypeFromUser'] = message.getMessageType();\n        this['messageFromUser'] = message.getMessage() || {};\n        if (this.messageTypeFromUser === this.messageTypes.MESSAGE_TYPE_STRING) {\n          // this['messageIdFromUser'] = message.getMessageId();\n          const getMessageContentType = message => {\n            const MessageTypeConstantsToInt = this.context.getCapability('MessageTypeConstantsToInt');\n            return MessageTypeConstantsToInt[message.getMessageType()] || 0;\n          };\n          this['messageTypeIntFromUser'] = getMessageContentType(message);\n          this['messageCreatedOnFromUser'] = message.getMessageDate().valueOf();\n          this['messageCreatedByFromUser'] = message.getCreatedBy();\n          let msgContent = message.getMessage();\n          let temp = JSON.stringify(msgContent);\n          temp = temp.replace(/\\\"\\\"/g, '\" \"');\n          msgContent = JSON.parse(temp);\n          this['messageContentFromUser'] = Array.isArray(msgContent) ? msgContent : [msgContent];\n          this['messageOptionsFromUser'] = message.getMessageOptions();\n        }\n      }\n      this._inputHistory.push({\n        type: JSON.stringify(this.messageTypeFromUser),\n        content: JSON.stringify(this.messageFromUser),\n      });\n      this._oldFields = this.fields;\n      if (this._inputHistory.length > 5) {\n        this._inputHistory.splice(0, 1);\n      }\n    }\n    this.autoResponse = this.messageTypeFromUser === State.SOCKET_RECONNECTION_EVENT();\n\n    if (this.messageFromUser && !this.messageFromUser.intentId) {\n      this.lastUserActivity = Date.now();\n    }\n    this.currentTabId = this._.get(this.messageFromUser, 'tabId');\n    if (this.onStart === undefined) {\n      this.onStart = async () => {};\n    }\n    this.defaultOnError = () => {\n      if (this.developer.runProfile !== _Developer__WEBPACK_IMPORTED_MODULE_0__.Developer.PROD()) {\n        this._.forEach(this.errorStack, error => {\n          if (error.errorCode === 40) {\n            this.addCriticalNotificationResponse(error.errorMessage)\n          } else {\n            this.addStringResponse(error.errorMessage)\n          }\n        });\n      } else {\n        this.addStringResponse('Requested information is currently unavailable. Please check back later');\n      }\n    };\n    this.stateInitialized = true;\n    this.resetOnErrorMethod();\n  }\n\n  // endMessageProcessing() {\n  //   this.actyiveWithMessage = false;\n  //   delete this.activeSinceTimestamp;\n  // }\n\n  runAllOnInits() {\n    this.developer.info({ message: \"Running onInits events\" });\n    this.initializationErrorMessages.forEach(message => {\n      D.warning({ message });\n    });\n    let allClosures = [];\n    Object.values(this._intents).forEach(intent => {\n      intent.resetProperties();\n      allClosures.push(intent.onInit(intent))\n    });\n    return Promise.all(allClosures);\n  }\n\n  set version(version) {\n    this._version = version;\n  }\n\n  callCapability(params) {\n    try {\n      let capabilities = this.context.capabilities.capabilities;\n      let capabilityDependencies = this.context.capabilities\n      if (!capabilities) {\n        capabilities = this.context.capabilities;\n        capabilityDependencies = this.context\n      }\n      let capFileName = params.capabilityFileName;\n      let capabilityModule = capabilities[capFileName];\n      if (capabilityModule) {\n        return capabilityModule.execute(params, capabilityDependencies);\n      }\n    } catch (err) {\n      this.addSystemErrorToStack(26, '4 ' + err.name + ': ' + err.message);\n    }\n  }\n\n  async callLambda(functionName, params, invocationType = 'RequestResponse') {\n    return this.frontmlib.invokeLambda(functionName, invocationType, params);\n  };\n\n  resetOnErrorMethod() {\n    this.clearError();\n    this._onError = this.defaultOnError;\n  }\n\n  get lastMainTimeStamp() {\n    return this.getField(_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.COMMON_FIELDS.LAST_MAIN_TIMESTAMP);\n  }\n\n  set onError(onErrorBlock) {\n    this._onError = onErrorBlock;\n  }\n\n  get onError() {\n    return this._onError;\n  }\n\n  get silentIntent() {\n    return this._silentIntent;\n  }\n\n  get activeIntent() {\n    return this._activeIntent;\n  }\n\n  getNlpResultsForId(nlpId) {\n    if (this._nlpResults) {\n      if (this._nlpResults[nlpId]) {\n        return this._nlpResults[nlpId];\n      }\n    }\n    return {};\n  }\n\n  async getStaticData(key, system, shared = false, encryptedValue = false) {\n    const KEY_VALUES = '_keyValues';\n    if (shared) {\n      key = `${key}_${this._systemId}`; \n    }\n\n    let query = {\n      key\n    };\n    let data = await this.db.getDataFromCollection({ collection: KEY_VALUES, query, cache: true, system, securedFields: encryptedValue ? ['value'] : null });\n    let response = this._.get(data, 'body[0].value');\n    if (!response) {\n      this.developer.warning({ message: \"Missing static data for key\", data: key })\n    }\n    return response\n  }\n\n  async getEncryptedStaticData(key, system, shared = false) {\n    return this.getStaticData(key, system, shared, true);\n  }\n  \n  async getSystemStaticData(key, shared = false) {\n    return this.getStaticData(key, true, shared);\n  }\n\n  async saveStaticData(key, value) {\n    const KEY_VALUES = '_keyValues';\n    let query = {\n      key\n    };\n    let document = {\n      value\n    }\n    await this.db.updateDataInCollection({\n      collection: KEY_VALUES,\n      document,\n      query,\n      cache: true\n    })\n  }\n\n  async recordActivity() {\n    if (this.activeIntent !== '' && !this.toCustomCap) {\n      let _ = this._;\n      let direction = _.size(this.responsesArray) === 0 ? 0 : 1; //0 = inbound message, 1 = outbound message\n      let messageFromUser = {\n        controlId: _.get(this.messageFromUser, \"controlId\"),\n        formId: _.get(this.messageFromUser, \"formId\"),\n        action: _.get(this.messageFromUser, \"action\"),\n        tableId: _.get(this.messageFromUser, \"tableId\"),\n        currentField: _.get(this.messageFromUser, \"currentField\"),\n        selectedEntry: _.get(this.messageFromUser, \"selectedEntry\"),\n        messageTypeFromUser: this.messageTypeFromUser\n      };\n      let document = {\n        botId: this.botId,\n        userId: this.user.userId,\n        botName: this.botName,\n        userEmail: this.user.userEmail,\n        timestamp: Date.now(),\n        intent: this.activeIntent,\n        migrated: false,\n        messageId: this.getUniqueId(),\n        domain: this.currentUserDomain,\n        messageFromUserMetadata: messageFromUser,\n        location: this.location,\n        client: this.client,\n        appVersion: this.appVersion,\n        //Add here the platform and all\n        osVersion: this.osVersion,\n        brand: this.brand,\n        phoneModel: this.phoneModel,\n        platform: this.platform,\n        userAgent: this.userAgent\n        //Analyse to have an object that can be added to the activity. This object can be handled only in backend and by a general definition\n      };\n      if (_.size(this.responsesArray) === 0) {\n        document.direction = 0;\n      } else {\n        document.direction = 1;\n        let responseMetadataArray = [];\n        _.forEach(this.responsesArray, response => {\n          let responseMetadata = {\n            type: _.get(response, \"type\"),\n            controlId: _.get(response, \"message.options.controlId\"),\n            action: _.get(response, \"message.options.action\")\n          };\n          responseMetadataArray.push(responseMetadata);\n        })\n        document.responsesArray = responseMetadataArray;\n      }\n      let query = {\n        messageId: document.messageId,\n        direction\n      }\n      let options = {\n        upsert: true // or 1\n      };\n      await this.db.updateDataInCollection({\n        collection: _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.ACTIVITY_COLLECTION,\n        document,\n        query,\n        options,\n        audit: false,\n        cache: false,\n        system: true,\n        asyncCall: true\n      });\n      await this.db.updateDataInCollection({\n        collection: _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.ACTIVITY_COLLECTION,\n        document,\n        query,\n        options,\n        audit: true,\n        cache: true,\n        asyncCall: true\n      });\n    }\n  }\n\n  get nlpResults() {\n    return this._nlpResults;\n  }\n\n  set nlpResults(nlpResults) {\n    this._nlpResults = nlpResults;\n  }\n\n  get previousActiveIntent() {\n    let l = this._intentHistory.length;\n    let r = '';\n    if (l > 1) {\n      if (this._activeIntent === '') {\n        r = this._intentHistory[l - 1];\n      } else {\n        r = this._intentHistory[l - 2];\n      }\n    } else {\n      if (l === 1) {\n        if (this._activeIntent === '') {\n          r = this._intentHistory[0];\n        }\n      }\n    }\n    return r;\n  }\n\n  online() {\n    if ((this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT || this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.EDGE_WEBCLIENT) && this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE && !this.v1Compatibility) {\n      try {\n        if (typeof this.context.getCapability('Network')?.isOnline === \"function\") {\n          return Promise.resolve(this.context.getCapability('Network').isOnline())\n        }\n        let network = this.context.getCapability('Network');\n        return network.isConnected().then(connected => {\n          return connected;\n        }).catch(() => {\n          return false\n        });\n      } catch (error) {\n        console.log('Error checking for online status ' + error.message)\n      }\n    } else {\n      return Promise.resolve(true);\n    }\n  }\n\n  async logout(appType) {\n    this['logoutInProcess'] = true;\n    try {\n      await this.context.getCapability('authContext').logout(this.context)\n      console.log(\"Logout executed\");\n      this.addResponse('silent', {});\n    } catch (error) {\n      console.log(\"Error during logout\");\n      console.log(JSON.stringify(error));\n    }\n  }\n\n  runLocationVerification(method, location) {\n    let locationPassed = location === this.location;\n    if (!locationPassed) {\n      this.addErrorToStack(1, 'Method ' + method + ' cannot run on the ' + this.location);\n    }\n    return locationPassed;\n  }\n\n  getUserRolesForDomain(domain) {\n    for (const domainObject of this.userDomains) {\n      if (domainObject.domain === domain) {\n        return domainObject.roles\n      }\n    }\n  }\n\n  setContext(context) {\n    this.context = context;\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n      this['userName'] = this.user.info.userName;\n      this.user.userName = this.user.info.userName;\n      const utils = this.context.getCapability('Utils');\n      this._ = utils.Lodash;\n      this.R = this.context.getCapability('R') || {};\n      this.immutable = this.context.getCapability('Immutable') || {};\n      //this.UUID = utils.UUID;\n      this.messageTypes = this.context.getCapability('MessageTypeConstants');\n      this.MessageCapability = this.context.getCapability('Message');\n      this.userDomains = this.user.info.domains;\n      this.moment = this.context.getCapability('Moment');\n      this.momentTimezone = this.context.getCapability('MomentTimezone');\n      if (this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT) {\n        this.aws = this.context.getCapability('aws');\n        this.frontmlib = this.context.getCapability('frontmlib');\n        let capabilities = this.context.capabilities.capabilities;\n        if (capabilities) {\n          this.sha1 = this.context.capabilities.sha1;\n        } else {\n          this.sha1 = this.context.sha1;\n        }\n      } else {\n        this.sha1 = this.context.getCapability('sha1');\n      }\n      this.currentWorkspace = this.user.info.lastLoggedInDomain;\n    } else {\n      this._ = this.context._;\n      this.R = this.context.R || {};\n      this.immutable = this.context.immutable || {};\n      this.userDomains = this.user.userDomains;\n      this.moment = this.context.moment;\n      this.momentTimezone = this.context['momentTimeZone'];\n      this.aws = this.context['aws'];\n      this.frontmlib = this.context['frontmlib'];\n      this.sha1 = this.context['sha1'];\n      this.marked = this.context[\"marked\"];\n    }\n    this.user.roles = this.getUserRolesForDomain(this.currentUserDomain);\n    this.systemId = this.context?.botManifest?.systemId || null;\n    this.developer.runProfile = this.context?.botManifest?.buildType || _Developer__WEBPACK_IMPORTED_MODULE_0__.Developer.DEV();\n  }\n\n  syncWithBackendState(state) {\n    let _ = this._;\n    if (this.messageTypeFromUser === _MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.BACKEND_RESPONSE()) {\n      //console.log(JSON.stringify(state));\n      if (state.intentResolved) {\n        this.intentResolved = state.intentResolved;\n      }\n      if (state.responsesArray) {\n        _.each(state.responsesArray, response => {\n          if (response.type === 'form2') {\n            let form = {};\n            form.options = response.message.options;\n            form.fields = response.message.fields;\n            this.addResponse('form2', form);\n          } else {\n            this.responsesArray.push(response);\n          }\n        });\n      }\n      if (state._activeIntent) {\n        this.addActiveIntent(state._activeIntent);\n      }\n      if (state._silentIntent) {\n        this._silentIntent = true;\n      }\n      if (state.nlpResponse) {\n        this.nlpResponse = state.nlpResponse;\n      }\n      if (state._nlpResults) {\n        this._nlpResults = state._nlpResults;\n        this._lastNLPResults = state._nlpResults;\n      }\n      if (state.errorStack) {\n        _.each(state.errorStack, error => {\n          this.addErrorToStack(error._errorCode, error._errorMessage);\n        });\n      }\n      if (state.smartSuggestionsArray) {\n        this.smartSuggestionsArray = state.smartSuggestionsArray;\n      }\n      if (_.size(state.fieldsChanged)) {\n        this.fields = this.R.merge(this.fields, state.fieldsChanged);\n      }\n      if (state.fieldsCleared && Array.isArray(state.fieldsCleared) && state.fieldsCleared.length > 0) {\n        _.forEach(state.fieldsCleared, field => {\n          delete this.fields[field]\n        })\n      }\n      //this.fields = state.fields;\n      if (state.sendMessageParam) {\n        this.sendMessageParam = state.sendMessageParam;\n      }\n      if (state._blockSuggestions) {\n        this.blockSuggestions = true;\n      }\n      if (Array.isArray(state.requestIdsArray)) {\n        this.requestIdsArray = this.requestIdsArray.concat(state.requestIdsArray);\n      }\n      if (state._intentDurations) {\n        this._intentDurations = state._intentDurations;\n      }\n      if (typeof state._conversational === 'boolean') {\n        this._conversational = state._conversational;\n      }\n      if (state._background) {\n        this._background = state._background;\n      }\n      if (state._sidebar) {\n        this._sidebar = state._sidebar;\n      }\n      if (state._navbar) {\n        this._navbar = state._navbar;\n      }\n      if (state.fromGreeting) {\n        this.fromGreeting = state.fromGreeting;\n      }\n      if (state._inSilence) {\n        this._inSilence = state._inSilence;\n      }\n      if (state.currentTabId) {\n        this.currentTabId = state.currentTabId;\n      }\n      if (_.size(state._dynamicIntents) > 0) {\n        this._dynamicIntents = state._dynamicIntents;\n      }\n      this._syncToEdge = state._syncToEdge\n      this.autoSaveBufferChanges = state.autoSaveBufferChanges;\n      if (state.backendResponseType) {\n        this.backendResponseType = state.backendResponseType;\n      }\n      this.responseToClient = state.responseToClient;\n    }\n  }\n\n  getNewRequestId() {\n    return this.getUniqueId;\n  }\n\n  getAllProperties() {\n    let _ = this._;\n    let response = {\n      conversationId: this['conversationId'],\n      toCustomCap: this['toCustomCap'],\n      intentResolved: this['intentResolved'],\n      waitingCustomCap: this['waitingCustomCap'],\n      lastGreetingTime: this['lastGreetingTime'],\n      lastUserActivity: this['lastUserActivity'],\n      _intentDurations: this['_intentDurations'],\n    };\n    response.errorStack = this['errorStack'];\n    response.requestIdsArray = this['requestIdsArray'];\n    response.fields = this.fields;\n    response._silentIntent = this._silentIntent;\n    response._lastNLPResults = this._lastNLPResults;\n    response._background = this._background;\n    response._conversational = this._conversational;\n    response._sidebar = this._sidebar;\n    response._inputHistory = this._inputHistory;\n    response._routesQueue = this._routesQueue;\n    if (this.developer._debugMode) {\n      response._debugMode = true;\n    }\n    response._intentHistory = this._intentHistory;\n    response.fromGreeting = this.fromGreeting;\n    response._inSilence = this._inSilence;\n    if (_.size(this._dynamicIntents) > 0) {\n      response._dynamicIntents = this._dynamicIntents;\n    }\n    response._delayedNotification = _.clone(this._delayedNotification) || [];\n    response._syncToCloud = _.clone(this._syncToCloud);\n    response.autoSaveBufferChanges = this.autoSaveBufferChanges;\n    return response;\n  }\n\n  get autoSaveBufferKey() {\n    if (this.currentTabId) {\n      return `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.AUTO_SAVE_BUFFER_FIELD}_${this.currentTabId}`;\n    } else {\n      return _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.AUTO_SAVE_BUFFER_FIELD;\n\n    }\n  }\n\n  loadAutoSaveBuffer() {\n    let _ = this._;\n    let D = this.developer;\n    return this.getPersistedField(this.autoSaveBufferKey).then(value => {\n      if (value) {\n        _.forEach(_.keys(value), key => {\n          this.autoSaveBuffer[key] = value[key]\n        });\n      }\n    })\n  }\n\n  storeAutoSaveBuffer() {\n    if (this.autoSaveBuffer) {\n      return this.setPersistedField(this.autoSaveBufferKey, this.autoSaveBuffer)\n    }\n  }\n\n  clearAutoSaveBuffer() {\n    this.autoSaveBuffer = {};\n  }\n\n  clearAutoSaveBufferChanges() {\n    this.autoSaveBufferChanges = {};\n  }\n\n  async resetAutoSaveBuffer() {\n    await this.clearPersistedField(this.autoSaveBufferKey)\n  }\n\n  addObjectToSyncMessage(collection, primaryKey, object) {\n    let key = this.sha1(primaryKey);\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD) {\n      let doc = this._syncToEdge[collection] || {};\n      doc[key] = object;\n      this._syncToEdge[collection] = doc;\n    } else {\n      let doc = this._syncToCloud[collection] || {};\n      doc[key] = object;\n      this._syncToCloud[collection] = doc;\n    }\n  }\n\n  addDelayedNotification(notificationParams) {\n    if (Array.isArray(this._delayedNotification)) {\n      this._delayedNotification.push(notificationParams)\n    } else {\n      this._delayedNotification = [notificationParams]\n    }\n  }\n\n  syncDataToDB() {\n    let _ = this._;\n    if (this.client !== _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT) {\n      let allPromises = [];\n      _.forEach(this._syncToCloud, (document, collection) => {\n        //D.log({message: 'Found document for', data: collection});\n        let collectionObject = this._intents[collection];\n        if (collectionObject || collection === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_STORAGE) {\n          _.forEach(document, (record, key) => {\n            if (collection === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_STORAGE) {\n              allPromises.push(this.db.setOneValueInCacheWithExpiry(key, record, 3600 * 24 * 7).catch(error => {\n                this.addSystemErrorToStack(42, '', error);\n              }));\n            } else {\n              let docArray = _.get(record, 'body');\n              _.forEach(docArray, doc => {\n                let newDoc = collectionObject.document;\n                if (newDoc.hasSubDocs) {\n                  newDoc.buildDocumentFromContainer(doc)\n                } else {\n                  newDoc.buildDocument(doc)\n                }\n                allPromises.push(newDoc.save(true).catch(error => {\n                  this.addSystemErrorToStack(42, '', error);\n                }));\n              })\n            }\n          })\n        }\n      })\n      if (allPromises.length > 0) {\n        return Promise.all(allPromises).then(() => {\n          //D.log({message: 'All saved'});\n          this._syncToCloud = {};\n        }).catch(error => {\n          this.addSystemErrorToStack(42, '', error);\n        })\n      } else {\n        //D.log({message: 'Nothing to sync'});\n        return Promise.resolve()\n      }\n    }\n  }\n\n  sendDelayedNotifications() {\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD && !(this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT)) {\n      let promisesArray = [];\n      this._.forEach(this._delayedNotification, notification => {\n        //console.log('Notifications ' + JSON.stringify(notification));\n        if (notification.userDomain === 'aagehempel' || notification.userDomain === 'aagehempeltest') {\n          //console.log('AHG sendDelayedNotifications ' + JSON.stringify(notification));\n          this.developer.log({ message: 'AHG sendDelayedNotifications', data: JSON.stringify(notification) });\n        }\n        promisesArray.push(this.notification.sendDelayedNotification(notification));\n      })\n      this._delayedNotification = [];\n      if (promisesArray.length > 0) {\n        return Promise.all(promisesArray);\n      } else {\n        return Promise.resolve()\n      }\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  removeObjectFromSyncMessage(collection, primaryKey) {\n    let key = this.sha1(primaryKey);\n    //let key = primaryKey;\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD) {\n      delete this._syncToEdge[collection][key];\n    } else {\n      delete this._syncToCloud[collection][key];\n    }\n  }\n\n  runFunctionOnceAnHour(functionBlock) {\n    let _ = this._;\n    let latestTime = _.now();\n    if (_.toNumber(latestTime) - _.toNumber(this.lastGreetingTime) > 3600000) {\n      this.lastGreetingTime = latestTime;\n      return functionBlock();\n    }\n  }\n\n  runFunctionOnceADay(functionBlock) {\n    let _ = this._;\n    let latestTime = _.now();\n    if (_.toNumber(latestTime) - _.toNumber(this.lastGreetingTime) > 86400000) {\n      this.lastGreetingTime = latestTime;\n      return functionBlock();\n    }\n  }\n\n  getDeviceLocation() {\n    return this.context.getCapability('DeviceLocation').getDeviceLocation();\n  }\n\n  sendMessage(message) {\n    ////console.log('============> setting send  message param');\n    this.developer.log({ message: 'User sending message with ' + JSON.stringify(message) });\n    this.sendMessageParam = message;\n  }\n\n  continueInIntentWithIdAndMessage(intentId, message) {\n    let object = {\n      intentId: intentId,\n    };\n    this.sendMessage({\n      ...object,\n      ...message\n    })\n  }\n\n  processIntentWithIdAndMessage(intentId, message) {\n    this.continueInIntentWithIdAndMessage(intentId, message)\n  }\n\n  processIntentWithId(intentId) {\n    let object = {\n      intentId: intentId,\n    };\n    this.sendMessage(object);\n  }\n\n  cleanFieldsForSave(fields) {\n    let _ = this._;\n    let cleanFields = {};\n    if (typeof fields === 'string') {\n      if (fields === '') {\n        fields = ' '; //Before it was null. Testing a space\n      }\n      return fields;\n    } else if (typeof fields === 'object') {\n      if (Array.isArray(fields)) {\n        let newArray = [];\n        _.each(fields, entry => {\n          let newEntry = this.cleanFieldsForSave(entry);\n          newArray.push(newEntry);\n        });\n        return newArray;\n      } else {\n        for (let properyName in fields) {\n          let theField = fields[properyName];\n          switch (typeof theField) {\n            case 'string': {\n              cleanFields[properyName] = this.cleanFieldsForSave(theField);\n              break;\n            }\n            case 'object': {\n              cleanFields[properyName] = this.cleanFieldsForSave(theField);\n              break;\n            }\n            default: {\n              cleanFields[properyName] = theField;\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      return fields;\n    }\n    return cleanFields;\n  }\n\n  save(deviceStorageUtil) {\n    if (this._persistentState) {\n      this.fields = this.cleanFieldsForSave(this.fields);\n      this._lastNLPResults = this.cleanFieldsForSave(this._lastNLPResults);\n      return deviceStorageUtil\n        .setInContext(this.getAllProperties(), this.context)\n        .then(() => {\n          //console.log('State Saved');\n          this.developer.info({ message: 'State saved' });\n          this.error = false;\n        })\n        .catch(err => {\n          //console.log('State not Saved ' + err.message);\n          this.developer.info({ message: `Error saving the state: ${err.message}` });\n          this.error = true;\n        });\n    }\n  }\n\n  getUniqueId() {\n\n    try {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\n        /[xy]/g,\n        function (match) {\n          let randomNibble = Math.random() * 16 | 0;\n          let nibble = (match === 'y') ?\n            (randomNibble & 0x3 | 0x8) :\n            randomNibble;\n          return nibble.toString(16);\n        }\n      );\n    } catch (error) {\n      console.log(\"Error generating UUID\");\n      console.log(JSON.stringify(error));\n    }\n  }\n\n  setField(fieldName, fieldValue) {\n    this.fields[fieldName] = fieldValue;\n    this.fieldsChanged[fieldName] = fieldValue;\n    let index = this.fieldsCleared.indexOf(fieldName);\n    if (index > -1) {\n      this.fieldsCleared.splice(index, 1);\n    }\n  }\n\n  commonSetFieldLogic(key, fieldValue, expire) {\n    this.addObjectToSyncMessage(_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_STORAGE, key, fieldValue);\n    let redisKey = this.sha1(key);\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD || this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE && this.v1Compatibility)) {\n      let redisExpire = expire || 3600 * 24 * 7;\n      return this.db.setOneValueInCacheWithExpiry(redisKey, fieldValue, redisExpire);\n    } else {\n      //console.log('Storing locally 2nd layer ' + key);\n      return this.deviceStorage.saveKeyInStorage(redisKey, fieldValue);\n    }\n  }\n\n  async commonGetFieldLogic(key) {\n    //console.log('Reading encrypted key ' + key);\n    let _ = this._;\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD || this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE && this.v1Compatibility)) {\n      let result = await this.db.getValueFromCache(key);\n      if (result) {\n        try {\n          return JSON.parse(_.get(result, 'content'))\n        } catch (error) {\n          // this.addSystemErrorToStack(39, null, error.message);\n          // this.developer.log({message: 'Data from Redis', data: result});\n          return _.get(result, 'content')\n        }\n      }\n    } else {\n      let response = await this.deviceStorage.getKeyFromStorage(key);\n      //console.log('Key from storage 2nd layer ' + key);\n      ////console.log(`${ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}${this.conversationId}_${fieldName})`);\n      //console.log('Response from storage 2nd layer ' + response);\n      return response\n    }\n  }\n\n  async commonClearFieldLogic(key) {\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD || this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE && this.v1Compatibility)) {\n      await this.db.deleteOneKeyInCache(key)\n      //await this.db.deleteOneKeyInCache(redisKey)\n    } else {\n      await this.deviceStorage.removeKeyFromStorage(key)\n      //await this.deviceStorage.removeKeyFromStorage(redisKey)\n    }\n  }\n\n  setSharedField(fieldName, fieldValue, expire) {\n    let key = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}_${fieldName}`;\n    return this.commonSetFieldLogic(key, fieldValue, expire);\n  }\n\n  getSharedField(fieldName) {\n    let key = this.sha1(`${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}_${fieldName}`);\n    return this.commonGetFieldLogic(key);\n  }\n\n  clearSharedField(fieldName) {\n    let key = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}_${fieldName}`;\n    return this.commonClearFieldLogic(this.sha1(key));\n  }\n\n  setPersistedField(fieldName, fieldValue) {\n    let key = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}${this.conversationId}_${fieldName}`;\n    let expire = 3600 * 24 * 7;\n    return this.commonSetFieldLogic(key, fieldValue, expire);\n  }\n\n  getPersistedField(fieldName) {\n    let key = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}${this.conversationId}_${fieldName}`;\n    return this.commonGetFieldLogic(this.sha1(key));\n  }\n\n  clearPersistedField(fieldName) {\n    let key = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}${this.conversationId}_${fieldName}`;\n    return this.commonClearFieldLogic(this.sha1(key));\n  }\n\n  async getPersistedFields(fieldNames) {\n    let _ = this._;\n    if (Array.isArray(fieldNames)) {\n      let keysArray = [];\n      let response = {};\n      if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD || this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT || (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE && this.v1Compatibility)) {\n        for (let i = 0; i < fieldNames.length; i++) {\n          let redisKey = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}${this.conversationId}_${fieldNames[i]}`;\n          keysArray.push(this.sha1(redisKey))\n        }\n        let responseFromCache = await this.db.getMultipleValuesFromCache(keysArray);\n        this.developer.log({ message: 'Content from Redis', data: responseFromCache });\n        if (responseFromCache) {\n          _.forEach(keysArray, key => {\n            let payload = responseFromCache[key];\n            if (payload) {\n              try {\n                let field = '';\n                let i = _.findIndex(fieldNames, fieldName => {\n                  let redisKey = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}${this.conversationId}_${fieldName}`;\n                  field = fieldName;\n                  return key === this.sha1(redisKey)\n                })\n                if (i !== -1) {\n                  response[field] = JSON.parse(_.get(payload, 'content'))\n                }\n              } catch (error) {\n                this.addSystemErrorToStack(39, null, error.message);\n                this.developer.log({ message: 'Data from Redis', data: _.get(payload, 'content') });\n              }\n            }\n          });\n        }\n      } else {\n        for (let i = 0; i < fieldNames.length; i++) {\n          let redisKey = `${_ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.PERSISTED_FIELD_PREFIX}${this.conversationId}_${fieldNames[i]}`;\n          let value = await this.deviceStorage.getKeyFromStorage(this.sha1(redisKey));\n          if (value) response[fieldNames[i]] = value;\n        }\n      }\n      return response\n    } else {\n      this.addSystemErrorToStack(7, 'getPersistedFields: fieldNames parameter must be an array')\n      return null\n    }\n  }\n\n  clearField(fieldName) {\n    delete this.fields[fieldName];\n    this.fieldsCleared.push(fieldName);\n  }\n\n  getField(fieldName) {\n    let field = this.fields[fieldName];\n    if (typeof field !== 'undefined') {\n      return field;\n    } else {\n      return null;\n    }\n  }\n\n  hasFieldInPath(path) {\n    return !!this.R.path(path, this.fields);\n  }\n\n  addSmartSuggestions(newSmartSuggestion) {\n    this.smartSuggestionsArray.push(newSmartSuggestion);\n  }\n\n  addSmartSuggestionsArray(newSmartSuggestions) {\n    this.developer.log({ message: 'Adding smart suggestions', data: newSmartSuggestions });\n    let _ = this._;\n    _.each(newSmartSuggestions, suggestionObject => {\n      if (suggestionObject.lang === this.lang) {\n        this.smartSuggestionsArray = this.smartSuggestionsArray.concat(suggestionObject.list);\n      }\n    });\n  }\n\n  addEnglishSmartSuggestions(newSmartSuggestions) {\n    let smartSuggestionsArray = [\n      {\n        lang: 'en',\n        list: newSmartSuggestions,\n      },\n    ];\n    this.addSmartSuggestionsArray(smartSuggestionsArray);\n  }\n\n  set blockSuggestions(flag) {\n    this._blockSuggestions = flag;\n  }\n\n  get blockSuggestions() {\n    return this._blockSuggestions;\n  }\n\n  clearSmartSuggestionsArray() {\n    //console.log('Clearing Suggestions');\n    this.smartSuggestionsArray = [];\n    this._blockSuggestions = false;\n  }\n\n  addActiveIntent(intentId, logHistory = true, silent = false) {\n    this._silentIntent = silent;\n    let cutIn10 = () => {\n      if (this._intentHistory.length > 10) {\n        this._intentHistory.splice(0, 1);\n        cutIn10();\n      }\n    };\n    this._activeIntent = intentId;\n    if (logHistory) {\n      this._intentHistory.push(intentId);\n    }\n    cutIn10();\n  }\n\n  removeActiveIntent() {\n    if (this._activeIntent !== '') {\n      this._activeIntent = '';\n    }\n  }\n\n  addSystemErrorToStack(code, message, data) {\n    let errorObject = new _Error__WEBPACK_IMPORTED_MODULE_23__.Error(this, code, message);\n    // console.log(\"######### Search for this\");\n    // console.log(\"######### message from code: \" + errorObject.errorMessage);\n    // console.log(\"######### message: \" + message);\n    // console.log(\"######### data: \" + JSON.stringify(data));\n    //this.developer.log(errorObject.errorMessage, LogEntrytype.SYSTEM_ERROR());\n    this.developer.systemError({ message: errorObject.errorMessage, errorCode: code, data });\n    this.errorStack.push(errorObject);\n  }\n\n  addErrorToStack(code, message, data) {\n    let errorObject = {};\n    if (code < 999) {\n      errorObject = new _Error__WEBPACK_IMPORTED_MODULE_23__.Error(this, 1000, message);\n    } else {\n      errorObject = new _Error__WEBPACK_IMPORTED_MODULE_23__.Error(this, code, message);\n    }\n    //this.developer.log(errorObject.errorMessage, LogEntrytype.USER_ERROR());\n    this.developer.userError({ message: errorObject.errorMessage, errorCode: code, data });\n    this.errorStack.push(errorObject);\n  }\n\n  get inError() {\n    return this._.size(this.errorStack) > 0;\n  }\n\n  clearError() {\n    this.errorStack = [];\n  }\n\n  addStringResponse(message) {\n    this.addResponse('string', message);\n  }\n\n  addStandardNotificationResponse(message) {\n    this.addResponse('standard_notification', message);\n  }\n\n  addCriticalNotificationResponse(message) {\n    this.addResponse('critical_notification', message);\n  }\n\n  addAuthorizationRequestResponse(message) {\n    this.addResponse('authorization_request', message);\n  }\n\n  addFormResponse(message) {\n    this.addResponse('form2', message);\n  }\n\n  addShortFormResponse(message) {\n    this.addResponse(_MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.SHORT_FORM_RESPONSE(), message);\n  }\n\n  addFormChangeResponse(message) {\n    this.addResponse('form_live_changes', message);\n  }\n\n  addInLineFormChangeResponse(message) {\n    this.addResponse('table_live_changes', message);\n  }\n\n  addMapResponse(message) {\n    this.addResponse('map', message);\n  }\n\n  addChartResponse(message) {\n    this.addResponse('chart', message);\n  }\n\n  addTableResponse(message) {\n    this.addResponse('table', message);\n  }\n\n  addShortTableResponse(message) {\n    this.addResponse(_MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.SHORT_TABLE_RESPONSE(), message);\n  }\n\n  addTrackingViewResponse(message) {\n    this.addResponse('trackerForm', message);\n  }\n\n  addCardsResponse(message) {\n    this.addResponse('cards', message);\n  }\n\n  addHTMLResponse(message) {\n    this.addResponse('html', { message: {}, options: message });\n  }\n\n  addContainerResponse(message) {\n    this.addResponse('container', message);\n  }\n\n  addVideoCallResponse(message) {\n    this.addResponse('videoCall', message);\n  }\n\n  addVoiceCallResponse(message) {\n    this.addResponse(_MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.MESSAGE_VOICE_CALL(), message);\n  }\n\n  addMenuResponse(message) {\n    this.addResponse('menuMessage', message);\n  }\n\n  addTimelinesResponse(message) {\n    this.addResponse(_MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.MESSAGE_TYPE_TIMELINE_LIST(), message);\n  }\n\n  addTimelinePostResponse(message) {\n    this.addResponse(_MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.MESSAGE_TYPE_TIMELINE_POST(), message);\n  }\n\n  addSoundResponse(message) {\n    let soundMessage = message;\n    if (!message) {\n      soundMessage = {\n        sound: 'FrontM_Ring.mp3',\n      };\n    }\n    this.addResponse('sound', soundMessage);\n  }\n\n  addCsvResponse(message) {\n    this.addResponse('csv', message);\n  }\n\n  addSurveyResponse(message) {\n    this.addResponse(_MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.MESSAGE_TYPE_SURVEY(), message);\n  }\n\n  addDashboardResponse(message) {\n    this.addResponse(_MessageTypes__WEBPACK_IMPORTED_MODULE_22__.MessageTypes.DASHBOARD(), message);\n  }\n\n  addTCPResponse(message, targetIp, targetPort) {\n    // targetIp and targetPort must be deleted after testing with terminal\n    if (this.client !== _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n      let msg = 'Message type not supported on this client';\n      this.addSystemErrorToStack(5, msg);\n      return;\n    }\n    const tcpCapability = this.context.getCapability('TCP');\n    let payload = {\n      dest_ip: targetIp,\n      dest_port: targetPort,\n      msg: message\n    }\n    tcpCapability.sendMessage(payload);\n  }\n\n  addRunModeResponse() {\n    if (this.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT && !this.v1Compatibility) {\n      return\n    }\n    let runModeMessage = {\n      background: this.background,\n      sidebar: this.sidebar,\n      navbar: this.navbar,\n      chatButtonHidden: this.chatButtonHidden,\n      waitingIcon: this._waitingIcon,\n      cssFilePath: this._cssFilePath,\n      suggestionsLayout: this._suggestionsLayout,\n      modal: this._modal\n    };\n    let Message = this.context.getCapability('Message');\n    let message = new Message();\n    message.runMode(runModeMessage);\n    this.context.tell(message);\n  }\n\n  addStringResponseFromArray(messages) {\n    let error = false;\n    if (Array.isArray(messages)) {\n      let index = Math.round(Math.random() * (messages.length - 1));\n      let message = messages[index];\n      if (typeof message === 'string') {\n        this.addResponse('string', message);\n      } else {\n        error = true;\n      }\n    } else {\n      error = true;\n    }\n    if (error) {\n      this.addErrorToStack(23, _Error__WEBPACK_IMPORTED_MODULE_23__.Error.getErrorMessageforCodeAndLang(23, this.lang));\n    }\n  }\n\n  addSilentResponse() {\n    this.developer.info({ message: 'Adding Silent response' });\n    this.addResponse('silent', {});\n  }\n\n  addResponse(type, message) {\n    //this.developer.debug({message: 'Will add response ', data: message});\n    if (this.developer.runProfile) {\n      if (type === 'string') {\n        this.developer.info({ message: 'Added response ' + message });\n      } else {\n        this.developer.info({ message: 'Added message type ' + type });\n      }\n    }\n    //this.developer.debug({message: 'Will add response 2', data: type});\n    if (message) {\n      if (message.options) {\n        if (this.currentControlId !== null) {\n          message.options['parentControlId'] = this.currentControlId;\n        }\n        if (this.currentTabId) {\n          message.options.tabId = this.currentTabId;\n        }\n        if (!message.options.controlId) {\n          message.options.controlId = this.getUniqueId();\n        }\n      } else {\n        if (message.tabId && this.currentTabId) {\n          message.tabId = this.currentTabId;\n        }\n      }\n      this.responsesArray.push({\n        type: type,\n        message: message,\n        messageId: this.getUniqueId()\n      });\n      //this.developer.debug({message: 'Added response'});\n    } else {\n      this.addSystemErrorToStack(14, type);\n    }\n  }\n\n  clearRoutesQueue() {\n    this._routesQueue = {};\n  }\n\n  clearResponseArray() {\n    this.responsesArray = [];\n  }\n\n  setWaitingCustomCap() {\n    if (!this.silentIntent) {\n      this.waitingCustomCap += 1;\n    }\n  }\n\n  resetWaitingForCustomCapCounter() {\n    this.waitingCustomCap = 0;\n  }\n\n  addRequestId(requestId) {\n    this.requestIdsArray.unshift(requestId);\n    if (this.requestIdsArray.length > 10) {\n      this.requestIdsArray.pop();\n    }\n  }\n\n  markRequestIdProcessed(requestId) {\n    let indexOfRequestId = this.requestIdsArray.indexOf(requestId);\n    if (indexOfRequestId === -1) {\n      this.addRequestId(requestId);\n      ////console.log('Adding requestId');\n      //this.requestIdsArray.splice(indexOfRequestId, 1);\n      if (this.waitingCustomCap > 0) {\n        this.waitingCustomCap -= 1;\n      }\n      return true;\n    } else {\n      ////console.log('did not find requestId');\n      return false;\n    }\n  }\n\n  stateToBackEnd() {\n    let _ = this._;\n    let stateToBackend = {\n      lang: this.lang,\n      intentResolved: this.intentResolved,\n      messageTypeFromUser: this.messageTypeFromUser,\n      messageFromUser: this.messageFromUser,\n      messageIdFromUser: this.messageIdFromUser,\n      messageTypeIntFromUser: this.messageTypeIntFromUser,\n      messageCreatedOnFromUser: this.messageCreatedOnFromUser,\n      messageCreatedByFromUser: this.messageCreatedByFromUser,\n      messageContentFromUser: this.messageContentFromUser,\n      messageOptionsFromUser: this.messageOptionsFromUser,\n      userName: this.userName,\n      tz: this.user.tz,\n      fields: this.fields,\n      _intentHistory: this._intentHistory,\n    };\n    if (this.fromGreeting) {\n      stateToBackend.fromGreeting = this.fromGreeting;\n    }\n    if (this._activeIntent !== '') {\n      stateToBackend._activeIntent = this._activeIntent;\n    }\n    if (this._intentDurations !== '') {\n      stateToBackend._intentDurations = this._intentDurations;\n    }\n    if (this.developer._debugMode) {\n      stateToBackend._debugMode = true;\n    }\n    stateToBackend.client = this.client;\n    stateToBackend.client = this.client;\n    stateToBackend.currentWorkspace = this.currentWorkspace;\n    stateToBackend._inSilence = this._inSilence;\n    if (_.size(this._dynamicIntents) > 0) {\n      stateToBackend._dynamicIntents = this._dynamicIntents\n    }\n    stateToBackend._syncToCloud = this._syncToCloud;\n    if (Array.isArray(this._delayedNotification) && this._delayedNotification.length > 0) {\n      stateToBackend._delayedNotification = _.clone(this._delayedNotification);\n      this._delayedNotification = [];\n    }\n    stateToBackend.autoSaveBufferChanges = this.autoSaveBufferChanges;\n    stateToBackend.osVersion = this.osVersion;\n    stateToBackend.brand = this.brand;\n    stateToBackend.phoneModel = this.phoneModel;\n    stateToBackend.platform = this.platform;\n    stateToBackend.userAgent = this.userAgent;\n    return { state: stateToBackend };\n  }\n\n  getFinalResponsesArray() {\n    let _ = this._;\n    let finalResponse = {};\n    if (this.nlpResponse) {\n      finalResponse.nlpResponse = this.nlpResponse;\n    }\n    if (this._nlpResults) {\n      finalResponse._nlpResults = this._nlpResults;\n    }\n    if (_.size(this['errorStack']) > 0) {\n      finalResponse.errorStack = this['errorStack'];\n    }\n    if (_.size(this['responsesArray']) > 0) {\n      finalResponse.responsesArray = this['responsesArray'];\n    }\n    if (this['smartSuggestionsArray'] && _.size(this['smartSuggestionsArray']) > 0) {\n      finalResponse.smartSuggestionsArray = this['smartSuggestionsArray'];\n    }\n    if (this['intentResolved']) {\n      finalResponse.intentResolved = this['intentResolved'];\n    }\n    finalResponse.responseToClient = this.client;\n    if (this.sendMessageParam) {\n      finalResponse.sendMessageParam = this.sendMessageParam;\n    }\n    return finalResponse;\n  }\n\n  getFinalResponseState() {\n    let _ = this._;\n    let finalResponse = {};\n    if (this['_activeIntent'] !== '') {\n      finalResponse._activeIntent = this['_activeIntent'];\n    }\n    finalResponse.fieldsChanged = this.fieldsChanged;\n    finalResponse.fieldsCleared = this.fieldsCleared\n    if (this.developer._debugMode) {\n      finalResponse._debugMode = true;\n    }\n    if (this.blockSuggestions) {\n      finalResponse._blockSuggestions = true;\n    }\n    if (this.silentIntent) {\n      finalResponse._silentIntent = true;\n    }\n    if (this.clearPrompt) {\n      finalResponse.clearPrompt = true;\n    }\n    if (this.requestIdsArray.length > 0) {\n      finalResponse.requestIdsArray = this.requestIdsArray;\n    }\n    if (this._intentDurations) {\n      finalResponse._intentDurations = this._intentDurations;\n    }\n    if (this._autoSavePresent) {\n      finalResponse._autoSavePresent = this._autoSavePresent;\n    }\n    if (this.fromGreeting) {\n      finalResponse._conversational = this._conversational;\n      finalResponse._background = this._background;\n      finalResponse._sidebar = this._sidebar;\n      finalResponse.fromGreeting = this.fromGreeting;\n    }\n    if (this._inSilence) {\n      finalResponse._inSilence = this._inSilence;\n    }\n    if (_.size(this._dynamicIntents) > 0) {\n      finalResponse._dynamicIntents = this._dynamicIntents\n    }\n    if (this.currentTabId) {\n      finalResponse.currentTabId = this.currentTabId;\n    }\n    finalResponse.backendResponseType = 1;\n    finalResponse.responseToClient = this.client;\n    return finalResponse;\n  }\n\n  getFinalResponseSync() {\n    let _ = this._;\n    let finalResponse = {};\n    finalResponse._syncToEdge = this._syncToEdge;\n    finalResponse.autoSaveBufferChanges = this.autoSaveBufferChanges;\n    finalResponse.backendResponseType = 2;\n    finalResponse.responseToClient = this.client;\n    return finalResponse;\n  }\n\n  sizeOfObject(object) {\n    try {\n      const typeSizes = {\n        symbol: () => 0,\n        function: () => 0,\n        undefined: () => 0,\n        boolean: () => 4,\n        number: () => 8,\n        string: item => 2 * item.length,\n        object: item => !item ? 0 : Object\n          .keys(item)\n          .reduce((total, key) => sizeOf(key) + sizeOf(item[key]) + total, 0)\n      };\n\n      const sizeOf = object => {\n        return typeSizes[typeof object](object)\n      };\n\n      return sizeOf(object);\n    } catch (error) {\n      //console.log('ERROR IN LAMBDA LOGIC: Data type not found checking state size ' + typeof object);\n      //console.log('ERROR IN LAMBDA LOGIC: Error: ' + error.message);\n      return 0\n    }\n  }\n\n  set conversational(flag) {\n    this._conversational = flag;\n  }\n\n  get conversational() {\n    return this._conversational;\n  }\n\n  set waitingIcon(waitingIcon) {\n    this._waitingIcon = waitingIcon;\n  }\n\n  get waitingIcon() {\n    return this._waitingIcon;\n  }\n\n  set background(message) {\n    this._background = message;\n  }\n\n  get background() {\n    return this._background;\n  }\n\n  set sidebar(message) {\n    this._sidebar = message;\n  }\n\n  get sidebar() {\n    return this._sidebar;\n  }\n\n  set navbar(message) {\n    this._navbar = message;\n  }\n\n  get navbar() {\n    return this._navbar;\n  }\n\n  set systemId(systemId) {\n    this._systemId = systemId;\n  }\n\n  get systemId() {\n    return this._systemId;\n  }\n\n  set cssFilePath(message) {\n    this._cssFilePath = message;\n  }\n\n  get cssFilePath() {\n    return this._cssFilePath;\n  }\n\n  get intentHistory() {\n    return this.intentHistory;\n  }\n\n  getGreetingIntent() {\n    if (this._intents['main']) {\n      return this._intents['main']\n    }\n  }\n\n  get currentUserDomain() {\n    return this.conversation.userDomain;\n  }\n\n  get isPublic() {\n    if (this.user.userName.substring(0, 5) === 'Anon_') {\n      return true;\n    }\n    return false;\n  }\n\n  get unitTestMode() {\n    return this._unitTestMode;\n  }\n\n  set unitTestMode(mode) {\n    this._unitTestMode = true;\n  }\n\n  silenceBot() {\n    this._inSilence = true;\n  }\n\n  wakeUpBot() {\n    this._inSilence = false;\n  }\n\n  resumeBot() {\n    this._inSilence = false;\n  }\n\n  setVerticalSuggestions() {\n    this._suggestionsLayout = 'vertical';\n  }\n\n  get inSilence() {\n    return this._inSilence;\n  }\n\n  get modal() {\n    return this._modal;\n  }\n\n  set modal(modal) {\n    this._modal = modal;\n  }\n\n  get currentControlId() {\n    return this._currentControlId\n  }\n\n  set currentControlId(currentControlId) {\n    this._currentControlId = currentControlId;\n  }\n\n  async addUserToConversation({\n    conversationId = this.conversationId,\n    userEmail\n  }) {\n    let user = await this.frontmlib.getUserByEmail(userEmail);\n    if (user?.userId) {\n      await this.addMeToTheConversation(conversationId, user.userId)\n    } else {\n      D.warning({ message: `User ${userEmail} doesn't exist` });\n    }\n  }\n\n  async addMeToTheConversation(conversationId, userId) {\n    let _ = this._;\n    const CONVERSATIONS_TABLE = 'Conversations';\n    let query = [\n      {\n        operand: 'conversationId',\n        value: conversationId,\n        operator: 'eq',\n      },\n      {\n        operand: 'userDomain',\n        value: this.currentUserDomain,\n        operator: 'eq',\n      },\n    ];\n    let conversationObject = await this.db.getData(CONVERSATIONS_TABLE, query);\n    if (conversationObject.items) {\n      let participants = _.get(conversationObject.items[0], 'participants');\n      let userToAdd = userId || this.user.userId;\n      if (participants.indexOf(userToAdd) === -1) {\n        participants.push(userToAdd);\n        let doc = [\n          {\n            key: {\n              conversationId: conversationId,\n              userDomain: this.currentUserDomain,\n            },\n            document: {\n              participants,\n            },\n          },\n        ];\n        await this.db.writeData(CONVERSATIONS_TABLE, doc);\n        let key = 'Conversations_' + conversationId + '_' + this.currentUserDomain;\n        let cachedConversation = await this.db.getValueFromCache(key);\n        let parsedCacheConversation = JSON.parse(cachedConversation.content);\n        parsedCacheConversation.participants = participants;\n        await this.db.setOneValueInCache(key, parsedCacheConversation);\n      }\n    }\n  }\n\n  setIntentWithId(id, intent) {\n    if (this._intents[id]) return;\n    this._intents[id] = intent;\n  }\n\n  addDynamicIntent(intent) {\n    this._dynamicIntents[intent.id] = intent;\n  }\n\n  clearDynamicIntents() {\n    this._dynamicIntents = {};\n  }\n\n  get dynamicIntents() {\n    return this._dynamicIntents;\n  }\n\n  get intents() {\n    return this._intents;\n  }\n\n  createAutoSaveIntent(intentName, location) {\n    let _ = this._;\n    let autoSaveIntent = new _Intent__WEBPACK_IMPORTED_MODULE_20__.Intent(intentName);\n    if (location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n      autoSaveIntent.onMatching = () => {\n        return this.client !== _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT && _.get(this.messageFromUser, 'intentId') === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.AUTO_SAVE_INTENT_EDGE\n      }\n    } else {\n      autoSaveIntent.runOnCloud();\n      autoSaveIntent.onMatching = () => {\n        return this.client !== _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.CLIENTS.WEBCLIENT && _.get(this.messageFromUser, 'intentId') === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.AUTO_SAVE_INTENT_CLOUD\n      }\n    }\n    autoSaveIntent.onResolution = async () => {\n      let _ = this._;\n      let tabId = _.get(this.messageFromUser, 'tabId');\n      let value = _.get(this.messageFromUser, 'value');\n      let field = _.get(this.messageFromUser, 'field');\n      let autoSaveBuffer = this.autoSaveBuffer;\n      if (tabId) {\n        let autoSavedDoc = _.get(autoSaveBuffer, tabId, {});\n        if (value) {\n          autoSavedDoc[field] = value;\n        } else {\n          if (autoSavedDoc[field]) {\n            delete autoSavedDoc[field];\n          }\n        }\n        autoSaveBuffer[tabId] = autoSavedDoc;\n      }\n    }\n    this.setIntentWithId(autoSaveIntent.intentId, autoSaveIntent);\n    this.addSilentResponse();\n  }\n\n  bot(BOT) {\n    let _ = this._;\n    let D = this.developer;\n    let createDynamicIntents = () => {\n      //First processing dynamic Docs\n      let dynamicIntentsObject = {};\n      _.forEach(this._dynamicIntents, dynamicIntent => {\n        if (_.get(dynamicIntent, 'type') === 'Doc') {\n          let id = dynamicIntent.id;\n          let options = dynamicIntent.options;\n          let doc = new Doc(id, this, {\n            title: options.title,\n            description: options.description,\n            confirm: options.confirm,\n            cancel: options.cancel\n          });\n          doc.onSubmit = async () => {\n            await doc.save()\n          }\n          dynamicIntentsObject[id] = doc;\n        }\n      });\n      //Then fields and collections\n      let c;\n      _.forEach(this._dynamicIntents, dynamicIntent => {\n        if (_.get(dynamicIntent, 'type') === 'Field') {\n          let doc = _.get(dynamicIntent, 'options.doc');\n          let dynamicDocument = this._intents[doc];\n          if (dynamicDocument) {\n            let f = _Utils__WEBPACK_IMPORTED_MODULE_25__.Utils.createNewDynamicField(_.get(dynamicIntent, 'options'), dynamicDocument, this);\n            dynamicIntentsObject[_.get(dynamicIntent, 'id')] = f;\n          }\n        } else if (_.get(dynamicIntent, 'type') === 'Collection') {\n          let id = _.get(dynamicIntent, 'id');\n          let title = _.get(dynamicIntent, 'options.title');\n          let description = _.get(dynamicIntent, 'options.description');\n          let document = _.get(dynamicIntent, 'options.document');\n          let dynamicDocument = this._intents[document];\n          if (dynamicDocument) {\n            c = new _Collection__WEBPACK_IMPORTED_MODULE_24__.Collection(id, {\n              document: this._intents[document],\n              title,\n              description,\n              state: this\n            });\n            dynamicIntentsObject[id] = c;\n          }\n        }\n      });\n      /* if (c) {\n        c.onAction = async () => {\n          let surveyInstanceIdFromSelection = this.messageFromUser.content[Surveys.SURVEY_INSTANCE_ID_TITLE()];\n          let surveyInstanceId = c.document.f[Surveys.SURVEY_BASIC_FIELDS().SURVEY_INSTANCE_ID];\n          surveyInstanceId.value = surveyInstanceIdFromSelection;\n          c.document.readOnly = true;\n          c.document.confirm = 'Ok';\n          delete c.document.cancel;\n          await c.document.loadDocument();\n          this.surveys.hideNonRequiredFieldFromSurvey(c.document);\n          c.document.sendResponse();\n        };\n      } */\n      return dynamicIntentsObject;\n    };\n    let botArray = BOT(this);\n    // this.createAutoSaveIntent(ALL_CONSTANTS.AUTO_SAVE_INTENT_EDGE, ALL_CONSTANTS.LOCATIONS.EDGE);\n    // this.createAutoSaveIntent(ALL_CONSTANTS.AUTO_SAVE_INTENT_CLOUD, ALL_CONSTANTS.LOCATIONS.CLOUD);\n    if (Array.isArray(botArray) && botArray.length > 0) {\n      _.forEach(botArray, intent => {\n        this.setIntentWithId(intent.intentId, intent);\n      })\n      return botArray //This will be deprecated\n    } else {\n      let newIntentsObject = createDynamicIntents();\n      let valueToReturn = {\n        ...this._intents,\n        ...newIntentsObject\n      }\n      return _.values(valueToReturn)\n    }\n  }\n\n  async sendMessageToQueue(queue, message) {\n    if (this.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_21__.ALL_CONSTANTS.LOCATIONS.CLOUD) {\n      try {\n        let params = {\n          message: JSON.stringify(message),\n          sqsQueue: queue\n        }\n        await this.frontmlib.invokeLambda(\"SendSQSMessages\", \"Event\", params)\n      } catch (e) {\n        this.addSystemErrorToStack(7, \"Error sending SQS message\", e)\n      }\n    } else {\n      this.addSystemErrorToStack(55)\n    }\n  }\n\n  sendResponseToClient(content) {\n    try {\n      let createdOn = Date.now();\n      let createdBy = 'AgentM';\n      let contentType = 150;\n      let messageId = this.getUniqueId();\n      let message = {\n        createdOn,\n        createdBy,\n        contentType,\n        //messageId: this.messageIdFromUser,\n        messageId,\n        message: content\n      };\n      let data = {\n        queueMsgs: [\n          {\n            userId: this.user.userId, //recipient\n            userEmail: this.user.userEmail,\n            conversation: this.conversationId,\n            bot: this.botId,\n            requestUuid: this.getUniqueId(),\n            createdOn,\n            createdBy,\n            contentType,\n            messageId,\n            conversational: this.conversational,\n            timeSensitiveMessage: this.timeSensitiveMode,\n            details: [message]\n          }\n        ]\n      };\n      return this.frontmlib.invokeLambda(\"RedisWriteQueue\", \"RequestResponse\", data);\n    } catch (error) {\n      this.addSystemErrorToStack(7, \"Error responding to backend\", JSON.stringify(error));\n    }\n  }\n\n  set persistentState(persistentState) {\n    this._persistentState = persistentState;\n  }\n\n  get persistentState() {\n    return this._persistentState;\n  }\n\n  set persistentOfflineData(persistentOfflineData) {\n    this._persistentOfflineData = persistentOfflineData;\n  }\n\n  get persistentOfflineData() {\n    return this._persistentOfflineData;\n  }\n}\n\nlet state = new State();\nlet D = state.developer;\nlet _ = state._;\n\nString.prototype.sendResponse = function () {\n  state.addStringResponse(this.toString())\n};\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/State.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/UnitTest.js":
/*!*************************************************!*\
  !*** ../../Bitbucket/frontmjs/core/UnitTest.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnitTest: function() { return /* binding */ UnitTest; }\n/* harmony export */ });\n/* harmony import */ var _Intent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n\n\nclass UnitTest extends _Intent__WEBPACK_IMPORTED_MODULE_0__.Intent {\n  static RUN_COMMAND() {\n    return '@@run';\n  }\n\n  static TEST_RUN_MSG() {\n    return 'Test request submitted successfully';\n  }\n\n  static VERIFICATION_RUN_MSG() {\n    return 'Verification process finished';\n  }\n\n  static TEST_CASES_FIELD() {\n    return 'testCases';\n  }\n\n  static CURRENT_TEST_FIELD() {\n    return 'currentTest';\n  }\n\n  constructor(intentId, state) {\n    super(intentId, state);\n    this.onTest = async () => {\n    };\n    this.onVerification = async () => {\n    };\n  }\n\n  get unitTestIntent() {\n    return true;\n  }\n\n  get onMatching() {\n    return state => {\n      return (\n        state.messageTypeFromUser === 'string' &&\n        state.messageFromUser.substring(0, 5) === UnitTest.RUN_COMMAND() &&\n        state.R.toLower(state.messageFromUser.substring(6, state.messageFromUser.length)) ===\n        state.R.toLower(this.intentId)\n      );\n    };\n  }\n\n  get onResolution() {\n    return async state => {\n      //console.log('Running onTest');\n      await this.onTest();\n      if (state.responsesArray.length === 0) {\n        state.addStringResponse(UnitTest.TEST_RUN_MSG());\n      }\n    };\n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/UnitTest.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/Utils.js":
/*!**********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/Utils.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Utils: function() { return /* binding */ Utils; }\n/* harmony export */ });\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Field */ \"../../Bitbucket/frontmjs/core/Field.js\");\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./State */ \"../../Bitbucket/frontmjs/core/State.js\");\n\n\n\nclass Utils {\n\n  static IsFieldAction(action) {\n    return action === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.ACTIONS.MOVE || action === _ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.ACTIONS.CLICK;\n  }\n\n  static createNewDynamicField(field, doc, state) {\n    let newField = new _Field__WEBPACK_IMPORTED_MODULE_1__.Field(field.id, {\n      title: field.title,\n      tabId: field.tabId,\n      type: field.type,\n      doc: doc,\n      state: state,\n      primaryKey: field.primaryKey,\n      value: field.value,\n      hidden: field.hidden,\n    });\n    field.doc = doc.intentId;\n    let f = {\n      id: field.id,\n      type: 'Field',\n      options: field\n    }\n    state.addDynamicIntent(f);\n    return newField\n  }\n\n  static BuildRowsFromArrayOfArrays(rowsArr, newOptions) {\n    let _ = _State__WEBPACK_IMPORTED_MODULE_2__.state._;\n    let rows = []\n    // building the rows back from array of arrays\n    _.forEach(rowsArr, rowArr => {\n      let row = {};\n      _.forEach(newOptions.keysForShortMessage, (key, i) => {\n        if (rowArr[0][i]) row[key] = rowArr[0][i]; // conditional added to filter out null values: importantly \"allowDelete\": null\n      });\n      row.docId = rowArr[1][0];\n      row.allowEdit = rowArr[1][1];\n      row.allowDelete = rowArr[1][2];\n      row.rowMenu = rowArr[1][3];\n      rows.push(row);\n    });\n    return rows;\n  }\n\n  static BuildCollection(collection, rows, rowsArr) {\n    collection.clearRows();\n    collection.buildRowsFromArray(rows);\n    let preserveFieldDataFields = Object.keys(collection._preserveFieldData);\n    collection._rows.map((row, rowIdx) => {\n      preserveFieldDataFields.map((field, fieldIdx) => {\n        collection._preserveFieldData[field].map((fieldProp, fieldPropIdx) => {\n          row.f[field][fieldProp] = rowsArr[rowIdx][2][fieldIdx][fieldPropIdx];\n        })\n      })\n    })\n\n  }\n\n  static async ExpandShortTableResponse(shortResponse, state) {\n    let _ = state._;\n    let toSyncMessages = await state.deviceStorage.getKeyFromStorage(_ALLConstants__WEBPACK_IMPORTED_MODULE_0__.ALL_CONSTANTS.TO_SYNC_WITH_BACKEND);\n    let collectionId = _.get(shortResponse, 'options.controlId');\n    if (collectionId) {\n      const TEMP_ROWS = `TEMP_ROWS`;\n      let collection = state._intents[collectionId];\n      let newOptions = _.get(shortResponse, 'options');\n      let totalExpectedRows = _.get(shortResponse, 'totalExpectedRows');\n      let asyncPages = _.get(shortResponse, 'asyncPages');\n      collection.overrideOptions(newOptions);\n      let rowsArr = _.get(shortResponse, 'rows');\n\n      let rows = Utils.BuildRowsFromArrayOfArrays(rowsArr, newOptions);\n\n      // updating the fields from columnTemplate\n      let columnTemplateRefactored = {};\n      _.forEach(newOptions.columnTemplate, message => {\n        columnTemplateRefactored[message.id] = message;\n      });\n      collection.document._fields.map(field => {\n        if (columnTemplateRefactored.hasOwnProperty(field.id)) {\n          field.updateFieldFromMessage(columnTemplateRefactored[field.id]);\n        }\n      })\n\n      if (totalExpectedRows) {\n        let tempRows = await state.deviceStorage.loadDocument(collectionId, TEMP_ROWS) || [];\n        let newTempRows = _.union(tempRows, rows);\n        if (newTempRows.length < totalExpectedRows) {\n          await state.deviceStorage.saveDocument(collectionId, TEMP_ROWS, newTempRows);\n          return\n        } else {\n          rows = newTempRows;\n          await state.deviceStorage.deleteDocument(collectionId, TEMP_ROWS)\n        }\n      }\n      Utils.BuildCollection(collection, rows, rowsArr);\n\n      for (let i = 0; i < collection.rows.length; i++) {\n        let row = collection.rows[i];\n        let primaryKey = row.getPrimaryKey();\n        let hashedKey = state.sha1(JSON.stringify(primaryKey));\n        let fromStorage = await state.deviceStorage.loadDocument(collectionId, hashedKey);\n        let flag = 0;\n        if (fromStorage) {\n          flag = 1;\n          _.forEach(toSyncMessages, (document, collection) => {\n            if (collection === collectionId) {\n              let toSyncCollection = state._intents[collection];\n              _.forEach(document, record => {\n                let doc = toSyncCollection.document;\n                doc.buildDocument(record);\n                if (_.isEqual(primaryKey, doc.getPrimaryKey())) {\n                  flag = 2;\n                  return false;\n                }\n              })\n              return false\n            }\n          })\n          if (flag !== 0) {\n            _.forEach(row.fields, field => {\n              if (field.primaryKey) {\n                field.onlineStatus = flag\n              }\n            });\n          }\n        }\n      }\n      return collection.message(asyncPages, true);\n    }\n  }\n\n  static getGenericKeys() {\n    return [\n      'id',\n      'tabId',\n      'title',\n      'type',\n      'info',\n      'mandatory',\n      'validation',\n      'readOnly',\n      'primaryKey',\n      'value',\n      'fileName',\n      'maxLength',\n      'minLength',\n      'section',\n      'column',\n      'options',\n      'search',\n      'hidden',\n      'index',\n      'onlineStatus',\n      'pointType',\n      'iconType',\n      'fileScope',\n      'quickView ',\n      'maxSelectionOptions',\n      'height'\n    ]\n  }\n\n  static getTermQueryForObject(object, state) {\n    let _ = state._;\n    let termsArray = [];\n    _.forEach(object, (value, key) => {\n      let termObject = {};\n      termObject[key] = value;\n      let term = {\n        term: termObject\n      }\n      termsArray.push(term)\n    });\n    let queryObject = {\n      query: {\n        bool: {\n          must: termsArray\n        }\n      }\n    }\n    return queryObject\n  }\n\n  static formResponseAsObject(message) {\n    let fields = {};\n    if (message.fields) {\n      message.fields.forEach(field => {\n        if (field.fileName) {\n          fields[field.id] = {\n            value: field.value,\n            fileName: field.fileName\n          }\n        } else {\n          fields[field.id] = field.value;\n        }\n      });\n    } else {\n      if (message.currentField) {\n        fields[message.currentField] = message.currentFieldValue;\n      }\n    }\n    return fields;\n  }\n\n  static async ExpandShortFormResponse(shortResponse, state) {\n    let _ = state._;\n    let D = state.developer;\n\n    let fieldKeys = _.get(shortResponse, \"fields.fieldKeys\", []);\n    let fieldData = _.get(shortResponse, \"fields.fieldData\", []);\n    let collectionData = _.get(shortResponse, \"collectionData\", {});\n\n    let fields = [];\n    _.forEach(fieldData, fieldArray => {\n      let fieldObj = {}\n      _.forEach(fieldKeys, (fieldParam, index) => {\n        if (fieldArray[index] !== null) {\n          fieldObj[fieldParam] = fieldArray[index];\n        }\n      })\n      fields.push(fieldObj);\n    });\n\n    if (_.get(shortResponse, 'options.version', 3) < 4) {\n      return fields;\n    }\n\n    let promises = _.map(collectionData, (collectionResponse) => {\n      return this.ExpandShortTableResponse(collectionResponse, state);\n    });\n    let results = await Promise.all(promises);\n    _.forEach(results, result => {\n      let section = _.get(result, 'options.sectionId');\n      collectionData[section] = result;\n    });\n\n    return {fields, collectionData};\n  }\n\n\n  static async _ProcessShortContainerResponse(entry, state) {\n    let _ = state._;\n    if (_.get(entry, 'type') === 'table' || _.get(entry, 'type') === 'calendar' || _.get(entry, 'type') === 'map') {\n      let newOptions = _.get(entry, 'message.options');\n      let key = _.get(newOptions, 'controlId');\n      let rowsArr = _.get(entry, 'message.rows');\n      let rows = Utils.BuildRowsFromArrayOfArrays(rowsArr, newOptions);\n      let collection = state._intents[key];\n      collection.overrideOptions(newOptions);\n      Utils.BuildCollection(collection, rows, rowsArr);\n      entry.message.options = collection.options;\n      entry.message.rows = collection.message(false, false).rows;\n    } else if (_.get(entry, 'type') === 'form2') {\n      let options = entry.message.options;\n      let formResponse = await this.ExpandShortFormResponse(entry.message, state);\n      if (Array.isArray(formResponse)) {\n        formResponse = {fields: formResponse};\n      }\n      entry.message = formResponse;\n      entry.message.options = options;\n    }\n    return entry;\n  }\n\n  static async ExpandShortContainerResponse(shortResponse, state) {\n    let _ = state._;\n    let D = state.developer;\n    let promises = _.map(shortResponse, entry => {\n      return this._ProcessShortContainerResponse(entry, state);\n    });\n    return await Promise.all(promises); \n  }\n}\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/Utils.js?");

/***/ }),

/***/ "../../Bitbucket/frontmjs/core/index.js":
/*!**********************************************!*\
  !*** ../../Bitbucket/frontmjs/core/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asyncRequest: function() { return /* binding */ asyncRequest; },\n/* harmony export */   asyncResult: function() { return /* binding */ processAsyncResult; },\n/* harmony export */   done: function() { return /* binding */ farewell; },\n/* harmony export */   init: function() { return /* binding */ greeting; },\n/* harmony export */   isActiveWithMessage: function() { return /* binding */ isActiveWithMessage; },\n/* harmony export */   next: function() { return /* binding */ processNext; },\n/* harmony export */   open: function() { return /* binding */ open; },\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\n/* harmony import */ var _Intent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n/* harmony import */ var _State__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State */ \"../../Bitbucket/frontmjs/core/State.js\");\n/* harmony import */ var _MessageTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MessageTypes */ \"../../Bitbucket/frontmjs/core/MessageTypes.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"../../Bitbucket/frontmjs/core/Utils.js\");\n/* harmony import */ var _ALLConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\n/* harmony import */ var _UnitTest__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UnitTest */ \"../../Bitbucket/frontmjs/core/UnitTest.js\");\n/* harmony import */ var _Orders__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Orders */ \"../../Bitbucket/frontmjs/core/Orders.js\");\n/* harmony import */ var _Geofence__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Geofence */ \"../../Bitbucket/frontmjs/core/Geofence.js\");\n/* harmony import */ var _InputQueue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./InputQueue */ \"../../Bitbucket/frontmjs/core/InputQueue.js\");\n/* harmony import */ var _NLP__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./NLP */ \"../../Bitbucket/frontmjs/core/NLP.js\");\n/* harmony import */ var main_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! main.js */ \"./src/main.js\");\n/* harmony import */ var _Developer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Developer */ \"../../Bitbucket/frontmjs/core/Developer.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst version = '4.0.0';\nconst ACTIONS = {\n  ASYNC_RESULT: 'asyncResult',\n  NEXT: 'next'\n};\n\nconst SYNC = false;\nconst NO_INTENT_MESSAGE = \"Sorry, I didn't get that\";\nlet iAmTheOne = null;\nlet inputQueue = new _InputQueue__WEBPACK_IMPORTED_MODULE_8__[\"default\"]();\n\nlet waitForRunmode = 500;\nlet timeout = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n\nlet runAction = function (message, action) {\n  _State__WEBPACK_IMPORTED_MODULE_1__.state.isRunning = true;\n  switch (action) {\n    case ACTIONS.NEXT: {\n      return next(message.msg, message.stateParam, message.previousMessages, message.botContext);\n    }\n    case ACTIONS.ASYNC_RESULT: {\n      return asyncResult(message.result, message.stateParam, message.previousMessages, message.botContext);\n    }\n  }\n}\n\nlet addToQueueOrProcess = function (message, action) {\n  return _State__WEBPACK_IMPORTED_MODULE_1__.state.isRunning ?\n    inputQueue.addMessage(message, action) : runAction(message, action);\n}\n\nlet pollAndProcess = function () {\n  let nextMessage = inputQueue.pollMessage();\n  if (!nextMessage) {\n    _State__WEBPACK_IMPORTED_MODULE_1__.state.isRunning = false;\n    return { status: 200 };\n  }\n  return runAction(nextMessage.message, nextMessage.action);\n}\n\nlet processNext = function (msg, stateParam, previousMessages, botContext) {\n  return addToQueueOrProcess({ msg, stateParam, previousMessages, botContext }, ACTIONS.NEXT);\n}\n\nlet processAsyncResult = function (result, stateParam, previousMessages, botContext) {\n  return addToQueueOrProcess({ result, stateParam, previousMessages, botContext }, ACTIONS.ASYNC_RESULT);\n}\n\nlet logMessageFromUser = () => {\n  console.log('*************** message type: ' + _State__WEBPACK_IMPORTED_MODULE_1__.state.messageTypeFromUser);\n  _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: '*************** message type: ', data: _State__WEBPACK_IMPORTED_MODULE_1__.state.messageTypeFromUser });\n  console.log('*************** message from user: ' + JSON.stringify(_State__WEBPACK_IMPORTED_MODULE_1__.state.messageFromUser));\n  _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: '*************** message from user: ', data: _State__WEBPACK_IMPORTED_MODULE_1__.state.messageFromUser });\n}\n\nlet deviceStorageUtil = {\n  conversation: '',\n  getContext: (botContext, DeviceStorage) => {\n    DeviceStorage = DeviceStorage || botContext.getCapability('DeviceStorage');\n    return DeviceStorage.get(deviceStorageUtil.conversation);\n  },\n  setInContext: (state, botContext) => {\n    let DeviceStorage = botContext.getCapability('DeviceStorage');\n    return DeviceStorage.save(state.conversationId, state);\n  },\n  resetContext: (conversationId, botContext) => {\n    let DeviceStorage = botContext.getCapability('DeviceStorage');\n    return DeviceStorage.save(conversationId, {});\n  },\n  removeFromContext: (key, botContext) => {\n    let DeviceStorage = botContext.getCapability('DeviceStorage');\n    return deviceStorageUtil.getContext(botContext, DeviceStorage).then(state => {\n      delete state[key];\n      return DeviceStorage.save(deviceStorageUtil.conversation, state);\n    });\n  },\n};\n\nlet runMatchers = state => {\n  let _ = state._;\n  state.developer.info({ message: 'Starting matching event' });\n  let start = Date.now();\n  let promiseProcessed = false;\n  return new Promise((resolve, reject) => {\n    if (state.messageTypeFromUser === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.BACKEND_RESPONSE() || state.activeIntent !== '') {\n      promiseProcessed = true;\n      resolve();\n    } else if (state.developer.isDeveloperIntent()) {\n      let devIntent = state.developer.identifyDeveloperIntent();\n      if (devIntent) {\n        state.addActiveIntent(devIntent, false);\n      } else {\n        state.addSystemErrorToStack(12);\n        state.addActiveIntent(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT);\n      }\n      promiseProcessed = true;\n      resolve();\n    } else {\n      Object.values(state.intents).forEach(intent => {\n        if (intent.intentId) {\n          if (intent.runLocation) {\n            if (intent.runLocation !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE && intent.runLocation !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.CLOUD) {\n              state.addSystemErrorToStack(1);\n              resolve();\n              promiseProcessed = true;\n              return false; //To break the _ loop\n            }\n            if (typeof intent.onMatching === 'function' && intent.intentId !== 'main') {\n              //state.developer.info({message: 'Trying to match', data: intent.intentId});\n              if (intent.onMatching(state)) {\n                if (promiseProcessed) {\n                  state.developer.info({ message: 'Second intent matched to ' + intent.intentId });\n                  if (state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.RESPONSES.FORM_RESPONSE || state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.RESPONSES.TABLE_RESPONSE || state.messageTypeFromUser === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.RESPONSES.CONTAINER_RESPONSE) {\n                    state.addSystemErrorToStack(34);\n                  } else {\n                    state.addSystemErrorToStack(35);\n                  }\n                  state.removeActiveIntent();\n                  return false\n                } else {\n                  console.log(`Matched intent ${intent.intentId}`);\n                  state.developer.info({ message: 'Intent matched to ' + intent.intentId });\n                  state.addActiveIntent(intent.intentId, intent.logHistory, intent.silentIntent);\n                  promiseProcessed = true;\n                  let action = _.get(state.messageFromUser, 'action');\n                  if (action) {\n                    intent._presentEvent = action\n                  }\n                  if (intent.runLocation === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.CLOUD && (state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT || state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.EDGE_WEBCLIENT)) state.toCustomCap = true;\n                }\n              }\n            }\n          } else {\n            state.addSystemErrorToStack(2);\n            resolve();\n            promiseProcessed = true;\n            return false; //To break the _ loop\n          }\n        } else {\n          state.addSystemErrorToStack(21);\n          resolve();\n          promiseProcessed = true;\n          return false; //To break the _ loop\n        }\n      });\n    }\n    return state.online().then(online => {\n      if (!promiseProcessed) {\n        if (online && state.messageTypeFromUser === state.messageTypes.MESSAGE_TYPE_STRING && (state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT || state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.EDGE_WEBCLIENT)) {\n          state.toCustomCap = true;\n        }\n      } else {\n        if (!online && state.toCustomCap) {\n          state.toCustomCap = false;\n        }\n      }\n      resolve();\n      state.developer.logCurrentEventDurationWithStartTime('runMatchers', start, Date.now());\n    })\n  });\n};\n\nlet callCustomCap = async state => {\n  console.log('************* Calling custom cap ****************');\n  state.developer.info({ message: 'Calling cloud capabilities' });\n  state.context.wait(true);\n  let start = Date.now();\n  const agentGuard = state.context.getCapability('AgentGuard');\n  const requestId = state.getNewRequestId();\n  let stateToBackend = state.stateToBackEnd();\n  //Build the call\n  let networkCall = {\n    capability: 'BackendBotCap',\n    parametersObject: {\n      botId: state.context.botManifest.botId,\n      botVersion: state.context.botManifest.version,\n      command: 'asyncRequest',\n      data: stateToBackend,\n    },\n    requestUuid: requestId,\n    sync: SYNC,\n    conversation: {\n      conversationId: state.conversationId,\n      bot: state.context.botManifest.botId\n    }\n  };\n  if (state.conversation.created === undefined) {\n    networkCall.conversation.participants = state.conversation.participants;\n    networkCall.conversation.onChannels = state.conversation.onChannels;\n    networkCall.conversation.closed = false;\n  }\n  networkCall.parameters = JSON.stringify(networkCall.parametersObject);\n  delete networkCall.parametersObject;\n  //Do the call\n  let callThisIfOnError = response => {\n    let responseAsString = JSON.stringify(response);\n    state.addSystemErrorToStack(5, responseAsString);\n  }\n  return agentGuard.execute(networkCall)\n    .then(response => {\n      const isRequestQueued = response?.queued || false;\n      if (isRequestQueued) {\n        return state.online().then(online => {\n          if (!online) {\n            state.addStringResponse(\n              \"Your device appears to be offline, but don't worry, I will process your message as soon as the connection is back and I will let you know.\"\n            );\n          } else {\n            callThisIfOnError(response)\n          }\n        })\n      } else {\n        state.developer.info({ message: 'Backend call successful' });\n        state.setWaitingCustomCap();\n        state.developer.logCurrentEventDurationWithStartTime('callCustomCap', start, Date.now());\n        state._delayedNotification = {};\n        state._syncToCloud = {};\n        if (state._persistentOfflineData) {\n          return state.deviceStorage.removeKeyFromStorage(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.TO_SYNC_WITH_BACKEND)\n        } else {\n          return {}\n        }\n      }\n    })\n    .catch(error => {\n      console.log(`************* Some sort of problem ${JSON.stringify(error)}`);\n      state.addSystemErrorToStack(5, error);\n      state.developer.logCurrentEventDurationWithStartTime('callCustomCap', start, Date.now());\n      callThisIfOnError(error)\n    });\n};\n\nlet runValidators = state => {\n  state.developer.info({ message: 'Starting validation event' });\n  let start = Date.now();\n  let _ = state._;\n  let activeIntent = state.activeIntent;\n  let validationResult = true;\n  if (activeIntent !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT) {\n    Object.values(state.intents).forEach(intent => {\n      if (intent.intentId === activeIntent) {\n        if (intent.onError) {\n          state.onError = intent.onError;\n        }\n        try {\n          if (intent.onValidation) {\n            state.developer.info({ message: 'Starting onValidation for intent ' + intent.intentId });\n            intent.onValidation(state);\n            if (_.size(state.errorStack) > 0) {\n            }\n          }\n        } catch (error) {\n          let errorCode = state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE ? 5 : 7;\n          state.addSystemErrorToStack(errorCode, error.message);\n        }\n      }\n    });\n  }\n  state.developer.logCurrentEventDurationWithStartTime('runValidators', start, Date.now());\n  return validationResult;\n};\n\nlet runResolvers = state => {\n  console.log('************* Resolvers method ****************');\n  state.developer.info({ message: 'Starting resolution event' });\n  let start = Date.now();\n  let _ = state._;\n  return new Promise((resolve, reject) => {\n    let activeIntent = state.activeIntent;\n    if (activeIntent === '') {\n      state.addActiveIntent(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT);\n      resolve();\n    } else if (activeIntent === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS) {\n      resolve()\n    } else if (activeIntent !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT) {\n      Object.values(state.intents).forEach(intent => {\n        if (intent.intentId === activeIntent) {\n          if (intent.onResolution) {\n            state.developer.info({ message: 'Starting onResolution for intent ' + intent.intentId });\n            return intent\n              .onResolution(state)\n              .then(() => {\n                state.developer.info({ message: 'Resolution passed' });\n                resolve();\n                state.developer.logCurrentEventDurationWithStartTime('runResolvers', start, Date.now());\n                return state.recordActivity();\n              })\n              .catch(error => {\n                let errorCode = state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE ? 5 : 7;\n                state.addSystemErrorToStack(errorCode, 'Error processing resolution on edge ' + error.message);\n                resolve();\n                state.developer.logCurrentEventDurationWithStartTime('runResolvers', start, Date.now());\n              });\n          } else {\n            state.addSystemErrorToStack(3);\n            resolve();\n            state.developer.logCurrentEventDurationWithStartTime('runResolvers', start, Date.now());\n          }\n        }\n      });\n    }\n  });\n};\n\nlet msgState = {\n  msgList: [],\n};\n\nlet tellOrTest = (state, msg, botContext) => {\n  if (state.unitTestMode) {\n    let currentUnitTest;\n    Object.values(state.intents).forEach(intent => {\n      if (intent.intentId === state.activeIntent && intent.runLocation === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n        currentUnitTest = intent;\n        return false;\n      }\n    });\n    if (currentUnitTest) {\n      return currentUnitTest.onVerification().then(() => {\n        tell(_UnitTest__WEBPACK_IMPORTED_MODULE_5__.UnitTest.VERIFICATION_RUN_MSG(), botContext);\n      });\n    }\n  } else {\n    tell(msg, botContext);\n  }\n};\n\nlet tell = (msg, botContext) => {\n  botContext.tell(msg);\n};\n\nlet syncData = state => {\n  if (!state.persistentOfflineData) return Promise.resolve();\n  let _ = state._;\n  let promisesArray = [];\n  if (state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE && !(state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.WEBCLIENT)) {\n    _.forEach(state._syncToEdge, (documents, collection) => {\n      _.forEach(documents, (value, key) => {\n        if (collection === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.PERSISTED_STORAGE) {\n          promisesArray.push(state.deviceStorage.saveKeyInStorage(key, value));\n        } else {\n          promisesArray.push(state.deviceStorage.saveDocument(collection, key, value));\n        }\n      })\n    })\n    if (promisesArray.length > 0) {\n      return Promise.all(promisesArray)\n        .then(() => {\n          return state.online();\n        })\n        .then(online => {\n          //If offline the system checks all new records stored in the state and stores them in the local storage\n          // ALL_CONSTANTS.TO_SYNC_WITH_BACKEND is deprecated. It will be removed\n          if (online) {\n            state._syncToEdge = {};\n            return Promise.resolve({ noDataToSync: true })\n          } else {\n            return state.deviceStorage.getKeyFromStorage(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.TO_SYNC_WITH_BACKEND);\n          }\n        })\n        .then(existingSync => {\n          let dataToSync = existingSync || {};\n          if (_.get(dataToSync, 'noDataToSync')) {\n            return Promise.resolve()\n          }\n          _.forEach(state._syncToCloud, (documents, collection) => {\n            let collectionObject = dataToSync[collection] || {};\n            _.forEach(documents, (value, key) => {\n              collectionObject[key] = value;\n            })\n            dataToSync[collection] = collectionObject;\n          })\n          if (_.size(dataToSync) > 0) {\n            return state.deviceStorage.saveKeyInStorage(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.TO_SYNC_WITH_BACKEND, dataToSync)\n          } else {\n            return Promise.resolve()\n          }\n        })\n    } else {\n      return Promise.resolve()\n    }\n  } else {\n    return Promise.resolve()\n  }\n}\n\nlet processShortResponse = state => {\n  let _ = state._;\n  let D = state.developer;\n  if (state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE && state.client !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.WEBCLIENT) {\n    let promisesArray = [];\n    _.forEach(state.responsesArray, response => {\n      if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.SHORT_TABLE_RESPONSE()) {\n        let processShortTableResponse = async response => {\n          D.log({ message: 'Calling expand table' });\n          let tableMessage = await _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.ExpandShortTableResponse(response.message, state);\n          if (tableMessage) {\n            response.message = tableMessage\n            response.type = 'table';\n          } else {\n            delete response.message;\n            response.type = 'silent'\n          }\n        }\n        promisesArray.push(processShortTableResponse(response));\n      } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.SHORT_CONTAINER_RESPONSE()) {\n        let processShortTableResponse = async response => {\n          let containerData = _.get(response, 'message.fields');\n          if (containerData) {\n            let containerMessage = await _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.ExpandShortContainerResponse(containerData, state);\n            if (containerMessage) {\n              response.message.fields = containerMessage\n              response.type = 'container';\n            }\n          }\n        }\n        promisesArray.push(processShortTableResponse(response));\n      } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.SHORT_FORM_RESPONSE()) {\n        let processShortFormResponse = async response => {\n          let formData = _.get(response, 'message', {});\n          if (formData.fields) {\n            let formMessage = await _Utils__WEBPACK_IMPORTED_MODULE_3__.Utils.ExpandShortFormResponse(formData, state);\n            if (formMessage) {\n              response.message.fields = formMessage\n              response.type = 'form2';\n            }\n          }\n        }\n        promisesArray.push(processShortFormResponse(response));\n      }\n    });\n    return Promise.all(promisesArray)\n  }\n  return Promise.resolve()\n}\n\nlet processGreeting = async state => {\n  console.log('Processing greeting');\n  let start = Date.now();\n  await state.resetAutoSaveBuffer();\n  //await state.loadAutoSaveBuffer();\n  let greetingIntent = state.getGreetingIntent();\n  state.developer.logCurrentEventDurationWithStartTime('searchForMainIntent', start, Date.now());\n  state.addActiveIntent(greetingIntent.intentId, greetingIntent.logHistory, greetingIntent.silentIntent);\n  state._routesQueue = {};\n  state.setField(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.COMMON_FIELDS.LAST_MAIN_TIMESTAMP, Date.now());\n  if (state.nlp.assistantName === _NLP__WEBPACK_IMPORTED_MODULE_9__.NLP.DEFAULT_ASSISTANT_NAME() && await state.online()) {\n    state.nlp.clearConversationContext();\n  }\n  if (greetingIntent) {\n    state.waitingCustomCap = 0;\n    await state.onStart();\n    state.amIOnline = await state.online();\n    state.addRunModeResponse();\n    let onEdgeInit = greetingIntent.onInitEdge;\n    if (onEdgeInit) {\n      await onEdgeInit()\n    }\n    logMessageFromUser();\n    if (greetingIntent.runLocation === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.CLOUD && state.amIOnline && (state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT || state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.EDGE_WEBCLIENT)) {\n      state.context.wait(true);\n      return callCustomCap(state);\n    }\n    let onResolution = greetingIntent.onResolution;\n    let start = Date.now();\n    if (greetingIntent.onError) {\n      state.onError = greetingIntent.onError;\n    }\n    if (onResolution) {\n      return onResolution(state).then(() => {\n        state.developer.logCurrentEventDurationWithStartTime('mainOnResolution', start, Date.now());\n        return state.recordActivity();\n      }).catch(error => {\n        console.log('Error in main');\n        state.addSystemErrorToStack(5, error.message);\n      });\n    }\n  }\n};\n\nlet initialiseGreetingState = (conversation, user, stateParam, botContext) => {\n  let emptyMessage = null;\n  _State__WEBPACK_IMPORTED_MODULE_1__.state.init(emptyMessage, conversation, user, _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE, stateParam, botContext);\n  _State__WEBPACK_IMPORTED_MODULE_1__.state.resetWaitingForCustomCapCounter();\n  _State__WEBPACK_IMPORTED_MODULE_1__.state.runAllOnInits().then();\n};\n\nlet startInfoLogs = (state, event, stateFromStorage) => {\n  if (event === 'Greeting') {\n    state.developer.info({ message: 'State initialised (Greeting)' });\n  } else {\n    state.developer.info({ message: 'State initialised (Next)' });\n  }\n  state.developer.info({ message: 'State from storage: ', data: stateFromStorage });\n  state.developer.info({ message: 'Message type from user: ', data: state.messageTypeFromUser });\n  state.developer.info({ message: 'Message from User: ', data: state.messageFromUser });\n};\n\nlet continueGreeting = (botContext) => {\n  let start = Date.now();\n  let conversation = null;\n  let user = null;\n  let sendMessageParam = null;\n  let startStorageCap = 0;\n  let endStorageCap = 0;\n  let startConvCap = 0;\n  let endConvCap = 0;\n  let startAuthCap = Date.now();\n  let endAuthCap = 0;\n  let errorMessage = \"Stopping on view due to a spurious request on bot start\";\n  const authContext = botContext.getCapability('authContext');\n  return new Promise((resolve, reject) => {\n    console.log(JSON.stringify(_State__WEBPACK_IMPORTED_MODULE_1__.state.user));\n    if (Object.keys(_State__WEBPACK_IMPORTED_MODULE_1__.state.user).length === 0) {\n      if (typeof authContext.getUserData === \"function\") {\n        resolve(authContext.getUserData())\n      } else {\n        resolve()\n      }\n    } else {\n      resolve(_State__WEBPACK_IMPORTED_MODULE_1__.state.user)\n    }\n  })\n    .then(usr => {\n      if (!usr) {\n        return authContext.getAuthUser(botContext)\n      } else {\n        return usr\n      }\n    })\n    .then(usr => {\n      endAuthCap = Date.now();\n      startConvCap = Date.now();\n      user = usr;\n      let conversationContext = botContext.getCapability('ConversationContext');\n      if (Object.keys(_State__WEBPACK_IMPORTED_MODULE_1__.state.conversation).length === 0) {\n        return conversationContext.getConversationContext(botContext, user);\n      } else {\n        return _State__WEBPACK_IMPORTED_MODULE_1__.state.conversation\n      }\n    })\n    .then(context => {\n      endConvCap = Date.now();\n      startStorageCap = Date.now();\n      conversation = context;\n      deviceStorageUtil.conversation = conversation.conversationId;\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state._persistentState) {\n        return deviceStorageUtil.getContext(botContext);\n      } else {\n        return {}\n      }\n    })\n    .then(stateFromStorage => {\n      endStorageCap = Date.now();\n      let startState = Date.now();\n      user.userName = user.info.name;\n      user.userId = user.info.userId;\n      user.userEmail = user.info.emailAddress;\n      user.tz = user.info.userTimezone;\n      initialiseGreetingState(conversation, user, stateFromStorage, botContext);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.addActiveIntent(\"main\");\n      startInfoLogs(_State__WEBPACK_IMPORTED_MODULE_1__.state, 'Greeting', stateFromStorage);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('loadAuthCap', startAuthCap, endAuthCap);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('loadConversationCap', startConvCap, endConvCap);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('loadStorageCap', startStorageCap, endStorageCap);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('initialiseGreetingState', startState, Date.now());\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.fromGreeting = true;\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.clearRoutesQueue();\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.WEBCLIENT && !_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) {\n        console.log(errorMessage);\n        _State__WEBPACK_IMPORTED_MODULE_1__.D.warning({\n          message: errorMessage, data: {\n            client: _State__WEBPACK_IMPORTED_MODULE_1__.state.client,\n            v1Compatibility: _State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility\n          }\n        });\n        throw errorMessage\n      }\n      if (!_State__WEBPACK_IMPORTED_MODULE_1__.state.inSilence) return processGreeting(_State__WEBPACK_IMPORTED_MODULE_1__.state);\n    })\n    .then(() => {\n      return processShortResponse(_State__WEBPACK_IMPORTED_MODULE_1__.state)\n    })\n    .then(() => {\n      return view(_State__WEBPACK_IMPORTED_MODULE_1__.state, botContext);\n    })\n    .then(() => {\n      return syncData(_State__WEBPACK_IMPORTED_MODULE_1__.state)\n    })\n    .then(() => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved) {\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved = false;\n      }\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam) {\n        sendMessageParam = _State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam;\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam = null;\n      }\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('allGreeting', start, Date.now());\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.save(deviceStorageUtil);\n    })\n    .then(() => {\n      if (sendMessageParam) {\n        let message = {\n          messageFromUser: sendMessageParam,\n        };\n        if (typeof sendMessageParam === 'string') {\n          message.messageType = 'string';\n        } else {\n          message.messageType = 'object';\n        }\n        return next(message, undefined, {}, botContext);\n      }\n    })\n    .then(() => {\n      // state.endMessageProcessing();\n      return pollAndProcess();\n    })\n    .catch(error => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state !== {} && error !== errorMessage) {\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.systemError({ message: 'Critical error running Greeting', data: error });\n        console.log(`Critical error during greeting ${error}`)\n        return tellOrTest(_State__WEBPACK_IMPORTED_MODULE_1__.state, 'Something wrong has happened ' + error.message, botContext);\n      }\n    });\n};\n\nlet greeting = function (state, previousMessages, botContext) {\n  iAmTheOne = 'Initialised';\n  console.log(\"Starting init\");\n  return continueGreeting(botContext);\n};\n\nlet runPredictors = async state => {\n  let start = Date.now();\n  let _ = state._;\n  state.developer.info({ message: 'Starting prediction event' });\n  if (_.size(state.smartSuggestionsArray) === 0 && !state.blockSuggestions) {\n    let predictors = false;\n    let sortedPredictions = [];\n    let allKeys = Object.keys(state.intents);\n    for (let index = 0; index < allKeys.length; index++) {\n      let intent = state.intents[allKeys[index]];\n      let predictionObject = {};\n      if (_.size(intent.suggestionsArray) > 0) {\n        let predictor = intent.onPrediction;\n        if (predictor) {\n          try {\n            predictors = true;\n            predictionObject.weight = await predictor();\n          } catch (err) {\n            state.addSystemErrorToStack(27, err.errorMessage);\n          }\n        } else {\n          predictionObject.weight = 1;\n        }\n        predictionObject.suggestionsArray = intent.suggestionsArray;\n        if (predictionObject.weight > 0) {\n          let index = _.sortedIndexBy(sortedPredictions, predictionObject, 'weight');\n          sortedPredictions.splice(index, 0, predictionObject);\n        }\n      }\n    }\n    if (predictors) {\n      _.each(sortedPredictions, predictionObject => {\n        state.addSmartSuggestionsArray(predictionObject.suggestionsArray);\n      });\n      state.smartSuggestionsArray = _.reverse(state.smartSuggestionsArray);\n    }\n  }\n  state.developer.logCurrentEventDurationWithStartTime('runPredictors', start, Date.now());\n};\n\nlet controller = state => {\n  let start = Date.now();\n  let _ = state._;\n  state.developer.info({ message: 'Starting controller event' });\n  return state.online().then(online => {\n    state.amIOnline = online;\n    return matchingLogic(state).then(() => {\n      if (state.activeIntent !== _Intent__WEBPACK_IMPORTED_MODULE_0__.Intent.SPEECH() && state.activeIntent !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT) {\n        if (state.toCustomCap) {\n          return callCustomCap(state).then(() => {\n            state.developer.logCurrentEventDurationWithStartTime('controller', start, Date.now());\n          });\n        } else {\n          state.developer.info({ message: 'Before onStart' });\n          return state.onStart()\n            .then(() => {\n              state.developer.info({ message: 'Before onInts' });\n              if (state.onlineRequired && !online) {\n                state.addSystemErrorToStack(56)\n                return\n              }\n              return state.runAllOnInits()\n            })\n            .then(() => {\n              logMessageFromUser();\n              if (runValidators(state)) {\n                let intentLocation = _.get(state, `intents.${state.activeIntent}.runLocation`, _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE);\n                if (state.location === intentLocation || state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE) {\n                  return runResolvers(state).then(() => {\n                    state.developer.logCurrentEventDurationWithStartTime('controller', start, Date.now());\n                    return state.storeAutoSaveBuffer()\n                  });\n                } else {\n                  state.developer.warning({\n                    message: `Bot tried to run a ${intentLocation} intent in ${state.location}`,\n                    data: state.activeIntent\n                  })\n                }\n              }\n            })\n        }\n      }\n    }).catch(error => {\n      console.log('Error in controller');\n      let errorCode = state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE ? 5 : 7;\n      state.addSystemErrorToStack(errorCode, error.message);\n    });\n  });\n};\n\nlet view = (state, botContext) => {\n  state.developer.info({ message: 'Starting view event' });\n  let _ = state._;\n  let start = Date.now();\n  return new Promise(async (resolve, reject) => {\n    if (state.fromGreeting && !state.conversational && !state.inError && state.waitingCustomCap > 0 && _.get(state.responsesArray, 'length', 0) === 0) {\n      state.developer.info({\n        message: 'Ending here', data: {\n          fromGreeting: state.fromGreeting,\n          conversational: state.conversational,\n          waitingForCustomCap: state.waitingCustomCap,\n          responsesArrayLength: _.get(state.responsesArray, 'length', 0)\n        }\n      });\n      state.fromGreeting = false;\n      resolve();\n      return;\n    }\n    if (state.conversational && !state.inSilence) {\n      await runPredictors(state);\n    }\n    state.developer.info({ message: 'Start processing responses' });\n    if (state.inError) {\n      state.onError(state);\n    } else {\n      if (\n        !state.fromGreeting &&\n        ((state.responsesArray.length === 0 &&\n          state.smartSuggestionsArray.length === 0 &&\n          !state.sendMessageParam &&\n          !state.toCustomCap &&\n          !state.autoResponse))\n      ) {\n        let noResponse = {\n          fromGreeting: state.fromGreeting,\n          responsesQ: state.responsesArray.length,\n          suggestionsQ: state.smartSuggestionsArray.length,\n          sendMSG: state.sendMessageParam,\n          toCustomCap: state.toCustomCap,\n          activeIntent: state.activeIntent,\n        };\n        state.developer.info({ message: 'Found No Intent', data: noResponse });\n        state.addStringResponse(NO_INTENT_MESSAGE);\n      }\n    }\n    state.removeActiveIntent();\n    if (state.silentIntent) {\n      state.clearResponseArray();\n      state.clearError();\n      resolve();\n      return;\n    }\n    if (state.fromGreeting) {\n      state.fromGreeting = false;\n    }\n    let smartSuggestions = state.smartSuggestionsArray;\n    if (_.size(state.responsesArray) > 0) {\n      state.intentResolved = true;\n      _.each(state.responsesArray, response => {\n        let Message = state.context.getCapability('Message');\n        let message = new Message({ uuid: response.messageId });\n        if (response.type === state.messageTypes.MESSAGE_TYPE_STRING) {\n          message.stringMessage(response.message)\n          tellOrTest(state, message, state.context);\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_WEB_CARD) {\n          let cards = response.message.cards;\n          let previews = response.message.previews;\n          message.webCard(cards, previews);\n          //tell(message, state.context);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_FORM2) {\n          let form = response.message;\n          message.form2Message(form.fields, form.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'form_live_changes') {\n          if (response.message.result) {\n            message.form2Message(response.message.result, response.message.options);\n          } else {\n            message.form2Message(response.message.options);\n          }\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'table_live_changes') {\n          //state.developer.debug({message: 'Live form change ', data:response.message});\n          message.tableMessage(response.message.result, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'form_close') {\n          if (message.closeFormMessage) {\n            message.closeFormMessage(response.message);\n            tellOrTest(state, message, state.context);\n          }\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_SMART_SUGGESTIONS) {\n          smartSuggestions = response.message;\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_TABLE) {\n          let table = response.message;\n          if (table.options && table.options.style === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.COLLECTION_TYPES.CALENDAR) {\n            message.calendarMessage(table.rows, table.options);\n          } else if (table.options && table.options.style === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.COLLECTION_TYPES.MAP) {\n            message.mapMessage(table.rows, table.options);\n          } else {\n            message.tableMessage(table.rows, table.options);\n          }\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'data_card') {\n          if (state.conversation.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT) {\n            let list = response.message;\n            message.dataCard(list);\n            tellOrTest(state, message, state.context);\n          } else {\n            let msg = 'Data cards are not yet available in your client';\n            state.addSystemErrorToStack(5, msg);\n            tellOrTest(state, msg, state.context);\n          }\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_CARDS) {\n          let list = response.message.cards;\n          let options = response.message.options;\n          message.cards(list, options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_MAP) {\n          let map = response.message;\n          let mapObject = {\n            region: map.region,\n            markers: _.get(map, 'markers'),\n            polylines: _.get(map, 'polylines'),\n            planeRoutes: _.get(map, 'planeRoutes'),\n            cards: _.get(map, 'cards'),\n            geoJsonUrl: _.get(map, 'geoJsonUrl', ''),\n          };\n          message.mapMessage(mapObject, map.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'standard_notification') {\n          message.standardNotification(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'critical_notification') {\n          message.criticalNotification(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'authorization_request') {\n          message.authorizationRequest(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'stripe') {\n          if ((state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.MOBILECLIENT || state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.EDGE_WEBCLIENT)) {\n            let msg = 'Message type not supported on this client';\n            state.addSystemErrorToStack(5, msg);\n            tellOrTest(state, msg, state.context);\n          } else {\n            let { amount, currency, description, paymentCode } = response.message;\n            if (_.isUndefined(paymentCode) || _.isEmpty(paymentCode)) {\n              paymentCode = _Orders__WEBPACK_IMPORTED_MODULE_6__.Orders.PAYMENT_CODES().TOP_UP_WALLET;\n            }\n            let transactionId = state.orders.createNewStripeTransaction(amount, currency, description);\n\n            let payments = state.context.getCapability('Stripe');\n            payments.startPayment(transactionId, amount, currency, description, state.context, paymentCode);\n          }\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_CHART) {\n          let chart = response.message;\n          message.chartMessage(chart.data, chart.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'slider') {\n          message.sliderMessage(response.message.list, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_VIDEO) {\n          message.videoMessage(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'trackerForm') {\n          message.trackingViewMessage(response.message.data, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'html') {\n          message.htmlMessage(response.message.message, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'container') {\n          message.containerMessage(response.message.fields, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'close_control') {\n          message.closeControlMessage(response.message);\n        } else if (response.type === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.RESPONSES.VIDEO_CALL) {\n          message.videoCallMessage(response.message?.data, response.message?.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'menuMessage') {\n          message.menuMessage(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'sound') {\n          message.soundResponse(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === 'image') {\n          message.imageMessage(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === state.messageTypes.MESSAGE_TYPE_CSV) {\n          message.csvMessage(response.message);\n          tellOrTest(state, message, state.context);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === _Geofence__WEBPACK_IMPORTED_MODULE_7__.Geofence.GEOFENCE_MESSAGE()) {\n          message.geofenceMessage(response.message.coordinates, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.SHORT_TABLE_RESPONSE()) {\n          //Nothing to do\n        } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.SHORT_CONTAINER_RESPONSE()) {\n          //Nothing to do\n        } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.MESSAGE_TYPE_SURVEY()) {\n          message.surveyMessage(response.message.data, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.MESSAGE_VOICE_CALL()) {\n          message.voiceCall(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.MESSAGE_TYPE_TIMELINE_LIST()) {\n          message.timelinesListMessage(response.message, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.MESSAGE_TYPE_TIMELINE_POST()) {\n          message.timelinesPostMessage(response.message);\n          tellOrTest(state, message, state.context);\n        } else if (response.type === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.DASHBOARD()) {\n          message.dashboardMessage({}, response.message.options);\n          tellOrTest(state, message, state.context);\n        } else if (response.type !== 'silent') {\n          let msg = 'Message type not supported';\n          state.addSystemErrorToStack(5, msg);\n          tellOrTest(state, msg, state.context);\n        }\n      });\n      state.waitingCustomCap = 0;\n    }\n    state.clearResponseArray();\n    state.clearError();\n    let MessageForSuggestions = state.context.getCapability('Message');\n    let messageForSuggestions = new MessageForSuggestions();\n    if (_.size(state.smartSuggestionsArray) > 0) {\n      messageForSuggestions.smartSuggestions(smartSuggestions);\n      state.developer.info({ message: 'Displaying suggestions ' + JSON.stringify(smartSuggestions) });\n      tellOrTest(state, messageForSuggestions, state.context);\n    } else {\n      if (state.blockSuggestions || state.inSilence) {\n        messageForSuggestions.smartSuggestions([]);\n        tellOrTest(state, messageForSuggestions, state.context);\n      }\n    }\n    state.clearSmartSuggestionsArray();\n    state.resetOnErrorMethod();\n    state.developer.info({ message: 'Finished processing responses' });\n    state.toCustomCap = false;\n    resolve();\n    state.developer.logCurrentEventDurationWithStartTime('view', start, Date.now());\n  });\n};\n\nlet next = function (msg, stateParam, previousMessages, botContext) {\n  console.log('************* Next method ****************');\n  let start = Date.now();\n  let startStorageCap = 0;\n  let endStorageCap = 0;\n  let startConvCap = 0;\n  let endConvCap = 0;\n  let startAuthCap = Date.now();\n  let endAuthCap = 0;\n  const authContext = botContext.getCapability('authContext');\n  let conversation = null;\n  let user = null;\n  let sendMessageParam = null;\n  let _ = null;\n  const EXIT_PROMISE_CHAIN = \"Exit promise chain\";\n  return new Promise((resolve, reject) => {\n    if (Object.keys(_State__WEBPACK_IMPORTED_MODULE_1__.state.user).length === 0) {\n      if (typeof authContext.getUserData === \"function\") {\n        resolve(authContext.getUserData())\n      } else {\n        resolve()\n      }\n    } else {\n      resolve(_State__WEBPACK_IMPORTED_MODULE_1__.state.user)\n    }\n  })\n    .then(usr => {\n      if (!usr) {\n        return authContext.getAuthUser(botContext)\n      }\n      return usr\n    })\n    .then(usr => {\n      endAuthCap = Date.now();\n      user = usr;\n      let conversationContext = botContext.getCapability('ConversationContext');\n      startConvCap = Date.now();\n      if (Object.keys(_State__WEBPACK_IMPORTED_MODULE_1__.state.conversation).length === 0) {\n        return conversationContext.getConversationContext(botContext, user);\n      } else {\n        return _State__WEBPACK_IMPORTED_MODULE_1__.state.conversation\n      }\n    })\n    .then(context => {\n      endConvCap = Date.now();\n      conversation = context;\n      deviceStorageUtil.conversation = conversation.conversationId;\n      startStorageCap = Date.now();\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state._persistentState) {\n        return deviceStorageUtil.getContext(botContext);\n      } else {\n        return {}\n      }\n    })\n    .then(stateFromStorage => {\n      let startState = Date.now();\n      endStorageCap = Date.now();\n      user.userName = user.info.name;\n      user.userId = user.info.userId;\n      user.userEmail = user.info.emailAddress;\n      user.tz = user.info.userTimezone;\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.init(msg, conversation, user, _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE, stateFromStorage, botContext);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.removeActiveIntent();\n      startInfoLogs(_State__WEBPACK_IMPORTED_MODULE_1__.state, 'Next', stateFromStorage);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('loadAuthCap', startAuthCap, endAuthCap);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('loadConversationCap', startConvCap, endConvCap);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('loadStorageCap', startStorageCap, endStorageCap);\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('initialiseState', startState, Date.now());\n      _ = _State__WEBPACK_IMPORTED_MODULE_1__.state._;\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.loadAutoSaveBuffer();\n    })\n    .then(() => {\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.syncWithBackendState(stateParam);\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.client !== _State__WEBPACK_IMPORTED_MODULE_1__.state.responseToClient && _State__WEBPACK_IMPORTED_MODULE_1__.state.responseToClient !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.WEBCLIENT) {\n        throw EXIT_PROMISE_CHAIN;\n      }\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.backendResponseType === 0) {\n        if (msg.requestId) {\n          if (!_State__WEBPACK_IMPORTED_MODULE_1__.state.markRequestIdProcessed(msg.requestId)) {\n            return Promise.resolve('ignore');\n          }\n        }\n        if (_State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved || _.size(_State__WEBPACK_IMPORTED_MODULE_1__.state.errorStack) > 0) {\n          return Promise.resolve();\n        } else {\n          return controller(_State__WEBPACK_IMPORTED_MODULE_1__.state);\n        }\n      } else if (_State__WEBPACK_IMPORTED_MODULE_1__.state.backendResponseType === 1) {\n        return _State__WEBPACK_IMPORTED_MODULE_1__.state.save(deviceStorageUtil).then(() => {\n          throw EXIT_PROMISE_CHAIN;\n        })\n      } else if (_State__WEBPACK_IMPORTED_MODULE_1__.state.backendResponseType === 2) {\n        return syncData(_State__WEBPACK_IMPORTED_MODULE_1__.state).then(() => {\n          return _State__WEBPACK_IMPORTED_MODULE_1__.state.save(deviceStorageUtil).then(() => {\n            throw EXIT_PROMISE_CHAIN;\n          });\n        })\n      } else {\n        return Promise.resolve('ignore');\n      }\n    })\n    .then(noNeedForView => {\n      if (noNeedForView === 'ignore') {\n        return noNeedForView;\n      }\n      return processShortResponse(_State__WEBPACK_IMPORTED_MODULE_1__.state);\n    })\n    .then(noNeedForView => {\n      if (noNeedForView === 'ignore') {\n        return noNeedForView;\n      }\n      return view(_State__WEBPACK_IMPORTED_MODULE_1__.state, botContext);\n    })\n    .then(() => {\n      botContext.wait(false);\n      if (\n        !_State__WEBPACK_IMPORTED_MODULE_1__.state.silentIntent &&\n        !_State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved &&\n        ((_State__WEBPACK_IMPORTED_MODULE_1__.state.waitingCustomCap > 0 &&\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.messageTypeFromUser !== 'search_box_response' &&\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.messageFromUser.action !== 'close' &&\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.messageFromUser.action !== 'move' &&\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.messageFromUser.action !== 'cancel' &&\n            //(state.messageTypeFromUser !== 'form_response' || !state.conversational)\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.messageTypeFromUser !== _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.BOT_TO_BOT()) ||\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam)\n      ) {\n        botContext.wait(true);\n      }\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved) {\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved = false;\n      }\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam) {\n        sendMessageParam = _State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam;\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam = null;\n      }\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('totalNextMethod', start, Date.now());\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.save(deviceStorageUtil);\n    })\n    .then(() => {\n      if (sendMessageParam) {\n        let message = {\n          messageFromUser: sendMessageParam,\n        };\n        let toGreeting = false;\n        if (typeof sendMessageParam === 'string') {\n          message.messageType = 'string';\n        } else {\n          message.messageType = 'object';\n          if (sendMessageParam.intentId && sendMessageParam.intentId === '@@reset') {\n            toGreeting = true;\n          }\n        }\n        if (toGreeting) {\n          return greeting(undefined, { reset: true }, botContext);\n        } else {\n          return next(message, undefined, {}, botContext);\n        }\n      }\n    })\n    .then(() => {\n      // state.endMessageProcessing();\n      return pollAndProcess();\n    })\n    .catch(error => {\n      if (error.message === \"1\" || typeof error === \"string\") {\n        return pollAndProcess();\n      }\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state instanceof _State__WEBPACK_IMPORTED_MODULE_1__.State) {\n        if (_State__WEBPACK_IMPORTED_MODULE_1__.state.backendResponseType === 0) {\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.addSystemErrorToStack(5, error.message);\n          return view(_State__WEBPACK_IMPORTED_MODULE_1__.state, botContext).then(() => {\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.save(deviceStorageUtil);\n          });\n        }\n        return pollAndProcess();\n      } else {\n        console.log('Something very wrong ' + error.message);\n      }\n    })\n    .then(() => {\n      return { status: 200 };\n    });\n};\n\nlet asyncResult = function (result, stateParam, previousMessages, botContext) {\n  const utils = botContext.getCapability('Utils');\n  const _ = utils.Lodash;\n  const state = _.get(result, 'details[0].message');\n  if (_.get(state, 'success') || _.get(state, 'StatusCode')) {\n    return pollAndProcess();\n  }\n  let data = {\n    state,\n    messageId: _.get(result, 'messageId'),\n    requestId: _.get(result, 'requestUuid')\n  }\n  let params = {\n    type: 'USER',\n    entry: {\n      userDomain: 'unknown',\n      userId: 'unknown',\n      userEmail: 'unknown',\n      botId: _.get(result, 'messageId'),\n      conversationId: _.get(result, 'requestUuid'),\n      entity: 'Micro-App',\n      intent: 'unknown',\n      client: 'unknown',\n      location: _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE,\n      timestamp: Date.now(),\n      level: 'LOG',\n      message: 'Started async_result in mobile',\n      data: result\n    },\n  };\n  botContext.log(params)\n  let requestId = _.get(result, 'requestUuid');\n  console.log('************* Data Received ****************');\n  console.log(JSON.stringify(state));\n  console.log('************* Data Received ****************');\n  if (state && requestId && requestId !== '') {\n    const contentType = _.get(result, 'contentType');\n    const createdOn = _.get(result, 'createdOn');\n    const createdBy = _.get(result, 'createdBy');\n    const messageId = _.get(result, 'messageId');\n\n    let message = {\n      messageDate: createdOn,\n      createdBy: createdBy,\n      uuid: messageId,\n      requestId: requestId,\n      contentType: contentType,\n    };\n    if (contentType === _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.BACKEND_RESPONSE()) {\n      message.messageType = _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.BACKEND_RESPONSE();\n    } else {\n      message.messageType = _MessageTypes__WEBPACK_IMPORTED_MODULE_2__.MessageTypes.BOT_TO_BOT();\n      message.messageFromUser = state;\n    }\n    return next(message, state, previousMessages, botContext);\n  }\n};\n\nlet runNlp = state => {\n  let D = state.developer;\n  let nlpBotsList = state.nlp.nlpIds;\n  state.developer.info({ message: 'Starting NLP event', data: nlpBotsList });\n  if (!state.inSilence && (state.messageTypeFromUser === 'string' || state.messageFromUser?.intentId === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS)) {\n    if (state.nlp.nlpEngine === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.NLP.ENGINES.DIALOGFLOW) {\n      if (nlpBotsList.length > 0) {\n        let params = {\n          capability: 'NLP2',\n          capabilityFileName: 'nlpv2',\n          queryString: state.messageFromUser,\n          nlpIds: nlpBotsList,\n          sync: true,\n          userId: state.user.userId,\n          conversation: state.conversation,\n        };\n        return state.callCapability(params);\n      } else {\n        state.developer.warning({ message: 'No NLP Engine added to the bot' });\n      }\n      return [];\n    } else if (state.nlp.nlpEngine === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.NLP.ENGINES.OPEN_AI) {\n      return state.nlp.callOpenAIWithMessageFromUser({\n        service: _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.LLM_SERVICE.CHAT\n      })\n    } else {\n      return new Promise((resolve, reject) => {\n        const params = {\n          botAlias: state.nlp.nlpAlias,\n          botName: state.nlp.nlpIds[0],\n          inputText: state.messageFromUser,\n          userId: state.conversationId,\n          sessionAttributes: {},\n        };\n        let lexRuntime = new state.aws.LexRuntime();\n        lexRuntime.postText(params, function (err, data) {\n          if (err) resolve(err);\n          else resolve(data);\n        });\n      });\n    }\n  }\n};\n\nlet processNLPResponse = (state, dataArray) => {\n  let _ = state._;\n  let startNLP = Date.now();\n  if (state.nlp.nlpEngine === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.NLP.ENGINES.DIALOGFLOW) {\n    _.each(dataArray, nlpResponse => {\n      state.developer.info({ message: 'Response from NLP', data: nlpResponse });\n      if (nlpResponse.error === 'Invalid NLP ID') {\n        state.addSystemErrorToStack(24, nlpResponse.nlpId);\n        return;\n      }\n      let nlpParameters = '';\n      let action = nlpResponse.action;\n      let nlpId = nlpResponse.nlpId;\n      state.developer.info({ message: 'Found NLP action: ', data: action });\n      if (nlpResponse.parameters && _.size(nlpResponse.parameters) > 0) {\n        nlpParameters = nlpResponse.parameters;\n        state.developer.info({ message: 'Found NLP parameters: ', data: nlpParameters });\n      }\n      let suggestions = [];\n      if (nlpResponse.messages) {\n        _.forEach(nlpResponse.messages, entry => {\n          if (entry.type === 4) {\n            if (entry.payload.messages) {\n              state.addSmartSuggestionsArray([\n                {\n                  lang: state.lang,\n                  list: entry.payload.messages,\n                },\n              ]);\n              suggestions = entry.payload.messages;\n            }\n          }\n        });\n      }\n      state.nlpResults[nlpId] = {\n        speech: '',\n      };\n      if (nlpResponse.speech && nlpResponse.speech !== '') {\n        state.nlpResults[nlpId].speech = nlpResponse.speech;\n      }\n      state.nlpResults[nlpId].action = action;\n      //state.nlpResults[nlpId].nlpResponse = nlpResponse;\n      state.nlpResults[nlpId].nlpParameters = state.nlp.getNlpParameters(nlpParameters);\n      state.nlpResults[nlpId].nlpSuggestions = suggestions;\n    });\n  } else {\n    let nlpId = state.nlp.nlpIds[0];\n    state.nlpResults[nlpId] = {\n      action: dataArray.intentName,\n      nlpParameters: dataArray.slots,\n    };\n    if (dataArray.message !== '') {\n      state.nlpResults[nlpId].speech = dataArray.message;\n    }\n  }\n  state.developer.logCurrentEventDurationWithStartTime('nlpAnalysis', startNLP, Date.now());\n};\n\nlet matchingLogic = async state => {\n  let _ = state._;\n  let R = state.R;\n  let D = state.developer;\n  if (state.developer.isDeveloperIntent()) {\n    let devIntent = state.developer.identifyDeveloperIntent();\n    if (devIntent) {\n      state.addActiveIntent(devIntent, false);\n      return\n    }\n  }\n  state.developer.info({ message: 'Starting matching logic' });\n  if (state.fromGreeting && !state.inSilence && state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.CLOUD) {\n    state.developer.info({ message: 'No matching required' });\n  } else {\n    if (state.activeIntent === '') {\n      await runMatchers(state);\n      if (state.activeIntent === '') {\n        let startNLP = Date.now();\n        let data = (state.location === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.CLOUD || state.client === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.WEBCLIENT) ? await runNlp(state) : [];\n        D.logCurrentEventDurationWithStartTime('nlpCalls', startNLP, Date.now());\n        D.debug({ message: 'Before processing NLP', data });\n        if (Array.isArray(data)) {\n          if (data.length > 0) {\n            processNLPResponse(state, data);\n          }\n        } else if (data && typeof data === \"string\") {\n          state.nlpResults[state.nlp.assistantName] = {\n            speech: data\n          }\n        } else if (data && typeof data === \"object\") {\n          state.nlpResults[state.nlp.assistantName] = data\n        }\n        await runMatchers(state);\n      }\n      if (state.activeIntent === '') {\n        if (_.size(state.nlpResults) > 0) {\n          let unambiguousResults = true;\n          let latestNoIntentSpeech = \"Sorry, I didn't get that\";\n          _.each(state.nlpResults, result => {\n            if (result.speech !== '') {\n              if (result.action === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT) {\n                latestNoIntentSpeech = result.speech;\n                state.addActiveIntent(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT);\n              } else {\n                if (unambiguousResults) {\n                  state.addActiveIntent(_Intent__WEBPACK_IMPORTED_MODULE_0__.Intent.SPEECH());\n                  state.addStringResponse(result.speech);\n                  unambiguousResults = false;\n                } else {\n                  if (!state.disambiguate) {\n                    state.addSystemErrorToStack(22);\n                  }\n                }\n              }\n            }\n          });\n          if (state.responsesArray.length === 0) {\n            state.addStringResponse(latestNoIntentSpeech);\n          }\n        }\n      } else {\n        if (state.messageFromUser?.intentId === _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.SYSTEM_INTENTS.GET_RELEVANT_QUESTIONS) {\n          let smartSuggestionsArray = state.nlpResults[state.nlp.assistantName]?.q || [];\n          if (smartSuggestionsArray.length > 0) {\n            state.addEnglishSmartSuggestions(smartSuggestionsArray);\n          } else {\n            state.addSilentResponse()\n          }\n        }\n      }\n    } else {\n      state.developer.info({ message: 'Intent already matched ', data: state.activeIntent });\n    }\n    await state.recordActivity();\n  }\n};\n\nlet asyncRequest = function (params, dependencies, botContext) {\n  let Promise = dependencies.promise;\n  let _ = dependencies._;\n  let R = dependencies.R;\n  let start = Date.now();\n  let startAutoSaveBuffer = 0;\n  let stateFromEdge = params.state;\n  let conversationFromEdge = params.conversation;\n  let userFromEdge = {\n    userId: params.userId,\n    userEmail: params.userEmail,\n    userDomains: params.userDomains,\n    userName: params.state.userName,\n    tz: params.userTimezone\n  };\n  let emptyMessage = null;\n  if (stateFromEdge.v1Compatibility) {\n    userFromEdge.info = {};\n    userFromEdge.info.userName = params.state.userName;\n    userFromEdge.info.domains = params.userDomains;\n    conversationFromEdge.client = _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.CLIENTS.WEBCLIENT;\n    _State__WEBPACK_IMPORTED_MODULE_1__.state.init(emptyMessage, conversationFromEdge, userFromEdge, _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.EDGE, stateFromEdge, botContext);\n  } else {\n    dependencies.botManifest = botContext.botManifest;\n    _State__WEBPACK_IMPORTED_MODULE_1__.state.init(emptyMessage, conversationFromEdge, userFromEdge, _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.LOCATIONS.CLOUD, stateFromEdge, dependencies);\n  }\n  let greetingIntent = _State__WEBPACK_IMPORTED_MODULE_1__.state.getGreetingIntent();\n  return _State__WEBPACK_IMPORTED_MODULE_1__.state.onStart()\n    .then(() => {\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: 'State initialised (cloud)', data: params });\n      logMessageFromUser();\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) {\n        return Promise.resolve()\n      }\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.runAllOnInits()\n    })\n    .then(() => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) {\n        return Promise.resolve()\n      }\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.syncDataToDB()\n    })\n    .then(() => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) {\n        return Promise.resolve()\n      }\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.sendDelayedNotifications()\n    })\n    .then(() => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) {\n        return Promise.resolve()\n      }\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.fromGreeting) {\n        return _State__WEBPACK_IMPORTED_MODULE_1__.state.resetAutoSaveBuffer()\n      } else {\n        return _State__WEBPACK_IMPORTED_MODULE_1__.state.loadAutoSaveBuffer()\n      }\n    })\n    .then(() => {\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.nlpResults = {};\n      return matchingLogic(_State__WEBPACK_IMPORTED_MODULE_1__.state);\n    })\n    .then(() => {\n      let onInitCloud = greetingIntent.onInitCloud;\n      if (onInitCloud) {\n        return onInitCloud();\n      }\n    })\n    .then(() => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.fromGreeting && !_State__WEBPACK_IMPORTED_MODULE_1__.state.inSilence) {\n        let start = Date.now();\n        let onResolution = greetingIntent.onResolution;\n        if (greetingIntent.onError) {\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.onError = greetingIntent.onError;\n        }\n        if (onResolution) {\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.addActiveIntent('main');\n          return onResolution(_State__WEBPACK_IMPORTED_MODULE_1__.state).then(() => {\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('mainOnResolution', start, Date.now());\n            startAutoSaveBuffer = Date.now();\n            if (_State__WEBPACK_IMPORTED_MODULE_1__.state.inError) {\n              _State__WEBPACK_IMPORTED_MODULE_1__.state.onError();\n            }\n            return _State__WEBPACK_IMPORTED_MODULE_1__.state.storeAutoSaveBuffer().then(() => {\n              return _State__WEBPACK_IMPORTED_MODULE_1__.state.recordActivity();\n            })\n          });\n        } else {\n          return;\n        }\n      }\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.inError) {\n        return;\n      }\n      let startController = Date.now();\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.activeIntent !== '' && _State__WEBPACK_IMPORTED_MODULE_1__.state.activeIntent !== _Intent__WEBPACK_IMPORTED_MODULE_0__.Intent.SPEECH() && _State__WEBPACK_IMPORTED_MODULE_1__.state.activeIntent !== _ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT) {\n        runValidators(_State__WEBPACK_IMPORTED_MODULE_1__.state);\n        if (_.size(_State__WEBPACK_IMPORTED_MODULE_1__.state.errorStack) === 0) {\n          return runResolvers(_State__WEBPACK_IMPORTED_MODULE_1__.state).then(() => {\n            _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('backendController', startController, Date.now());\n            if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) {\n              return Promise.resolve()\n            }\n            startAutoSaveBuffer = Date.now();\n            return _State__WEBPACK_IMPORTED_MODULE_1__.state.storeAutoSaveBuffer();\n          });\n        }\n      }\n    })\n    .then(() => {\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('startAutoSaveBuffer', startAutoSaveBuffer, Date.now());\n      if (_.size(_State__WEBPACK_IMPORTED_MODULE_1__.state.responsesArray) > 0 || _.size(_State__WEBPACK_IMPORTED_MODULE_1__.state.smartSuggestionsArray) > 0 || _State__WEBPACK_IMPORTED_MODULE_1__.state.inError || _State__WEBPACK_IMPORTED_MODULE_1__.state.sendMessageParam || _State__WEBPACK_IMPORTED_MODULE_1__.state.fromGreeting) {\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved = true;\n        if (_State__WEBPACK_IMPORTED_MODULE_1__.state.activeIntent.substring(0, 5) === '_dev_') {\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.removeActiveIntent();\n        }\n      } else {\n        if (_State__WEBPACK_IMPORTED_MODULE_1__.state.cloudIntent) {\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.intentResolved = false;\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: 'Found No intent' });\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.addActiveIntent(_ALLConstants__WEBPACK_IMPORTED_MODULE_4__.ALL_CONSTANTS.INTENTS.NO_INTENT);\n        }\n      }\n      try {\n        if (_.size(_State__WEBPACK_IMPORTED_MODULE_1__.state.errorStack) > 0) {\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.onError(_State__WEBPACK_IMPORTED_MODULE_1__.state);\n          _State__WEBPACK_IMPORTED_MODULE_1__.state.resetOnErrorMethod();\n        }\n      } catch (err) {\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.addSystemErrorToStack(11, err.message);\n      }\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.fromGreeting = false;\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) {\n        return view(_State__WEBPACK_IMPORTED_MODULE_1__.state, botContext);\n      } else {\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.logCurrentEventDurationWithStartTime('fullCustomCap', start, Date.now());\n        let content = _State__WEBPACK_IMPORTED_MODULE_1__.state.getFinalResponseState();\n        _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: 'Sending state to queue', data: content });\n        return _State__WEBPACK_IMPORTED_MODULE_1__.state.sendResponseToClient(content);\n      }\n    })\n    .then(() => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) return\n      let content = _State__WEBPACK_IMPORTED_MODULE_1__.state.getFinalResponseSync();\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: 'Sending data sync to queue', data: content });\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.sendResponseToClient(content);\n    })\n    .then(() => {\n      if (_State__WEBPACK_IMPORTED_MODULE_1__.state.v1Compatibility) return\n      let response = _State__WEBPACK_IMPORTED_MODULE_1__.state.getFinalResponsesArray();\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: 'Sending responses to queue', data: response });\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.apiResponse ? response : _State__WEBPACK_IMPORTED_MODULE_1__.state.sendResponseToClient(response);\n    })\n    .then((responseArray = {}) => {\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.developer.info({ message: 'Ending' });\n      return responseArray;\n    })\n    .catch(error => {\n      _State__WEBPACK_IMPORTED_MODULE_1__.state.addSystemErrorToStack(8, error);\n      return _State__WEBPACK_IMPORTED_MODULE_1__.state.getFinalResponseState();\n    });\n};\n\nlet farewell = function (msg, state, botContext) {};\n\nlet open = function (msg, state, previousMessages, botContext) {\n  if (msg && botContext) {\n    return next(msg, state, previousMessages, botContext);\n  }\n}\n\nlet isActiveWithMessage = function () {\n  return _State__WEBPACK_IMPORTED_MODULE_1__.state.actyiveWithMessage\n}\n\n\n\n\n//# sourceURL=webpack://botModule/../../Bitbucket/frontmjs/core/index.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HELLO_WORLD: function() { return /* binding */ HELLO_WORLD; }\n/* harmony export */ });\nvar HELLO_WORLD = \"Hello world!\";\n\n//# sourceURL=webpack://botModule/./src/constants.js?");

/***/ }),

/***/ "./src/docs.js":
/*!*********************!*\
  !*** ./src/docs.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDocument: function() { return /* binding */ deleteDocument; },\n/* harmony export */   displayOfflineCollection: function() { return /* binding */ displayOfflineCollection; }\n/* harmony export */ });\n/* harmony import */ var frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! frontm.js/core/State */ \"../../Bitbucket/frontmjs/core/State.js\");\n/* harmony import */ var frontm_js_core_Doc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! frontm.js/core/Doc */ \"../../Bitbucket/frontmjs/core/Doc.js\");\n/* harmony import */ var frontm_js_core_Field__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! frontm.js/core/Field */ \"../../Bitbucket/frontmjs/core/Field.js\");\n/* harmony import */ var frontm_js_core_FormFieldTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! frontm.js/core/FormFieldTypes */ \"../../Bitbucket/frontmjs/core/FormFieldTypes.js\");\n/* harmony import */ var frontm_js_core_Collection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! frontm.js/core/Collection */ \"../../Bitbucket/frontmjs/core/Collection.js\");\n/* harmony import */ var frontm_js_core_ALLConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! frontm.js/core/ALLConstants */ \"../../Bitbucket/frontmjs/core/ALLConstants.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\nvar offlineDoc = new frontm_js_core_Doc__WEBPACK_IMPORTED_MODULE_1__.Doc('offineDocTest', frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state, {\n  title: 'Offline Doc',\n  minimizeOnConfirm: true,\n  confirm: 'Save',\n  autoSave: true\n});\nofflineDoc.runOnCloud();\nofflineDoc.onSubmit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        _context.next = 2;\n        return offlineDoc.save();\n      case 2:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _callee);\n}));\nvar firstName = new frontm_js_core_Field__WEBPACK_IMPORTED_MODULE_2__.Field('offlineFirstName', {\n  title: 'First Name',\n  dbName: 'firstName',\n  doc: offlineDoc,\n  type: frontm_js_core_FormFieldTypes__WEBPACK_IMPORTED_MODULE_3__.FormFieldTypes.TEXT_FIELD,\n  state: frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state\n});\nvar lastName = new frontm_js_core_Field__WEBPACK_IMPORTED_MODULE_2__.Field('offlineLastName', {\n  title: 'Last Name',\n  dbName: 'lastName',\n  doc: offlineDoc,\n  type: frontm_js_core_FormFieldTypes__WEBPACK_IMPORTED_MODULE_3__.FormFieldTypes.TEXT_FIELD,\n  state: frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state\n});\nvar email = new frontm_js_core_Field__WEBPACK_IMPORTED_MODULE_2__.Field('offlineEmail', {\n  title: 'Email',\n  dbName: 'email',\n  doc: offlineDoc,\n  primaryKey: true,\n  mandatory: true,\n  type: frontm_js_core_FormFieldTypes__WEBPACK_IMPORTED_MODULE_3__.FormFieldTypes.TEXT_FIELD,\n  state: frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state\n});\nvar offileCollection = new frontm_js_core_Collection__WEBPACK_IMPORTED_MODULE_4__.Collection('offlineCollection', {\n  title: 'Offile Test',\n  document: offlineDoc,\n  version: 3,\n  style: frontm_js_core_ALLConstants__WEBPACK_IMPORTED_MODULE_5__.ALL_CONSTANTS.COLLECTION_TYPES.TABLE,\n  confirmAction: 'New',\n  state: frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state\n});\noffileCollection.runOnCloud();\noffileCollection.onConfirm = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state.currentTabId = 'editDoc';\n        offlineDoc.sendShortResponse();\n      case 2:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _callee2);\n}));\noffileCollection.onQuickAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state.currentTabId = 'editDoc';\n        _context3.next = 3;\n        return offlineDoc.loadDocument({\n          email: \"test@test.com\"\n        });\n      case 3:\n        offlineDoc.sendShortResponse();\n      case 4:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, _callee3);\n}));\nvar displayOfflineCollection = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var query,\n      _args4 = arguments;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          query = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n          frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state.currentTabId = 'showOfflineTable';\n          _context4.next = 4;\n          return offileCollection.loadCollectionWithQuery({\n            query: query\n          });\n        case 4:\n          offileCollection.sendShortResponse();\n        case 5:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return function displayOfflineCollection() {\n    return _ref4.apply(this, arguments);\n  };\n}();\nvar deleteDocument = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(emailName) {\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          email.value = emailName;\n          _context5.next = 3;\n          return offlineDoc[\"delete\"]();\n        case 3:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return function deleteDocument(_x) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\n\n//# sourceURL=webpack://botModule/./src/docs.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   main: function() { return /* binding */ main; }\n/* harmony export */ });\n/* harmony import */ var frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! frontm.js/core/State */ \"../../Bitbucket/frontmjs/core/State.js\");\n/* harmony import */ var frontm_js_core_Intent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! frontm.js/core/Intent */ \"../../Bitbucket/frontmjs/core/Intent.js\");\n/* harmony import */ var frontm_js_core_Developer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! frontm.js/core/Developer */ \"../../Bitbucket/frontmjs/core/Developer.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n/* harmony import */ var _docs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./docs */ \"./src/docs.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\nfrontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state.onStart = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.D.runProfile = frontm_js_core_Developer__WEBPACK_IMPORTED_MODULE_2__.Developer.DEV();\n        frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state.conversational = true;\n        frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state.systemId = 'helloWorld';\n      case 3:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _callee);\n}));\nvar main = new frontm_js_core_Intent__WEBPACK_IMPORTED_MODULE_1__.Intent('main', frontm_js_core_State__WEBPACK_IMPORTED_MODULE_0__.state);\nmain.runOnCloud();\nmain.onResolution = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        _context2.next = 2;\n        return (0,_docs__WEBPACK_IMPORTED_MODULE_4__.displayOfflineCollection)();\n      case 2:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _callee2);\n}));\n\n//# sourceURL=webpack://botModule/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../../Bitbucket/frontmjs/core/index.js");
/******/ 	botModule = __webpack_exports__;
/******/ 	
/******/ })()
; 
    return botModule;
})()
